
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarkov Raid Planner v1.0 Beta</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root { --bg-black: #0a0a0a; --bg-dark: #0e0e0e; --bg-panel: #121212; --bg-element: #1a1a1a; --bg-hover: #252525; --border-dark: #2a2a2a; --border-gold: #9e8f6b; --text-main: #d0d0d0; --text-sub: #888; --text-beige: #d2c4a6; --eft-gold: #9e8f6b; --eft-gold-bright: #c4b896; --eft-red: #8c3b3b; --eft-green: #4a7a4a; --eft-blue: #4a6a8a; --tier-s: #ffd700; --tier-a: #c0c0c0; --tier-b: #cd7f32; --tier-c: #5a9e5a; --tier-d: #5a7a9e; --tier-f: #9e5a5a; }
        * { box-sizing: border-box; }
        body { background-color: var(--bg-black); color: var(--text-main); font-family: 'Rajdhani', 'Segoe UI', sans-serif; font-size: 0.95rem; line-height: 1.5; min-height: 100vh; }
        h1, h2, h3, h4, h5 { color: var(--text-beige); font-family: 'Rajdhani', sans-serif; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; }
        .text-beige { color: var(--text-beige) !important; } .text-sub { color: var(--text-sub) !important; } .text-gold { color: var(--eft-gold) !important; }
        .container { max-width: 1500px; margin-top: 20px; }
        
        /* Header with status indicator */
        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .header-row h1 { margin: 0; font-size: 1.8rem; }
        .status-indicator { display: flex; align-items: center; gap: 10px; background: var(--bg-element); border: 1px solid var(--border-dark); padding: 8px 15px; font-size: 0.85rem; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--eft-green); animation: pulse 2s infinite; }
        .status-dot.offline { background: var(--eft-red); animation: none; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .nav-tabs-tarkov { border-bottom: 2px solid var(--border-gold); margin-bottom: 30px; display: flex; gap: 0; }
        .nav-tab { background: var(--bg-panel); border: 1px solid var(--border-dark); border-bottom: none; color: var(--text-sub); padding: 15px 40px; font-family: 'Rajdhani', sans-serif; font-size: 1.1rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; cursor: pointer; transition: all 0.2s ease; position: relative; top: 2px; }
        .nav-tab:hover { background: var(--bg-element); color: var(--text-beige); }
        .nav-tab.active { background: var(--bg-dark); color: var(--text-beige); border-color: var(--border-gold); border-bottom: 2px solid var(--bg-dark); }
        .tab-content { display: none; } .tab-content.active { display: block; }
        .tarkov-panel { background: var(--bg-panel); border: 1px solid var(--border-dark); border-radius: 0; padding: 20px; margin-bottom: 20px; }
        .tarkov-panel h5 { border-bottom: 1px solid var(--border-gold); padding-bottom: 10px; margin-bottom: 15px; font-size: 1rem; }
        .btn-tarkov { background: linear-gradient(180deg, var(--bg-element) 0%, var(--bg-dark) 100%); border: 1px solid var(--border-gold); color: var(--text-beige); font-family: 'Rajdhani', sans-serif; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; padding: 10px 20px; transition: all 0.2s ease; }
        .btn-tarkov:hover { background: linear-gradient(180deg, var(--bg-hover) 0%, var(--bg-element) 100%); color: var(--eft-gold-bright); border-color: var(--eft-gold-bright); }
        .btn-tarkov:disabled { opacity: 0.5; cursor: not-allowed; }
        .trader-group { background: var(--bg-element); border: 1px solid var(--border-dark); margin-bottom: 10px; }
        .trader-header { display: flex; align-items: center; gap: 15px; padding: 15px; cursor: pointer; transition: background 0.2s; }
        .trader-header:hover { background: var(--bg-hover); }
        .trader-header img { width: 50px; height: 50px; border-radius: 0; border: 1px solid var(--border-gold); }
        .trader-header h6 { margin: 0; font-size: 1.1rem; flex-grow: 1; }
        .trader-quests { display: none; padding: 0 15px 15px; }
        .trader-quests.show { display: block; }
        .quest-row { display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg-dark); border: 1px solid var(--border-dark); margin-bottom: 6px; cursor: pointer; transition: all 0.15s ease; position: relative; }
        .quest-row:hover { background: var(--bg-hover); border-color: var(--eft-gold); }
        .quest-row.selected { background: rgba(158, 143, 107, 0.15); border-color: var(--eft-gold); }
        .quest-row.completed { opacity: 0.6; background: rgba(74, 122, 74, 0.1); border-color: var(--eft-green); }
        .quest-row.completed .quest-name { text-decoration: line-through; color: var(--text-sub); }
        .quest-row.completed .complete-btn { background: var(--eft-green); color: #fff; }
        .quest-row input[type="checkbox"] { width: 18px; height: 18px; accent-color: var(--eft-gold); cursor: pointer; flex-shrink: 0; }
        .complete-btn { background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-sub); padding: 2px 6px; font-size: 0.65rem; cursor: pointer; transition: all 0.15s; border-radius: 2px; flex-shrink: 0; }
        .complete-btn:hover { background: var(--eft-green); color: #fff; border-color: var(--eft-green); }
        .quest-prereqs { font-size: 0.7rem; color: var(--text-sub); margin-top: 3px; }
        .quest-prereqs .prereq-tag { background: var(--bg-element); padding: 1px 5px; margin-right: 4px; border-radius: 2px; display: inline-block; margin-bottom: 2px; }
        .quest-prereqs .prereq-done { color: var(--eft-green); text-decoration: line-through; opacity: 0.7; }
        .quest-prereqs .prereq-pending { color: var(--text-sub); }
        
        /* Hideout Tracker Styles */
        .hideout-station { background: var(--bg-element); border: 1px solid var(--border-dark); margin-bottom: 10px; }
        .hideout-station.maxed { opacity: 0.6; border-color: var(--eft-green); }
        .hideout-station-header { display: flex; align-items: center; gap: 12px; padding: 12px 15px; cursor: pointer; transition: background 0.2s; }
        .hideout-station-header:hover { background: var(--bg-hover); }
        .hideout-station-header img { width: 48px; height: 48px; object-fit: contain; }
        .hideout-station-header .station-info { flex-grow: 1; }
        .hideout-station-header .station-name { font-weight: 600; color: var(--text-beige); font-size: 1rem; }
        .hideout-station-header .station-level { font-size: 0.8rem; color: var(--text-sub); }
        .hideout-station-header .station-level .current { color: var(--eft-gold); font-weight: 600; }
        .hideout-station-levels { display: none; padding: 0 15px 15px; }
        .hideout-station-levels.show { display: block; }
        .hideout-level { background: var(--bg-dark); border: 1px solid var(--border-dark); padding: 12px; margin-bottom: 8px; }
        .hideout-level.completed { border-color: var(--eft-green); background: rgba(74, 122, 74, 0.1); }
        .hideout-level.current-target { border-color: var(--eft-gold); background: rgba(158, 143, 107, 0.1); }
        .hideout-level-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .hideout-level-header h6 { margin: 0; font-size: 0.9rem; color: var(--text-beige); }
        .hideout-level-header .level-status { font-size: 0.75rem; padding: 2px 8px; }
        .hideout-level-header .level-status.done { background: var(--eft-green); color: #fff; }
        .hideout-level-header .level-status.locked { background: var(--bg-element); color: var(--text-sub); }
        .hideout-requirements { display: flex; flex-direction: column; gap: 8px; }
        .hideout-req-section { font-size: 0.8rem; }
        .hideout-req-section .req-title { color: var(--text-sub); margin-bottom: 4px; }
        .hideout-req-items { display: flex; flex-wrap: wrap; gap: 6px; }
        .hideout-req-item { display: flex; align-items: center; gap: 6px; background: var(--bg-element); padding: 4px 8px; font-size: 0.75rem; }
        .hideout-req-item img { width: 24px; height: 24px; object-fit: contain; }
        .hideout-req-item.owned { background: rgba(74, 122, 74, 0.2); border: 1px solid var(--eft-green); }
        .hideout-req-item .item-count { color: var(--eft-gold); font-weight: 600; }
        .hideout-req-item .item-name { color: var(--text-main); max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .level-complete-btn { background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-sub); padding: 4px 12px; font-size: 0.75rem; cursor: pointer; transition: all 0.15s; }
        .level-complete-btn:hover { background: var(--eft-green); color: #fff; border-color: var(--eft-green); }
        .level-complete-btn.completed { background: var(--eft-green); color: #fff; border-color: var(--eft-green); }
        .shopping-item { display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--bg-dark); border: 1px solid var(--border-dark); margin-bottom: 6px; }
        .shopping-item img { width: 32px; height: 32px; object-fit: contain; }
        .shopping-item .item-info { flex-grow: 1; }
        .shopping-item .item-name { font-size: 0.85rem; color: var(--text-main); }
        .shopping-item .item-for { font-size: 0.7rem; color: var(--text-sub); }
        .shopping-item .item-count { color: var(--eft-gold); font-weight: 600; font-size: 0.9rem; }
        .fir-badge { background: var(--eft-red); color: #fff; font-size: 0.6rem; font-weight: 700; padding: 1px 4px; border-radius: 2px; margin-left: 4px; }
        .fir-required { border-left: 2px solid var(--eft-red); }
        .shopping-item .fir-badge { font-size: 0.55rem; }
        
        .quest-info { flex-grow: 1; min-width: 0; }
        .quest-name { font-weight: 600; color: var(--text-beige); font-size: 0.95rem; }
        .quest-name a { color: inherit; text-decoration: none; }
        .quest-name a:hover { text-decoration: underline; color: var(--eft-gold-bright); }
        .quest-meta { font-size: 0.8rem; color: var(--text-sub); display: flex; gap: 15px; flex-wrap: wrap; }
        .badge-tarkov { background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-sub); padding: 4px 10px; font-size: 0.75rem; font-weight: 600; }
        .badge-active { background: rgba(158, 143, 107, 0.2); border-color: var(--eft-gold); color: var(--eft-gold); }
        .form-select-tarkov, .form-control-tarkov { background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-main); padding: 10px 15px; font-family: 'Rajdhani', sans-serif; }
        .form-select-tarkov:focus, .form-control-tarkov:focus { background: var(--bg-hover); border-color: var(--eft-gold); color: var(--text-main); box-shadow: none; outline: none; }
        .form-select-tarkov option { background: var(--bg-dark); color: var(--text-main); }
        .form-select-tarkov option:disabled { color: var(--text-sub); opacity: 0.5; }
        #map { height: 600px; background: var(--bg-dark); border: 1px solid var(--border-dark); overflow: hidden; position: relative; }
        .leaflet-container { overflow: hidden; }
        /* Leaflet panes don't need overflow visible - tooltips work fine without it */
        /* Map pane also doesn't need overflow visible */
        .leaflet-tooltip-pane { z-index: 9999 !important; }
        .leaflet-popup-pane { z-index: 9998 !important; }
        .map-controls { display: flex; align-items: center; gap: 15px; padding: 10px 15px; background: var(--bg-element); border: 1px solid var(--border-dark); border-bottom: none; font-size: 0.85rem; color: var(--text-sub); }
        .map-controls .btn-tarkov { padding: 5px 12px; font-size: 0.8rem; }
        .marker-count { margin-left: auto; color: var(--eft-gold); font-weight: 600; }
        .map-hint { padding: 8px 15px; background: rgba(158, 143, 107, 0.1); border: 1px solid var(--border-dark); border-top: none; font-size: 0.8rem; color: var(--eft-gold); }
        .map-hint.warning { background: rgba(140, 59, 59, 0.15); color: var(--eft-red); }
        .leaflet-container { background: var(--bg-dark); }
        .map-legend { background: var(--bg-element); border: 1px solid var(--border-dark); border-top: none; padding: 10px 15px; }
        .legend-title { font-weight: 600; color: var(--text-beige); font-size: 0.85rem; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .legend-items { display: flex; flex-wrap: wrap; gap: 12px; }
        .legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.8rem; color: var(--text-main); }
        .legend-color { width: 16px; height: 16px; border-radius: 50%; border: 2px solid; flex-shrink: 0; }
        .marker-label { background: rgba(0,0,0,0.95) !important; border: 1px solid var(--eft-gold) !important; color: var(--text-beige) !important; font-family: 'Rajdhani', sans-serif !important; padding: 8px 12px !important; border-radius: 0 !important; box-shadow: 0 4px 12px rgba(0,0,0,0.5) !important; }
        .leaflet-tooltip { white-space: nowrap; z-index: 9999 !important; }
        .leaflet-popup { z-index: 9999 !important; }
        .leaflet-popup-content-wrapper { background: var(--bg-panel) !important; color: var(--text-main) !important; border-radius: 0 !important; border: 1px solid var(--eft-gold) !important; box-shadow: 0 4px 15px rgba(0,0,0,0.6) !important; }
        .leaflet-popup-content { margin: 12px 15px !important; }
        .leaflet-popup-tip { background: var(--bg-panel) !important; border: 1px solid var(--eft-gold) !important; border-top: none !important; border-left: none !important; }
        .leaflet-popup-close-button { color: var(--text-sub) !important; font-size: 20px !important; padding: 8px !important; }
        .leaflet-popup-close-button:hover { color: var(--eft-gold) !important; }
        .quest-marker-popup { min-width: 220px; max-width: 300px; }
        .quest-marker-popup h6 { color: var(--eft-gold); margin-bottom: 8px; font-size: 1rem; font-weight: 600; }
        .quest-marker-popup p { margin: 0; font-size: 0.9rem; color: var(--text-main); line-height: 1.4; }
        .quest-marker-popup .obj-type { display: inline-block; padding: 3px 10px; font-size: 0.75rem; text-transform: uppercase; margin-bottom: 8px; font-weight: 600; letter-spacing: 1px; }
        .quest-marker-popup .obj-num { display: inline-block; background: var(--eft-gold); color: #000; font-weight: 700; padding: 3px 8px; font-size: 0.8rem; margin-right: 8px; }
        .quest-marker-popup .popup-footer { margin-top: 10px; padding-top: 8px; border-top: 1px solid var(--border-dark); font-size: 0.75rem; color: var(--text-sub); }
        .obj-pickup { background: #2d5a2d; color: #7fff7f; }
        .obj-place { background: #5a5a2d; color: #ffff7f; }
        .obj-mark { background: #5a2d5a; color: #ff7fff; }
        .obj-find { background: #2d5a5a; color: #7fffff; }
        .obj-kill { background: #5a2d2d; color: #ff7f7f; }
        .obj-locate { background: #2d2d5a; color: #7f7fff; }
        .marker-number { position: absolute; top: -8px; right: -8px; background: var(--eft-gold); color: #000; font-weight: 700; font-size: 0.65rem; width: 16px; height: 16px; line-height: 16px; text-align: center; border-radius: 50%; }
        .quest-marker-icon { background: transparent !important; border: none !important; }
        .item-box { display: flex; align-items: center; gap: 10px; background: var(--bg-dark); border: 1px solid var(--border-dark); padding: 8px 12px; margin-bottom: 6px; }
        .item-box img { width: 40px; height: 40px; object-fit: contain; }
        .item-label { font-size: 0.65rem; padding: 2px 6px; font-weight: 700; letter-spacing: 1px; }
        .label-find { background: var(--eft-red); color: #fff; }
        .label-given { background: var(--eft-green); color: #fff; }
        .status-provided { border-left: 3px solid var(--eft-green); }
        .status-acquire { border-left: 3px solid var(--eft-red); }
        .unlock-card { background: var(--bg-dark); border: 1px solid var(--border-dark); padding: 12px; margin-bottom: 8px; }
        .unlock-link { color: var(--eft-gold); text-decoration: none; }
        .unlock-link:hover { color: var(--eft-gold-bright); text-decoration: underline; }
        .quest-objectives-group { background: var(--bg-dark); border: 1px solid var(--border-dark); margin-bottom: 10px; padding: 12px; }
        .quest-objectives-header { display: flex; align-items: center; gap: 8px; font-weight: 600; color: var(--text-beige); margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid var(--border-dark); }
        .quest-objectives-list { list-style: none; padding: 0; margin: 0; }
        .quest-objectives-list li { color: var(--text-sub); font-size: 0.9rem; padding: 4px 0; padding-left: 22px; position: relative; }
        .quest-objectives-list .obj-index { position: absolute; left: 0; color: var(--eft-gold); font-weight: 600; }
        .caliber-group { margin-bottom: 20px; }
        .caliber-header { background: var(--bg-element); border: 1px solid var(--border-dark); padding: 10px 15px; font-weight: 600; color: var(--text-beige); margin-bottom: 5px; }
        .ammo-card { display: flex; align-items: center; gap: 10px; background: var(--bg-dark); border: 1px solid var(--border-dark); padding: 10px 12px; margin-bottom: 4px; cursor: pointer; transition: all 0.15s ease; }
        .ammo-card:hover { background: var(--bg-hover); border-color: var(--eft-gold); }
        .ammo-card.owned { background: rgba(74, 122, 74, 0.15); border-color: var(--eft-green); }
        .ammo-card img { width: 45px; height: 45px; object-fit: contain; }
        .ammo-stats { display: flex; gap: 12px; font-size: 0.8rem; color: var(--text-sub); margin-top: 3px; }
        .stat-dmg { color: #e07050; }
        .stat-pen { color: #50a0e0; }
        .stat-price { color: var(--eft-gold); }
        .stat-highlight { font-weight: 700; text-decoration: underline; }
        .tier-source { font-size: 0.65rem; font-weight: 700; padding: 2px 6px; border-radius: 2px; text-transform: uppercase; }
        .source-pen { background: rgba(80, 160, 224, 0.2); color: #50a0e0; }
        .source-dmg { background: rgba(224, 112, 80, 0.2); color: #e07050; }
        .source-both { background: rgba(158, 143, 107, 0.2); color: var(--eft-gold); }
        .tier-badge { display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; font-weight: 700; font-size: 0.85rem; border-radius: 0; flex-shrink: 0; }
        .tier-S { background: linear-gradient(135deg, #ffd700 0%, #b8860b 100%); color: #000; }
        .tier-A { background: linear-gradient(135deg, #e0e0e0 0%, #a0a0a0 100%); color: #000; }
        .tier-B { background: linear-gradient(135deg, #cd7f32 0%, #8b4513 100%); color: #fff; }
        .tier-C { background: linear-gradient(135deg, #5a9e5a 0%, #3a6e3a 100%); color: #fff; }
        .tier-D { background: linear-gradient(135deg, #5a7a9e 0%, #3a5a7e 100%); color: #fff; }
        .tier-F { background: linear-gradient(135deg, #9e5a5a 0%, #7e3a3a 100%); color: #fff; }
        .analysis-panel { display: flex; gap: 20px; }
        .analysis-col { flex: 1; }
        .analysis-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; background: var(--bg-element); border: 1px solid var(--border-dark); margin-bottom: 10px; }
        .analysis-header h6 { margin: 0; font-size: 0.9rem; }
        .analysis-list { max-height: 300px; overflow-y: auto; }
        .search-box { position: relative; margin-bottom: 15px; }
        .search-box input { width: 100%; padding-right: 35px; }
        .loading-spinner { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px; color: var(--text-sub); }
        .spinner { width: 40px; height: 40px; border: 3px solid var(--border-dark); border-top-color: var(--eft-gold); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Tier Editor Styles */
        .tier-config { margin-bottom: 20px; }
        .tier-config-row { display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: var(--bg-dark); border: 1px solid var(--border-dark); margin-bottom: 4px; }
        .tier-config-row .tier-badge { flex-shrink: 0; }
        .tier-config-row label { font-size: 0.8rem; color: var(--text-sub); min-width: 80px; }
        .tier-config-row input[type="number"] { width: 70px; background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-main); padding: 4px 8px; font-family: 'Rajdhani', sans-serif; text-align: center; }
        .tier-config-row input[type="number"]:focus { border-color: var(--eft-gold); outline: none; }
        .tier-override { position: relative; }
        .tier-override-btn { position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-sub); cursor: pointer; padding: 2px 6px; font-size: 0.7rem; }
        .tier-override-btn:hover { color: var(--eft-gold); }
        .ammo-card.overridden { border-left: 3px solid var(--eft-gold); }
        .override-indicator { font-size: 0.65rem; color: var(--eft-gold); margin-left: auto; }
        .tier-select-mini { background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-main); padding: 2px 6px; font-size: 0.75rem; cursor: pointer; }
        
        /* New Tier Config Dropdown System */
        .stat-selector { margin-bottom: 15px; }
        .stat-selector label { display: block; font-size: 0.85rem; color: var(--text-beige); margin-bottom: 8px; }
        .stat-checkboxes { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 12px; }
        .stat-checkbox { display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: var(--bg-dark); border: 1px solid var(--border-dark); cursor: pointer; font-size: 0.75rem; color: var(--text-sub); transition: all 0.2s; }
        .stat-checkbox:hover { border-color: var(--eft-gold); }
        .stat-checkbox.active { background: rgba(158, 143, 107, 0.2); border-color: var(--eft-gold); color: var(--text-beige); }
        .stat-checkbox input { display: none; }
        .threshold-editor { background: var(--bg-dark); border: 1px solid var(--border-dark); padding: 12px; }
        .threshold-editor-header { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .threshold-editor-header select { flex: 1; background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-main); padding: 6px 10px; font-family: 'Rajdhani', sans-serif; }
        .threshold-editor-header select:focus { border-color: var(--eft-gold); outline: none; }
        .threshold-direction { font-size: 0.7rem; color: var(--text-sub); padding: 2px 6px; background: var(--bg-element); }
        .threshold-direction.higher { color: var(--eft-green); }
        .threshold-direction.lower { color: #e07050; }
        .threshold-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; }
        .threshold-item { text-align: center; }
        .threshold-item .tier-badge { display: block; margin: 0 auto 4px; width: 28px; height: 28px; line-height: 28px; }
        .threshold-item input { width: 100%; background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-main); padding: 4px; text-align: center; font-family: 'Rajdhani', sans-serif; font-size: 0.85rem; }
        .threshold-item input:focus { border-color: var(--eft-gold); outline: none; }
        
        /* Inventory Dashboard */
        .inventory-dashboard { background: var(--bg-panel); border: 1px solid var(--border-dark); margin-bottom: 20px; }
        .dashboard-toggle { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; cursor: pointer; color: var(--text-beige); font-size: 0.9rem; }
        .dashboard-toggle:hover { background: var(--bg-element); }
        .dashboard-content { padding: 0 15px 15px; }
        .dashboard-content.collapsed { display: none; }
        .dashboard-grid { display: flex; gap: 15px; flex-wrap: wrap; }
        .dashboard-item { flex: 1; min-width: 120px; background: var(--bg-dark); padding: 10px; text-align: center; border: 1px solid var(--border-dark); }
        .dashboard-item.dashboard-total { background: rgba(158, 143, 107, 0.15); border-color: var(--border-gold); }
        .dash-label { display: block; font-size: 0.75rem; color: var(--text-sub); margin-bottom: 5px; }
        .dash-value { display: block; font-size: 1rem; color: var(--text-beige); font-weight: 600; }
        .dash-percent { display: block; font-size: 0.8rem; color: var(--eft-green); }
        .dash-value-rub { display: block; font-size: 0.75rem; color: var(--eft-gold); margin-top: 3px; }
        
        /* Penetration Matrix */
        .pen-matrix-container { overflow-x: auto; }
        .pen-matrix { border-collapse: collapse; width: 100%; min-width: 600px; font-size: 0.8rem; }
        .pen-matrix th, .pen-matrix td { border: 1px solid var(--border-dark); padding: 6px 8px; text-align: center; }
        .pen-matrix th { background: var(--bg-element); color: var(--text-beige); font-weight: 600; position: sticky; top: 0; }
        .pen-matrix th.caliber-header { background: var(--bg-dark); text-align: left; padding-left: 15px; }
        .pen-matrix td.ammo-name { text-align: left; background: var(--bg-dark); color: var(--text-main); white-space: nowrap; position: sticky; left: 0; }
        .pen-matrix td.ammo-pen { color: var(--text-sub); font-size: 0.75rem; }
        .pen-cell { font-weight: 600; min-width: 50px; }
        .pen-cell.pen-high { background: rgba(74, 140, 74, 0.4); color: #7fff7f; }
        .pen-cell.pen-mid { background: rgba(180, 150, 50, 0.4); color: #ffd700; }
        .pen-cell.pen-low { background: rgba(140, 60, 60, 0.4); color: #ff7f7f; }
        .pen-cell.pen-none { background: rgba(60, 60, 60, 0.3); color: #666; }
        .pen-legend { display: flex; gap: 20px; margin-bottom: 15px; font-size: 0.8rem; flex-wrap: wrap; }
        .pen-legend-item { display: flex; align-items: center; gap: 6px; }
        .pen-legend-color { width: 20px; height: 20px; border: 1px solid var(--border-dark); }
        
        /* Bulk Select */
        .bulk-mode .item-checkbox { display: inline-block !important; }
        .item-checkbox { display: none; margin-right: 8px; accent-color: var(--eft-gold); }
        .bulk-controls { display: none; margin-bottom: 15px; padding: 10px; background: var(--bg-element); border: 1px solid var(--border-gold); }
        .bulk-mode .bulk-controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .bulk-selected { background: rgba(158, 143, 107, 0.2) !important; border-color: var(--eft-gold) !important; }
        
        /* Keyboard Shortcuts Help */
        .shortcuts-help { position: fixed; bottom: 15px; right: 15px; background: var(--bg-panel); border: 1px solid var(--border-dark); padding: 8px 12px; font-size: 0.75rem; color: var(--text-sub); z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.5); }
        .shortcuts-help kbd { background: var(--bg-dark); padding: 2px 6px; border-radius: 3px; margin: 0 2px; color: var(--text-beige); }
        
        /* Quest Item Tracker */
        .item-tracker-progress { display: flex; align-items: center; gap: 10px; }
        .progress-text { font-size: 0.85rem; color: var(--text-beige); font-weight: 600; }
        .progress-bar-mini { width: 80px; height: 6px; background: var(--bg-dark); border: 1px solid var(--border-dark); }
        .progress-fill { height: 100%; background: var(--eft-green); transition: width 0.3s ease; }
        
        .quest-items-group { background: var(--bg-dark); border: 1px solid var(--border-dark); margin-bottom: 10px; }
        .quest-items-header { display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: var(--bg-element); border-bottom: 1px solid var(--border-dark); cursor: pointer; }
        .quest-items-header:hover { background: rgba(158, 143, 107, 0.1); }
        .quest-items-header .quest-color { width: 12px; height: 12px; border-radius: 50%; border: 2px solid; }
        .quest-items-header .quest-name { flex: 1; font-weight: 600; color: var(--text-beige); font-size: 0.85rem; }
        .quest-items-header .quest-item-count { font-size: 0.75rem; color: var(--text-sub); }
        .quest-items-list { padding: 8px; }
        .quest-items-list.collapsed { display: none; }
        
        .tracker-item { display: flex; align-items: center; gap: 10px; padding: 8px 10px; background: var(--bg-panel); border: 1px solid var(--border-dark); margin-bottom: 4px; transition: all 0.2s; }
        .tracker-item:hover { border-color: var(--border-gold); }
        .tracker-item.collected { opacity: 0.6; background: rgba(74, 140, 74, 0.1); border-color: var(--eft-green); }
        .tracker-item.collected .item-name { text-decoration: line-through; }
        .tracker-item img { width: 32px; height: 32px; object-fit: contain; }
        .tracker-item .item-checkbox { accent-color: var(--eft-green); width: 18px; height: 18px; cursor: pointer; }
        .tracker-item .item-info { flex: 1; }
        .tracker-item .item-name { color: var(--text-main); font-size: 0.85rem; }
        .tracker-item .item-meta { font-size: 0.7rem; color: var(--text-sub); display: flex; gap: 8px; margin-top: 2px; }
        .tracker-item .item-count { font-weight: 600; color: var(--eft-gold); }
        .tracker-item .fir-badge { background: var(--eft-green); color: #000; padding: 1px 5px; font-size: 0.65rem; font-weight: 600; }
        .tracker-item .handover-badge { background: var(--eft-gold); color: #000; padding: 1px 5px; font-size: 0.65rem; font-weight: 600; }
        .tracker-item .given-badge { background: #4a8c4a; color: #fff; padding: 1px 5px; font-size: 0.65rem; font-weight: 600; }
        
        .tracker-item .collected-input { display: flex; align-items: center; gap: 5px; }
        .tracker-item .collected-input input { width: 40px; background: var(--bg-dark); border: 1px solid var(--border-dark); color: var(--text-main); text-align: center; padding: 2px; font-size: 0.8rem; }
        .tracker-item .collected-input input:focus { border-color: var(--eft-gold); outline: none; }
        .tracker-item .collected-input span { color: var(--text-sub); font-size: 0.8rem; }
        
        /* Multi-Map Tabs */
        .multi-map-tabs { background: var(--bg-element); border: 1px solid var(--border-dark); border-bottom: none; }
        .map-tabs-container { display: flex; gap: 0; }
        .map-tab { padding: 10px 20px; background: var(--bg-dark); border-right: 1px solid var(--border-dark); cursor: pointer; font-size: 0.85rem; color: var(--text-sub); transition: all 0.2s; }
        .map-tab:hover { background: var(--bg-element); color: var(--text-main); }
        .map-tab.active { background: var(--bg-panel); color: var(--eft-gold); border-bottom: 2px solid var(--eft-gold); }
        .map-tab .tab-quest-count { font-size: 0.7rem; margin-left: 6px; padding: 2px 6px; background: rgba(158, 143, 107, 0.3); border-radius: 3px; }
        
        /* Spawn Layer Controls */
        .map-overlay-controls { display: flex; align-items: center; gap: 15px; padding: 8px 15px; background: var(--bg-dark); border: 1px solid var(--border-dark); border-bottom: none; flex-wrap: wrap; }
        .overlay-title { color: var(--text-sub); font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; }
        .overlay-toggle { display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 4px 10px; background: var(--bg-element); border: 1px solid var(--border-dark); transition: all 0.15s; font-size: 0.8rem; color: var(--text-sub); }
        .overlay-toggle:hover { border-color: var(--eft-gold); color: var(--text-beige); }
        .overlay-toggle:has(input:checked) { background: rgba(158, 143, 107, 0.2); border-color: var(--eft-gold); color: var(--eft-gold); }
        .overlay-toggle input { display: none; }
        .overlay-icon { font-size: 1rem; }
        .overlay-icon.extract-pmc { color: #4CAF50; }
        .overlay-icon.extract-scav { color: #FF9800; }
        .overlay-icon.hazard { color: #f44336; }
        .overlay-icon.locks { color: #9C27B0; }
        
        /* Map Overlay Markers */
        .overlay-marker { border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 14px; box-shadow: 0 2px 6px rgba(0,0,0,0.4); transition: transform 0.15s; cursor: pointer; }
        .overlay-marker:hover { transform: scale(1.15); z-index: 1000 !important; }
        .overlay-marker.extract-pmc { background: rgba(76, 175, 80, 0.9); border: 2px solid #81C784; color: #fff; }
        .overlay-marker.extract-scav { background: rgba(255, 152, 0, 0.9); border: 2px solid #FFB74D; color: #fff; }
        .overlay-marker.hazard { background: rgba(244, 67, 54, 0.9); border: 2px solid #E57373; color: #fff; }
        .overlay-marker.lock { background: rgba(156, 39, 176, 0.9); border: 2px solid #BA68C8; color: #fff; }
        .overlay-popup { min-width: 180px; }
        .overlay-popup h6 { color: var(--eft-gold); margin-bottom: 6px; font-size: 0.95rem; }
        .overlay-popup .overlay-type { font-size: 0.7rem; padding: 2px 6px; display: inline-block; margin-bottom: 6px; border-radius: 2px; }
        .overlay-popup .overlay-type.pmc { background: #4CAF50; color: #fff; }
        .overlay-popup .overlay-type.scav { background: #FF9800; color: #fff; }
        .overlay-popup .overlay-type.shared { background: #2196F3; color: #fff; }
        .overlay-popup .overlay-type.hazard { background: #f44336; color: #fff; }
        .overlay-popup .overlay-type.lock { background: #9C27B0; color: #fff; }
        .overlay-popup .overlay-detail { font-size: 0.8rem; color: var(--text-sub); margin-top: 4px; }
        
        /* Global Loading Screen */
        .global-loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 100%);
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease;
        }
        .global-loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-content {
            text-align: center;
            max-width: 400px;
            padding: 40px;
        }
        .loading-spinner-large {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        .spinner-large {
            width: 60px;
            height: 60px;
            border: 4px solid var(--border-dark);
            border-top: 4px solid var(--eft-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loading-progress-container {
            width: 100%;
            height: 6px;
            background: var(--bg-dark);
            border: 1px solid var(--border-dark);
            border-radius: 3px;
            margin-top: 20px;
            overflow: hidden;
        }
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--eft-gold) 0%, #d4a84b 100%);
            width: 0%;
            transition: width 0.3s ease;
        }
        .loading-checkmark {
            color: #4a8c4a;
            margin-right: 5px;
        }
        .loading-item {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 3px 0;
            color: var(--text-sub);
            font-size: 0.8rem;
        }
        .loading-item.done {
            color: var(--text-main);
        }
        .loading-item.active {
            color: var(--eft-gold);
        }
        .loading-item.error {
            color: var(--eft-red);
        }
        
        /* Login System */
        .auth-buttons {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .user-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--bg-element);
            border: 1px solid var(--eft-gold);
            padding: 5px 12px;
            font-size: 0.8rem;
            color: var(--text-beige);
        }
        .user-badge .user-email {
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .edit-mode-badge {
            background: var(--eft-red);
            color: #fff;
            padding: 3px 8px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: edit-pulse 1.5s infinite;
        }
        @keyframes edit-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .login-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 99998;
            justify-content: center;
            align-items: center;
        }
        .login-modal.show {
            display: flex;
        }
        .login-modal-content {
            background: var(--bg-panel);
            border: 2px solid var(--border-gold);
            padding: 30px;
            max-width: 400px;
            width: 90%;
        }
        .login-modal-content h3 {
            margin-bottom: 20px;
            text-align: center;
        }
        .login-form-group {
            margin-bottom: 15px;
        }
        .login-form-group label {
            display: block;
            color: var(--text-beige);
            font-size: 0.85rem;
            margin-bottom: 5px;
        }
        .login-form-group input {
            width: 100%;
            padding: 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border-dark);
            color: var(--text-main);
            font-size: 0.9rem;
        }
        .login-form-group input:focus {
            outline: none;
            border-color: var(--eft-gold);
        }
        .login-error {
            color: var(--eft-red);
            font-size: 0.8rem;
            margin-bottom: 10px;
            display: none;
        }
        .login-error.show {
            display: block;
        }
        .login-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .login-buttons button {
            flex: 1;
        }
        
        /* Modal Overlay (used for login, etc.) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 99998;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: var(--bg-panel);
            border: 2px solid var(--border-gold);
            padding: 25px;
            width: 90%;
        }
        
        /* Custom Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
            border: 1px solid var(--border-dark);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--bg-hover);
            border: 1px solid var(--border-dark);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--eft-gold);
            border-color: var(--eft-gold);
        }
        ::-webkit-scrollbar-corner {
            background: var(--bg-dark);
        }
        /* Firefox scrollbar */
        #quest-list, .analysis-list, #ammo-list, #weapons-list, #gear-list, #attachments-list {
            scrollbar-width: thin;
            scrollbar-color: var(--bg-hover) var(--bg-dark);
        }
        
        /* Leaflet Zoom Controls Styling */
        .leaflet-control-zoom {
            border: 1px solid var(--border-gold) !important;
            border-radius: 0 !important;
            overflow: hidden;
        }
        .leaflet-control-zoom a {
            background: var(--bg-element) !important;
            color: var(--eft-gold) !important;
            border: none !important;
            border-bottom: 1px solid var(--border-dark) !important;
            width: 30px !important;
            height: 30px !important;
            line-height: 30px !important;
            font-size: 16px !important;
            font-weight: 600 !important;
        }
        .leaflet-control-zoom a:last-child {
            border-bottom: none !important;
        }
        .leaflet-control-zoom a:hover {
            background: var(--eft-gold) !important;
            color: #000 !important;
        }
        .leaflet-control-zoom-in,
        .leaflet-control-zoom-out {
            font-family: 'Rajdhani', sans-serif !important;
        }
        
        /* Draggable Marker Styles (Edit Mode) */
        .leaflet-marker-draggable {
            cursor: move !important;
        }
        .leaflet-marker-draggable > div > div:first-child {
            box-shadow: 0 0 8px 2px var(--eft-gold) !important;
            animation: marker-glow 1.5s ease-in-out infinite;
        }
        @keyframes marker-glow {
            0%, 100% { box-shadow: 0 0 8px 2px var(--eft-gold); }
            50% { box-shadow: 0 0 15px 4px var(--eft-gold-bright); }
        }
        .leaflet-marker-icon.marker-dragging {
            z-index: 10000 !important;
            opacity: 0.8;
        }
        
        /* Edit Mode Button */
        .edit-mode-toggle {
            background: var(--bg-element);
            border: 1px solid var(--border-dark);
            color: var(--text-sub);
            padding: 6px 12px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .edit-mode-toggle:hover {
            border-color: var(--eft-gold);
            color: var(--text-beige);
        }
        .edit-mode-toggle.active {
            background: rgba(158, 143, 107, 0.3);
            border-color: var(--eft-gold);
            color: var(--eft-gold);
        }
        
        /* Correction Save Dialog */
        .correction-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-panel);
            border: 2px solid var(--eft-gold);
            padding: 20px;
            z-index: 100000;
            min-width: 320px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
        .correction-dialog h4 {
            margin: 0 0 15px 0;
            font-size: 1rem;
        }
        .correction-coords {
            background: var(--bg-dark);
            border: 1px solid var(--border-dark);
            padding: 10px;
            margin-bottom: 15px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.85rem;
        }
        .correction-coords .label {
            color: var(--text-sub);
            font-size: 0.75rem;
            margin-bottom: 3px;
        }
        .correction-coords .old-coords {
            color: var(--eft-red);
            text-decoration: line-through;
        }
        .correction-coords .new-coords {
            color: var(--eft-green);
        }
        .correction-dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .correction-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 99999;
        }
    </style>
</head>
<body>
    <!-- Global Loading Screen -->
    <div id="globalLoadingScreen" class="global-loading-screen">
        <div class="loading-content">
            <h1 style="color: var(--eft-gold); margin-bottom: 20px; font-family: 'Rajdhani', sans-serif;">TARKOV RAID PLANNER</h1>
            <div class="loading-spinner-large">
                <div class="spinner-large"></div>
            </div>
            <div id="loadingStatus" style="color: var(--text-main); margin-top: 20px; font-size: 0.9rem;">Initializing...</div>
            <div class="loading-progress-container">
                <div class="loading-progress-bar" id="loadingProgressBar"></div>
            </div>
            <div id="loadingDetails" style="color: var(--text-sub); margin-top: 10px; font-size: 0.75rem;"></div>
        </div>
    </div>
    
    <div class="container">
        <div class="header-row">
            <h1>Tarkov Raid Planner</h1>
            <div style="display: flex; align-items: center; gap: 15px;">
                <!-- Edit Mode Badge (hidden by default) -->
                <div id="editModeBadge" class="edit-mode-badge" style="display: none;">
                    ‚úèÔ∏è EDIT MODE
                </div>
                <!-- Auth Buttons -->
                <div id="authButtons" class="auth-buttons">
                    <button id="loginBtn" class="btn-tarkov" onclick="showLoginModal()" style="padding: 6px 12px; font-size: 0.75rem;">üîë Login</button>
                    <div id="userInfo" style="display: none; align-items: center; gap: 8px;">
                        <span id="userEmail" style="color: var(--text-sub); font-size: 0.75rem;"></span>
                        <button id="editModeBtn" class="edit-mode-toggle" onclick="toggleEditMode()" title="Toggle marker editing (Ctrl+Shift+E)">‚úèÔ∏è Edit Markers</button>
                        <button class="btn-tarkov" onclick="logout()" style="padding: 6px 12px; font-size: 0.75rem;">Logout</button>
                    </div>
                </div>
                <div class="config-buttons" style="display: flex; gap: 8px;">
                    <button class="btn-tarkov" onclick="exportConfig()" style="padding: 6px 12px; font-size: 0.75rem;" title="Export configuration">üì• Export</button>
                    <button class="btn-tarkov" onclick="showImportModal()" style="padding: 6px 12px; font-size: 0.75rem;" title="Import configuration">üì§ Import</button>
                    <button class="btn-tarkov" onclick="toggleShortcutsHelp()" style="padding: 6px 12px; font-size: 0.75rem;" title="Keyboard shortcuts (?)">‚å®Ô∏è</button>
                </div>
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Connecting...</span>
                </div>
            </div>
        </div>
        
        <!-- Login Modal -->
        <div id="loginModal" class="modal-overlay" style="display: none;">
            <div class="modal-content" style="max-width: 400px;">
                <h5 style="color: var(--text-beige); margin-bottom: 20px;">üîë Contributor Login</h5>
                <div id="loginError" style="display: none; background: rgba(140, 59, 59, 0.3); border: 1px solid var(--eft-red); padding: 10px; margin-bottom: 15px; color: var(--eft-red); font-size: 0.85rem;"></div>
                <div style="margin-bottom: 15px;">
                    <label style="color: var(--text-sub); font-size: 0.8rem; display: block; margin-bottom: 5px;">Email</label>
                    <input type="email" id="loginEmail" class="form-control-tarkov w-100" placeholder="your@email.com" style="padding: 10px;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="color: var(--text-sub); font-size: 0.8rem; display: block; margin-bottom: 5px;">Password</label>
                    <input type="password" id="loginPassword" class="form-control-tarkov w-100" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" style="padding: 10px;" onkeypress="if(event.key==='Enter')doLogin()">
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn-tarkov" onclick="hideLoginModal()" style="padding: 8px 20px; background: var(--bg-dark);">Cancel</button>
                    <button class="btn-tarkov" onclick="doLogin()" id="loginSubmitBtn" style="padding: 8px 20px;">Login</button>
                </div>
                <p style="color: var(--text-sub); font-size: 0.75rem; margin-top: 15px; text-align: center;">
                    Contributors can correct marker positions.<br>
                    Contact admin for an account.
                </p>
            </div>
        </div>
        
        <!-- Import Modal -->
        <div id="importModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 9999; justify-content: center; align-items: center;">
            <div style="background: var(--bg-panel); border: 2px solid var(--border-gold); padding: 25px; max-width: 500px; width: 90%;">
                <h5 style="color: var(--text-beige); margin-bottom: 15px;">Import Configuration</h5>
                <p style="color: var(--text-sub); font-size: 0.85rem; margin-bottom: 15px;">Paste your share code or JSON below, or upload a file:</p>
                <textarea id="importTextarea" style="width: 100%; height: 150px; background: var(--bg-dark); border: 1px solid var(--border-dark); color: var(--text-main); padding: 10px; font-family: monospace; font-size: 0.8rem; resize: vertical;" placeholder="Paste share code or JSON here..."></textarea>
                <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <label class="btn-tarkov" style="padding: 8px 15px; cursor: pointer;">
                        üìÅ Upload File
                        <input type="file" accept=".json" onchange="importFromFile(event)" style="display: none;">
                    </label>
                    <button class="btn-tarkov" onclick="importFromText()" style="padding: 8px 15px;">‚úì Apply</button>
                    <button class="btn-tarkov" onclick="hideImportModal()" style="padding: 8px 15px; background: var(--bg-dark);">Cancel</button>
                </div>
            </div>
        </div>
        
        <!-- Export Modal -->
        <div id="exportModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 9999; justify-content: center; align-items: center;">
            <div style="background: var(--bg-panel); border: 2px solid var(--border-gold); padding: 25px; max-width: 500px; width: 90%;">
                <h5 style="color: var(--text-beige); margin-bottom: 15px;">Export Configuration</h5>
                <p style="color: var(--text-sub); font-size: 0.85rem; margin-bottom: 10px;">Choose how to export your configuration:</p>
                
                <div style="margin-bottom: 20px;">
                    <label style="color: var(--text-beige); font-size: 0.85rem; display: block; margin-bottom: 8px;">üìã Share Code (for Discord, etc.):</label>
                    <textarea id="exportCode" readonly style="width: 100%; height: 80px; background: var(--bg-dark); border: 1px solid var(--border-dark); color: var(--text-main); padding: 10px; font-family: monospace; font-size: 0.75rem; resize: none;"></textarea>
                    <button class="btn-tarkov" onclick="copyExportCode()" style="margin-top: 8px; padding: 6px 15px; font-size: 0.85rem;">üìã Copy Code</button>
                </div>
                
                <div style="border-top: 1px solid var(--border-dark); padding-top: 15px; margin-top: 10px;">
                    <label style="color: var(--text-beige); font-size: 0.85rem; display: block; margin-bottom: 8px;">üíæ Download as file:</label>
                    <button class="btn-tarkov" onclick="downloadExportFile()" style="padding: 8px 15px;">üì• Download .json</button>
                </div>
                
                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn-tarkov" onclick="hideExportModal()" style="padding: 8px 15px; background: var(--bg-dark);">Close</button>
                </div>
            </div>
        </div>
        
        <!-- Raid Share Modal -->
        <div id="raidShareModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 9999; justify-content: center; align-items: center;">
            <div style="background: var(--bg-panel); border: 1px solid var(--eft-gold); padding: 25px; max-width: 550px; width: 90%;">
                <h5 style="color: var(--eft-gold); margin-bottom: 15px;">üì§ Share Raid Plan</h5>
                
                <div id="raidShareSummary" style="background: var(--bg-dark); padding: 10px; margin-bottom: 15px; font-size: 0.85rem; border: 1px solid var(--border-dark);"></div>
                
                <!-- Import Code -->
                <div style="margin-bottom: 15px;">
                    <p class="text-sub small mb-2">üì¶ Import Code (for the app):</p>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="raidShareCode" class="form-control-tarkov" readonly style="flex: 1; font-family: monospace; font-size: 0.75rem;">
                        <button class="btn-tarkov" onclick="copyRaidCode()" style="padding: 8px 15px;">üìã Copy</button>
                    </div>
                </div>
                
                <!-- Discord Text -->
                <div style="margin-bottom: 15px;">
                    <p class="text-sub small mb-2">üí¨ Discord Message:</p>
                    <textarea id="raidShareText" class="form-control-tarkov" readonly style="width: 100%; height: 120px; font-family: monospace; font-size: 0.75rem; resize: none;"></textarea>
                    <button class="btn-tarkov w-100 mt-2" onclick="copyRaidText()" style="padding: 8px 15px;">üìã Copy for Discord</button>
                </div>
                
                <div style="text-align: right;">
                    <button class="btn-tarkov" onclick="hideRaidShareModal()" style="padding: 8px 15px; background: var(--bg-dark);">Close</button>
                </div>
            </div>
        </div>
        
        <!-- Raid Import Modal -->
        <div id="raidImportModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 9999; justify-content: center; align-items: center;">
            <div style="background: var(--bg-panel); border: 1px solid var(--eft-gold); padding: 25px; max-width: 500px; width: 90%;">
                <h5 style="color: var(--eft-gold); margin-bottom: 15px;">üì• Import Raid Plan</h5>
                <p class="text-sub small mb-3">Paste the raid code from your squadmate:</p>
                
                <input type="text" id="raidImportCode" class="form-control-tarkov w-100 mb-3" placeholder="Paste raid code here..." style="font-family: monospace;">
                
                <div id="raidImportPreview" style="display: none; background: var(--bg-dark); padding: 10px; margin-bottom: 15px; font-size: 0.85rem; border: 1px solid var(--border-dark);"></div>
                
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn-tarkov" onclick="hideRaidImportModal()" style="padding: 8px 15px; background: var(--bg-dark);">Cancel</button>
                    <button class="btn-tarkov" onclick="importRaidPlan()" id="btnImportRaid" style="padding: 8px 15px;">üéØ Load Raid</button>
                </div>
            </div>
        </div>
        
        <!-- Correction Dialog (for editing marker positions) -->
        <div id="correctionDialogOverlay" class="correction-dialog-overlay" style="display: none;">
            <div class="correction-dialog">
                <h4>üìç Save Marker Correction</h4>
                <div class="correction-quest-info">
                    <strong id="correctionQuestName">Quest Name</strong>
                    <div class="text-sub" style="font-size: 0.8rem;" id="correctionObjective">Objective description</div>
                </div>
                <div class="correction-coords">
                    <div class="coord-row">
                        <span class="label">Original:</span>
                        <span class="old-coords" id="correctionOldCoords">(0.0%, 0.0%)</span>
                    </div>
                    <div class="coord-row">
                        <span class="label">New:</span>
                        <span class="new-coords" id="correctionNewCoords">(0.0%, 0.0%)</span>
                    </div>
                    <div class="coord-row" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-dark);">
                        <span class="label">Delta:</span>
                        <span class="text-gold" id="correctionDelta">(+0.0%, +0.0%)</span>
                    </div>
                </div>
                <div class="correction-dialog-buttons">
                    <button class="btn-tarkov" onclick="cancelCorrection()" style="background: var(--bg-dark);">Cancel</button>
                    <button class="btn-tarkov" onclick="saveCorrection()" id="saveCorrectionBtn">üíæ Save Correction</button>
                </div>
                <p class="text-sub" style="font-size: 0.7rem; margin-top: 10px; text-align: center;">
                    Corrections are saved to the database and help improve marker accuracy for everyone.
                </p>
            </div>
        </div>
        
        <div class="nav-tabs-tarkov">
            <div class="nav-tab active" onclick="switchTab('planner')">Mission Planner</div>
            <div class="nav-tab" onclick="switchTab('hideout')">Hideout</div>
            <div class="nav-tab" onclick="switchTab('penetration')">Pen Chart</div>
            <div class="nav-tab" onclick="switchTab('ammo')">Ammo</div>
            <div class="nav-tab" onclick="switchTab('weapons')">Weapons</div>
            <div class="nav-tab" onclick="switchTab('gear')">Gear</div>
            <div class="nav-tab" onclick="switchTab('attachments')">Attachments</div>
        </div>
        
        <!-- INVENTORY DASHBOARD -->
        <div id="inventoryDashboard" class="inventory-dashboard" style="display: none;">
            <div class="dashboard-toggle" onclick="toggleDashboard()">
                <span>üìä Inventory Overview</span>
                <span id="dashboardArrow">‚ñº</span>
            </div>
            <div id="dashboardContent" class="dashboard-content">
                <div class="dashboard-grid">
                    <div class="dashboard-item">
                        <span class="dash-label">Ammo</span>
                        <span class="dash-value" id="dash-ammo-count">0/0</span>
                        <span class="dash-percent" id="dash-ammo-pct">0%</span>
                        <span class="dash-value-rub" id="dash-ammo-value">0 ‚ÇΩ</span>
                    </div>
                    <div class="dashboard-item">
                        <span class="dash-label">Weapons</span>
                        <span class="dash-value" id="dash-weapons-count">0/0</span>
                        <span class="dash-percent" id="dash-weapons-pct">0%</span>
                        <span class="dash-value-rub" id="dash-weapons-value">0 ‚ÇΩ</span>
                    </div>
                    <div class="dashboard-item">
                        <span class="dash-label">Gear</span>
                        <span class="dash-value" id="dash-gear-count">0/0</span>
                        <span class="dash-percent" id="dash-gear-pct">0%</span>
                        <span class="dash-value-rub" id="dash-gear-value">0 ‚ÇΩ</span>
                    </div>
                    <div class="dashboard-item">
                        <span class="dash-label">Attachments</span>
                        <span class="dash-value" id="dash-attachments-count">0/0</span>
                        <span class="dash-percent" id="dash-attachments-pct">0%</span>
                        <span class="dash-value-rub" id="dash-attachments-value">0 ‚ÇΩ</span>
                    </div>
                    <div class="dashboard-item dashboard-total">
                        <span class="dash-label">TOTAL</span>
                        <span class="dash-value" id="dash-total-count">0</span>
                        <span class="dash-percent" id="dash-total-pct">0%</span>
                        <span class="dash-value-rub" id="dash-total-value">0 ‚ÇΩ</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- MISSION PLANNER TAB -->
        <div id="tab-planner" class="tab-content active">
            <div class="row">
                <div class="col-lg-5">
                    <div class="tarkov-panel">
                        <h5>Select Tasks</h5>
                        <div class="search-box" style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" class="form-control-tarkov" placeholder="Search tasks..." id="questSearch" oninput="filterQuests()" style="flex: 1;">
                            <select id="levelFilter" class="form-select-tarkov" onchange="filterQuests()" style="width: auto; padding: 8px 12px; font-size: 0.85rem;">
                                <option value="0">All Levels</option>
                                <option value="5">‚â§ Lvl 5</option>
                                <option value="10">‚â§ Lvl 10</option>
                                <option value="15">‚â§ Lvl 15</option>
                                <option value="20">‚â§ Lvl 20</option>
                                <option value="25">‚â§ Lvl 25</option>
                                <option value="30">‚â§ Lvl 30</option>
                                <option value="40">‚â§ Lvl 40</option>
                                <option value="50">‚â§ Lvl 50</option>
                            </select>
                        </div>
                        <div class="quest-list-controls" style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; margin-bottom: 8px; border-bottom: 1px solid var(--border-dark);">
                            <span class="text-sub small"><span id="selectedQuestCount">0</span> tasks selected</span>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.75rem; color: var(--text-sub);">
                                    <input type="checkbox" id="hideCompletedToggle" onchange="filterQuests()" style="width: 14px; height: 14px; accent-color: var(--eft-gold);">
                                    Hide done
                                </label>
                                <div class="group-toggle" style="display: flex; background: var(--bg-dark); border: 1px solid var(--border-dark); border-radius: 3px; overflow: hidden;">
                                    <button id="groupByTrader" class="group-toggle-btn active" onclick="setQuestGrouping('trader')" style="padding: 3px 8px; font-size: 0.7rem; border: none; background: var(--eft-gold); color: #000; cursor: pointer;">Trader</button>
                                    <button id="groupByMap" class="group-toggle-btn" onclick="setQuestGrouping('map')" style="padding: 3px 8px; font-size: 0.7rem; border: none; background: transparent; color: var(--text-sub); cursor: pointer;">Map</button>
                                </div>
                                <button class="btn-tarkov" onclick="deselectAllQuests()" style="padding: 4px 10px; font-size: 0.75rem;">Deselect All</button>
                            </div>
                        </div>
                        <div id="quest-loading" class="loading-spinner">
                            <div class="spinner"></div>
                            <div>Loading intel from command...</div>
                        </div>
                        <div id="quest-list" class="d-none" style="max-height: 500px; overflow-y: auto;"></div>
                        <div id="quest-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-7">
                    <div class="tarkov-panel">
                        <h5>Tactical Map</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-6">
                                <select id="mapSelect" class="form-select-tarkov w-100" onchange="onMapChange()">
                                    <option value="customs">Customs</option>
                                    <option value="factory">Factory</option>
                                    <option value="groundzero">Ground Zero</option>
                                    <option value="interchange">Interchange</option>
                                    <option value="labs">The Lab</option>
                                    <option value="lighthouse">Lighthouse</option>
                                    <option value="reserve">Reserve</option>
                                    <option value="shoreline">Shoreline</option>
                                    <option value="streets">Streets of Tarkov</option>
                                    <option value="woods">Woods</option>
                                </select>
                            </div>
                            <div class="col-md-6">
                                <button class="btn-tarkov w-100" onclick="planRaid()">Plan Raid</button>
                            </div>
                        </div>
                        <div class="row g-2 mb-3">
                            <div class="col-6">
                                <button class="btn-tarkov w-100" onclick="showRaidExportModal()" style="font-size: 0.8rem; padding: 6px 10px;">üì§ Share Raid</button>
                            </div>
                            <div class="col-6">
                                <button class="btn-tarkov w-100" onclick="showRaidImportModal()" style="font-size: 0.8rem; padding: 6px 10px;">üì• Import Raid</button>
                            </div>
                        </div>
                        <div id="mapHint" class="map-hint" style="display: none;"></div>
                        
                        <!-- Multi-Map Tabs (dynamisch generiert) -->
                        <div id="multiMapTabs" class="multi-map-tabs" style="display: none;">
                            <div id="mapTabsContainer" class="map-tabs-container"></div>
                        </div>
                        
                        <!-- Map Overlay Controls -->
                        <div class="map-overlay-controls" style="opacity: 0.6;">
                            <span class="overlay-title">Extracts:</span>
                            <span style="color: var(--eft-gold); font-size: 0.8rem; font-style: italic;">Coming Soon</span>
                            <label class="overlay-toggle" style="cursor: not-allowed;">
                                <input type="checkbox" disabled>
                                <span>üö™</span>
                                <span>PMC</span>
                            </label>
                            <label class="overlay-toggle" style="cursor: not-allowed;">
                                <input type="checkbox" disabled>
                                <span>üö™</span>
                                <span>Scav</span>
                            </label>
                            <label class="overlay-toggle" style="cursor: not-allowed;">
                                <input type="checkbox" disabled>
                                <span>üö™</span>
                                <span>Co-Op</span>
                            </label>
                        </div>
                        
                        <div class="map-controls">
                            <span>Scroll to zoom | Drag to pan | Click markers for details</span>
                            <span class="marker-count" id="markerCount">0 markers</span>
                            <button class="btn-tarkov" onclick="resetMapView()">Reset View</button>
                        </div>
                        <div id="map"></div>
                        <div id="mapLegend" class="map-legend" style="display: none;">
                            <div class="legend-title">Quest Colors</div>
                            <div id="legendItems" class="legend-items"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="planning-result" class="tarkov-panel" style="display: none;">
                <h5>Mission Briefing</h5>
                <div class="row">
                    <div class="col-md-4">
                        <h6 class="text-beige mb-3">Required Keys</h6>
                        <div id="required-keys"></div>
                    </div>
                    <div class="col-md-8" id="quest-item-tracker-section">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="text-beige mb-0">Quest Item Tracker</h6>
                            <div class="item-tracker-progress">
                                <span class="progress-text" id="tracker-progress">0/0</span>
                                <div class="progress-bar-mini">
                                    <div class="progress-fill" id="tracker-progress-bar" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                        <div id="quest-item-tracker"></div>
                    </div>
                </div>
                <div class="row mt-4">
                    <div class="col-md-6">
                        <h6 class="text-beige mb-3">Unlocks</h6>
                        <div id="progression-list"></div>
                    </div>
                    <div class="col-md-6">
                        <h6 class="text-beige mb-3">Objectives</h6>
                        <div id="mission-steps" style="max-height: none; overflow: visible;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- HIDEOUT TRACKER TAB -->
        <div id="tab-hideout" class="tab-content">
            <div class="row">
                <div class="col-lg-8">
                    <div class="tarkov-panel">
                        <h5>Hideout Upgrades</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-4">
                                <input type="text" class="form-control-tarkov w-100" placeholder="Search stations..." id="hideoutSearch" oninput="filterHideoutStations()">
                            </div>
                            <div class="col-md-4">
                                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 0.85rem; color: var(--text-sub); height: 100%;">
                                    <input type="checkbox" id="hideCompletedStations" onchange="filterHideoutStations()" style="width: 16px; height: 16px; accent-color: var(--eft-gold);">
                                    Hide maxed stations
                                </label>
                            </div>
                            <div class="col-md-4">
                                <button class="btn-tarkov w-100" onclick="loadHideoutData()" id="btn-refresh-hideout">üîÑ Refresh</button>
                            </div>
                        </div>
                        <div class="hideout-progress-bar mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <span class="text-sub small">Overall Progress</span>
                                <span class="text-gold" id="hideout-progress-text">0 / 0 Levels</span>
                            </div>
                            <div style="background: var(--bg-dark); border: 1px solid var(--border-dark); height: 8px;">
                                <div id="hideout-progress-fill" style="background: var(--eft-gold); height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                        <div id="hideout-loading" class="loading-spinner">
                            <div class="spinner"></div>
                            <div>Loading hideout data...</div>
                        </div>
                        <div id="hideout-content" class="d-none">
                            <div id="hideout-stations-list" style="max-height: 600px; overflow-y: auto;"></div>
                        </div>
                        <div id="hideout-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="tarkov-panel">
                        <h5>üìã Shopping List</h5>
                        <p class="text-sub small mb-3">Items needed for next upgrades</p>
                        <div id="hideout-shopping-list" style="max-height: 400px; overflow-y: auto;">
                            <div class="text-sub text-center p-3">Select a target level to see required items</div>
                        </div>
                    </div>
                    <div class="tarkov-panel mt-3">
                        <h5>üìä Station Stats</h5>
                        <div id="hideout-stats">
                            <div class="d-flex justify-content-between py-2 border-bottom" style="border-color: var(--border-dark) !important;">
                                <span class="text-sub">Stations</span>
                                <span class="text-beige" id="stat-stations-count">0</span>
                            </div>
                            <div class="d-flex justify-content-between py-2 border-bottom" style="border-color: var(--border-dark) !important;">
                                <span class="text-sub">Completed</span>
                                <span class="text-gold" id="stat-completed-count">0</span>
                            </div>
                            <div class="d-flex justify-content-between py-2 border-bottom" style="border-color: var(--border-dark) !important;">
                                <span class="text-sub">In Progress</span>
                                <span class="text-beige" id="stat-inprogress-count">0</span>
                            </div>
                            <div class="d-flex justify-content-between py-2">
                                <span class="text-sub">Not Started</span>
                                <span class="text-sub" id="stat-notstarted-count">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- AMMO MANAGER TAB -->
        <div id="tab-ammo" class="tab-content">
            <div class="row">
                <div class="col-lg-8">
                    <div class="tarkov-panel">
                        <h5>Ammunition Database</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-4">
                                <select id="caliberFilter" class="form-select-tarkov w-100" onchange="filterAmmoByCaliber()">
                                    <option value="ALL">All Calibers</option>
                                </select>
                            </div>
                            <div class="col-md-4">
                                <div class="search-box">
                                    <input type="text" class="form-control-tarkov w-100" placeholder="Search ammo..." id="ammoSearch" oninput="filterAmmoBySearch()">
                                </div>
                            </div>
                            <div class="col-md-2">
                                <button id="btn-load-ammo" class="btn-tarkov w-100" onclick="loadAmmoData()" style="display: none;">üîÑ Refresh Data</button>
                            </div>
                            <div class="col-md-2">
                                <button id="bulk-toggle-ammo" class="btn-tarkov w-100" onclick="toggleBulkMode('ammo')" style="font-size: 0.75rem;">Bulk Select</button>
                            </div>
                        </div>
                        <div class="bulk-controls" id="bulk-controls-ammo">
                            <span id="bulk-count-ammo" class="text-beige">0 selected</span>
                            <button class="btn-tarkov" onclick="bulkMarkOwned('ammo')" style="padding: 4px 10px; font-size: 0.75rem;">‚úì Mark Owned</button>
                            <button class="btn-tarkov" onclick="bulkUnmarkOwned('ammo')" style="padding: 4px 10px; font-size: 0.75rem;">‚úó Unmark</button>
                            <button class="btn-tarkov" onclick="bulkSelectAll('ammo')" style="padding: 4px 10px; font-size: 0.75rem; background: var(--bg-dark);">Select All</button>
                            <button class="btn-tarkov" onclick="bulkDeselectAll('ammo')" style="padding: 4px 10px; font-size: 0.75rem; background: var(--bg-dark);">Deselect All</button>
                        </div>
                        <div class="text-sub small mb-3">Click ammo to mark as owned | <span id="ammo-count">0</span> loaded</div>
                        <div id="ammo-loading" class="loading-spinner d-none">
                            <div class="spinner"></div>
                            <div>Loading ammunition data...</div>
                        </div>
                        <div id="ammo-content" class="d-none">
                            <div id="ammo-list" style="max-height: 500px; overflow-y: auto;"></div>
                        </div>
                        <div id="ammo-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="tarkov-panel">
                        <h5>Tier Configuration</h5>
                        <div class="tier-config" id="tierConfigAmmo">
                            <div class="stat-selector">
                                <label>Active Stats (OR logic):</label>
                                <div class="stat-checkboxes" id="ammoStatCheckboxes"></div>
                            </div>
                            <div class="threshold-editor">
                                <div class="threshold-editor-header">
                                    <span class="text-sub small">Edit:</span>
                                    <select id="ammoStatSelect" onchange="renderThresholdEditor('ammo')"></select>
                                    <span class="threshold-direction" id="ammoStatDirection"></span>
                                </div>
                                <div class="threshold-grid" id="ammoThresholdGrid"></div>
                            </div>
                            <div class="tier-config-row mt-3">
                                <span class="tier-badge tier-F">F</span>
                                <label>Below all D thresholds</label>
                            </div>
                            <div class="mt-2 d-flex gap-2">
                                <button class="btn-tarkov flex-grow-1" onclick="resetCategoryConfig('ammo')" style="padding: 6px 12px; font-size: 0.8rem;">Reset</button>
                                <button class="btn-tarkov flex-grow-1" onclick="clearCategoryOverrides('ammo')" style="padding: 6px 12px; font-size: 0.8rem;">Clear Overrides</button>
                            </div>
                        </div>
                    </div>
                    <div class="tarkov-panel">
                        <h5>Keep/Sell Analysis</h5>
                        <div class="mb-3">
                            <label class="form-label text-sub small">Minimum tier to keep:</label>
                            <input type="range" class="form-range" id="ammoTierSlider" min="0" max="5" value="2" oninput="updateKeepThreshold('ammo')">
                            <div class="text-center text-beige" id="ammoTierDisplay">Keep B-Tier+</div>
                        </div>
                        <div class="analysis-panel" style="flex-direction: column;">
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(74, 122, 74, 0.2);">
                                    <h6 style="color: var(--eft-green);">KEEP</h6>
                                    <span class="badge-tarkov badge-active" id="ammo-keep-count">0</span>
                                </div>
                                <div id="ammo-keep-list" class="analysis-list"></div>
                            </div>
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(140, 59, 59, 0.2);">
                                    <h6 style="color: var(--eft-red);">SELL</h6>
                                    <span class="badge-tarkov" id="ammo-sell-count">0</span>
                                </div>
                                <div id="ammo-sell-list" class="analysis-list"></div>
                                <div class="text-end mt-2 text-sub small">Total value: <span id="ammo-total-sell-value" class="text-gold">0 RUB</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- PENETRATION CHART TAB -->
        <div id="tab-penetration" class="tab-content">
            <div class="tarkov-panel">
                <h5>Ammo Penetration vs Armor Class</h5>
                <p class="text-sub small mb-3">Shows effectiveness of ammunition against different armor classes. Data loaded from Ammo tab.</p>
                
                <div class="pen-legend">
                    <div class="pen-legend-item"><div class="pen-legend-color" style="background: rgba(74, 140, 74, 0.4);"></div> High penetration (6+ shots effective)</div>
                    <div class="pen-legend-item"><div class="pen-legend-color" style="background: rgba(180, 150, 50, 0.4);"></div> Medium (3-5 shots needed)</div>
                    <div class="pen-legend-item"><div class="pen-legend-color" style="background: rgba(140, 60, 60, 0.4);"></div> Low (many shots needed)</div>
                    <div class="pen-legend-item"><div class="pen-legend-color" style="background: rgba(60, 60, 60, 0.3);"></div> Ineffective</div>
                </div>
                
                <div class="row g-3 mb-3">
                    <div class="col-md-4">
                        <select id="penCaliberFilter" class="form-select-tarkov w-100" onchange="renderPenMatrix()">
                            <option value="ALL">All Calibers</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <select id="penSortBy" class="form-select-tarkov w-100" onchange="renderPenMatrix()">
                            <option value="pen">Sort by Penetration</option>
                            <option value="name">Sort by Name</option>
                            <option value="damage">Sort by Damage</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label class="text-sub small d-flex align-items-center gap-2">
                            <input type="checkbox" id="penShowOwned" onchange="renderPenMatrix()"> Show only owned
                        </label>
                    </div>
                </div>
                
                <div id="pen-loading" class="text-sub text-center p-4">
                    Load ammo data in the Ammo tab first to see the penetration chart.
                </div>
                <div id="pen-matrix-container" class="pen-matrix-container d-none"></div>
            </div>
        </div>

        <!-- WEAPONS TAB -->
        <div id="tab-weapons" class="tab-content">
            <div class="row">
                <div class="col-lg-8">
                    <div class="tarkov-panel">
                        <h5>Weapons Database</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-3">
                                <select id="weaponTypeFilter" class="form-select-tarkov w-100" onchange="filterWeapons()">
                                    <option value="ALL">All Types</option>
                                </select>
                            </div>
                            <div class="col-md-4">
                                <input type="text" class="form-control-tarkov w-100" placeholder="Search weapons..." id="weaponSearch" oninput="filterWeapons()">
                            </div>
                            <div class="col-md-3">
                                <button id="btn-load-weapons" class="btn-tarkov w-100" onclick="loadWeaponsData()" style="display: none;">üîÑ Refresh Data</button>
                            </div>
                            <div class="col-md-2">
                                <button id="bulk-toggle-weapons" class="btn-tarkov w-100" onclick="toggleBulkMode('weapons')" style="font-size: 0.75rem;">Bulk Select</button>
                            </div>
                        </div>
                        <div class="bulk-controls" id="bulk-controls-weapons">
                            <span id="bulk-count-weapons" class="text-beige">0 selected</span>
                            <button class="btn-tarkov" onclick="bulkMarkOwned('weapons')" style="padding: 4px 10px; font-size: 0.75rem;">‚úì Mark Owned</button>
                            <button class="btn-tarkov" onclick="bulkUnmarkOwned('weapons')" style="padding: 4px 10px; font-size: 0.75rem;">‚úó Unmark</button>
                            <button class="btn-tarkov" onclick="bulkSelectAll('weapons')" style="padding: 4px 10px; font-size: 0.75rem; background: var(--bg-dark);">Select All</button>
                            <button class="btn-tarkov" onclick="bulkDeselectAll('weapons')" style="padding: 4px 10px; font-size: 0.75rem; background: var(--bg-dark);">Deselect All</button>
                        </div>
                        <div class="text-sub small mb-3">Click weapon to mark as owned | <span id="weapon-count">0</span> loaded</div>
                        <div id="weapons-loading" class="loading-spinner d-none">
                            <div class="spinner"></div>
                            <div>Loading weapons data...</div>
                        </div>
                        <div id="weapons-content" class="d-none">
                            <div id="weapons-list" style="max-height: 500px; overflow-y: auto;"></div>
                        </div>
                        <div id="weapons-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="tarkov-panel">
                        <h5>Weapon Tier Config</h5>
                        <div class="tier-config" id="tierConfigWeapons">
                            <div class="stat-selector">
                                <label>Active Stats (OR logic):</label>
                                <div class="stat-checkboxes" id="weaponsStatCheckboxes"></div>
                            </div>
                            <div class="threshold-editor">
                                <div class="threshold-editor-header">
                                    <span class="text-sub small">Edit:</span>
                                    <select id="weaponsStatSelect" onchange="renderThresholdEditor('weapons')"></select>
                                    <span class="threshold-direction" id="weaponsStatDirection"></span>
                                </div>
                                <div class="threshold-grid" id="weaponsThresholdGrid"></div>
                            </div>
                            <div class="tier-config-row mt-3">
                                <span class="tier-badge tier-F">F</span>
                                <label>Below all D thresholds</label>
                            </div>
                            <div class="mt-2 d-flex gap-2">
                                <button class="btn-tarkov flex-grow-1" onclick="resetCategoryConfig('weapons')" style="padding: 6px 12px; font-size: 0.8rem;">Reset</button>
                                <button class="btn-tarkov flex-grow-1" onclick="clearCategoryOverrides('weapons')" style="padding: 6px 12px; font-size: 0.8rem;">Clear Overrides</button>
                            </div>
                        </div>
                    </div>
                    <div class="tarkov-panel">
                        <h5>Keep/Sell Analysis</h5>
                        <div class="mb-3">
                            <label class="form-label text-sub small">Minimum tier to keep:</label>
                            <input type="range" class="form-range" id="weaponsTierSlider" min="0" max="5" value="2" oninput="updateKeepThreshold('weapons')">
                            <div class="text-center text-beige" id="weaponsTierDisplay">Keep B-Tier+</div>
                        </div>
                        <div class="analysis-panel" style="flex-direction: column;">
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(74, 122, 74, 0.2);"><h6 style="color: var(--eft-green);">KEEP</h6><span class="badge-tarkov badge-active" id="weapons-keep-count">0</span></div>
                                <div id="weapons-keep-list" class="analysis-list"></div>
                            </div>
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(140, 59, 59, 0.2);"><h6 style="color: var(--eft-red);">SELL</h6><span class="badge-tarkov" id="weapons-sell-count">0</span></div>
                                <div id="weapons-sell-list" class="analysis-list"></div>
                                <div class="text-end mt-2 text-sub small">Total value: <span id="weapons-total-sell-value" class="text-gold">0 RUB</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- GEAR TAB -->
        <div id="tab-gear" class="tab-content">
            <div class="row">
                <div class="col-lg-8">
                    <div class="tarkov-panel">
                        <h5>Gear Database</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-3">
                                <select id="gearTypeFilter" class="form-select-tarkov w-100" onchange="filterGear()">
                                    <option value="ALL">All Types</option>
                                    <option value="armor">Body Armor</option>
                                    <option value="helmet">Helmets</option>
                                    <option value="rig">Tactical Rigs</option>
                                    <option value="backpack">Backpacks</option>
                                    <option value="headphones">Headsets</option>
                                </select>
                            </div>
                            <div class="col-md-4">
                                <input type="text" class="form-control-tarkov w-100" placeholder="Search gear..." id="gearSearch" oninput="filterGear()">
                            </div>
                            <div class="col-md-3">
                                <button id="btn-load-gear" class="btn-tarkov w-100" onclick="loadGearData()" style="display: none;">üîÑ Refresh Data</button>
                            </div>
                            <div class="col-md-2">
                                <button id="bulk-toggle-gear" class="btn-tarkov w-100" onclick="toggleBulkMode('gear')" style="font-size: 0.75rem;">Bulk Select</button>
                            </div>
                        </div>
                        <div class="bulk-controls" id="bulk-controls-gear">
                            <span id="bulk-count-gear" class="text-beige">0 selected</span>
                            <button class="btn-tarkov" onclick="bulkMarkOwned('gear')" style="padding: 4px 10px; font-size: 0.75rem;">‚úì Mark Owned</button>
                            <button class="btn-tarkov" onclick="bulkUnmarkOwned('gear')" style="padding: 4px 10px; font-size: 0.75rem;">‚úó Unmark</button>
                            <button class="btn-tarkov" onclick="bulkSelectAll('gear')" style="padding: 4px 10px; font-size: 0.75rem; background: var(--bg-dark);">Select All</button>
                            <button class="btn-tarkov" onclick="bulkDeselectAll('gear')" style="padding: 4px 10px; font-size: 0.75rem; background: var(--bg-dark);">Deselect All</button>
                        </div>
                        <div class="text-sub small mb-3">Click gear to mark as owned | <span id="gear-count">0</span> loaded</div>
                        <div id="gear-loading" class="loading-spinner d-none">
                            <div class="spinner"></div>
                            <div>Loading gear data...</div>
                        </div>
                        <div id="gear-content" class="d-none">
                            <div id="gear-list" style="max-height: 500px; overflow-y: auto;"></div>
                        </div>
                        <div id="gear-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="tarkov-panel">
                        <h5>Gear Tier Config</h5>
                        <div class="tier-config" id="tierConfigGear">
                            <div class="stat-selector">
                                <label>Active Stats (OR logic):</label>
                                <div class="stat-checkboxes" id="gearStatCheckboxes"></div>
                            </div>
                            <div class="threshold-editor">
                                <div class="threshold-editor-header">
                                    <span class="text-sub small">Edit:</span>
                                    <select id="gearStatSelect" onchange="renderThresholdEditor('gear')"></select>
                                    <span class="threshold-direction" id="gearStatDirection"></span>
                                </div>
                                <div class="threshold-grid" id="gearThresholdGrid"></div>
                            </div>
                            <div class="tier-config-row mt-3">
                                <span class="tier-badge tier-F">F</span>
                                <label>Below all D thresholds</label>
                            </div>
                            <div class="mt-2 d-flex gap-2">
                                <button class="btn-tarkov flex-grow-1" onclick="resetCategoryConfig('gear')" style="padding: 6px 12px; font-size: 0.8rem;">Reset</button>
                                <button class="btn-tarkov flex-grow-1" onclick="clearCategoryOverrides('gear')" style="padding: 6px 12px; font-size: 0.8rem;">Clear Overrides</button>
                            </div>
                        </div>
                    </div>
                    <div class="tarkov-panel">
                        <h5>Keep/Sell Analysis</h5>
                        <div class="mb-3">
                            <label class="form-label text-sub small">Minimum tier to keep:</label>
                            <input type="range" class="form-range" id="gearTierSlider" min="0" max="5" value="2" oninput="updateKeepThreshold('gear')">
                            <div class="text-center text-beige" id="gearTierDisplay">Keep B-Tier+</div>
                        </div>
                        <div class="analysis-panel" style="flex-direction: column;">
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(74, 122, 74, 0.2);"><h6 style="color: var(--eft-green);">KEEP</h6><span class="badge-tarkov badge-active" id="gear-keep-count">0</span></div>
                                <div id="gear-keep-list" class="analysis-list"></div>
                            </div>
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(140, 59, 59, 0.2);"><h6 style="color: var(--eft-red);">SELL</h6><span class="badge-tarkov" id="gear-sell-count">0</span></div>
                                <div id="gear-sell-list" class="analysis-list"></div>
                                <div class="text-end mt-2 text-sub small">Total value: <span id="gear-total-sell-value" class="text-gold">0 RUB</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ATTACHMENTS TAB -->
        <div id="tab-attachments" class="tab-content">
            <div class="row">
                <div class="col-lg-8">
                    <div class="tarkov-panel">
                        <h5>Attachments Database</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-3">
                                <select id="attachmentTypeFilter" class="form-select-tarkov w-100" onchange="filterAttachments()">
                                    <option value="ALL">All Types</option>
                                </select>
                            </div>
                            <div class="col-md-4">
                                <input type="text" class="form-control-tarkov w-100" placeholder="Search attachments..." id="attachmentSearch" oninput="filterAttachments()">
                            </div>
                            <div class="col-md-3">
                                <button id="btn-load-attachments" class="btn-tarkov w-100" onclick="loadAttachmentsData()" style="display: none;">üîÑ Refresh Data</button>
                            </div>
                            <div class="col-md-2">
                                <button id="bulk-toggle-attachments" class="btn-tarkov w-100" onclick="toggleBulkMode('attachments')" style="font-size: 0.75rem;">Bulk Select</button>
                            </div>
                        </div>
                        <div class="bulk-controls" id="bulk-controls-attachments">
                            <span id="bulk-count-attachments" class="text-beige">0 selected</span>
                            <button class="btn-tarkov" onclick="bulkMarkOwned('attachments')" style="padding: 4px 10px; font-size: 0.75rem;">‚úì Mark Owned</button>
                            <button class="btn-tarkov" onclick="bulkUnmarkOwned('attachments')" style="padding: 4px 10px; font-size: 0.75rem;">‚úó Unmark</button>
                            <button class="btn-tarkov" onclick="bulkSelectAll('attachments')" style="padding: 4px 10px; font-size: 0.75rem; background: var(--bg-dark);">Select All</button>
                            <button class="btn-tarkov" onclick="bulkDeselectAll('attachments')" style="padding: 4px 10px; font-size: 0.75rem; background: var(--bg-dark);">Deselect All</button>
                        </div>
                        <div class="text-sub small mb-3">Click attachment to mark as owned | <span id="attachment-count">0</span> loaded</div>
                        <div id="attachments-loading" class="loading-spinner d-none">
                            <div class="spinner"></div>
                            <div>Loading attachments data...</div>
                        </div>
                        <div id="attachments-content" class="d-none">
                            <div id="attachments-list" style="max-height: 500px; overflow-y: auto;"></div>
                        </div>
                        <div id="attachments-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="tarkov-panel">
                        <h5>Attachment Tier Config</h5>
                        <div class="tier-config" id="tierConfigAttachments">
                            <div class="stat-selector">
                                <label>Active Stats (OR logic):</label>
                                <div class="stat-checkboxes" id="attachmentsStatCheckboxes"></div>
                            </div>
                            <div class="threshold-editor">
                                <div class="threshold-editor-header">
                                    <span class="text-sub small">Edit:</span>
                                    <select id="attachmentsStatSelect" onchange="renderThresholdEditor('attachments')"></select>
                                    <span class="threshold-direction" id="attachmentsStatDirection"></span>
                                </div>
                                <div class="threshold-grid" id="attachmentsThresholdGrid"></div>
                            </div>
                            <div class="tier-config-row mt-3">
                                <span class="tier-badge tier-F">F</span>
                                <label>Below all D thresholds</label>
                            </div>
                            <div class="mt-2 d-flex gap-2">
                                <button class="btn-tarkov flex-grow-1" onclick="resetCategoryConfig('attachments')" style="padding: 6px 12px; font-size: 0.8rem;">Reset</button>
                                <button class="btn-tarkov flex-grow-1" onclick="clearCategoryOverrides('attachments')" style="padding: 6px 12px; font-size: 0.8rem;">Clear Overrides</button>
                            </div>
                        </div>
                    </div>
                    <div class="tarkov-panel">
                        <h5>Keep/Sell Analysis</h5>
                        <div class="mb-3">
                            <label class="form-label text-sub small">Minimum tier to keep:</label>
                            <input type="range" class="form-range" id="attachmentsTierSlider" min="0" max="5" value="2" oninput="updateKeepThreshold('attachments')">
                            <div class="text-center text-beige" id="attachmentsTierDisplay">Keep B-Tier+</div>
                        </div>
                        <div class="analysis-panel" style="flex-direction: column;">
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(74, 122, 74, 0.2);"><h6 style="color: var(--eft-green);">KEEP</h6><span class="badge-tarkov badge-active" id="attachments-keep-count">0</span></div>
                                <div id="attachments-keep-list" class="analysis-list"></div>
                            </div>
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(140, 59, 59, 0.2);"><h6 style="color: var(--eft-red);">SELL</h6><span class="badge-tarkov" id="attachments-sell-count">0</span></div>
                                <div id="attachments-sell-list" class="analysis-list"></div>
                                <div class="text-end mt-2 text-sub small">Total value: <span id="attachments-total-sell-value" class="text-gold">0 RUB</span></div>
                            </div>
                        </div>
                    </div>
                </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // ============================================================================
        // SUPABASE CONFIGURATION
        // ============================================================================
        const SUPABASE_URL = 'https://dpryrhcqeviyvssyiwdz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRwcnlyaGNxZXZpeXZzc3lpd2R6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk0OTg0MjEsImV4cCI6MjA4NTA3NDQyMX0.IiYyEjEOU1fSq8DN_7tG2oQPr6Iuft2zMC2TasMXSfI';
        
        // Initialize Supabase client (delayed to ensure SDK is loaded)
        let supabaseClient = null;
        
        function initSupabase() {
            if (supabaseClient) return supabaseClient;
            
            if (window.supabase && window.supabase.createClient) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('Supabase initialized');
                return supabaseClient;
            } else {
                console.error('Supabase SDK not loaded');
                return null;
            }
        }
        
        // Auth state
        let currentUser = null;
        let isEditMode = false;
        
        // ============================================================================
        // AUTH FUNCTIONS
        // ============================================================================
        
        function showLoginModal() {
            document.getElementById('loginModal').style.display = 'flex';
            document.getElementById('loginEmail').focus();
            document.getElementById('loginError').style.display = 'none';
        }
        
        function hideLoginModal() {
            document.getElementById('loginModal').style.display = 'none';
            document.getElementById('loginEmail').value = '';
            document.getElementById('loginPassword').value = '';
            document.getElementById('loginError').style.display = 'none';
        }
        
        async function doLogin() {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');
            const submitBtn = document.getElementById('loginSubmitBtn');
            
            if (!email || !password) {
                errorDiv.textContent = 'Please enter email and password';
                errorDiv.style.display = 'block';
                return;
            }
            
            if (!supabaseClient) {
                errorDiv.textContent = 'Authentication service not available';
                errorDiv.style.display = 'block';
                return;
            }
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Logging in...';
            
            try {
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email: email,
                    password: password
                });
                
                if (error) throw error;
                
                hideLoginModal();
                updateAuthUI(data.user);
                console.log('Login successful:', data.user.email);
                
            } catch (error) {
                console.error('Login error:', error);
                errorDiv.textContent = error.message || 'Login failed. Please check your credentials.';
                errorDiv.style.display = 'block';
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Login';
            }
        }
        
        async function logout() {
            if (!supabaseClient) return;
            
            try {
                await supabaseClient.auth.signOut();
                currentUser = null;
                isEditMode = false;
                updateAuthUI(null);
                updateEditModeUI();
                console.log('Logged out');
            } catch (error) {
                console.error('Logout error:', error);
            }
        }
        
        function updateAuthUI(user) {
            currentUser = user;
            const loginBtn = document.getElementById('loginBtn');
            const userInfo = document.getElementById('userInfo');
            const userEmail = document.getElementById('userEmail');
            
            if (user) {
                loginBtn.style.display = 'none';
                userInfo.style.display = 'flex';
                userEmail.textContent = user.email;
            } else {
                loginBtn.style.display = 'block';
                userInfo.style.display = 'none';
                userEmail.textContent = '';
            }
        }
        
        function toggleEditMode() {
            if (!currentUser) {
                showLoginModal();
                return;
            }
            
            isEditMode = !isEditMode;
            updateEditModeUI();
            
            // Make markers draggable/non-draggable
            if (questMarkersLayer) {
                questMarkersLayer.eachLayer(marker => {
                    if (marker.dragging) {
                        if (isEditMode) {
                            marker.dragging.enable();
                            marker._icon?.classList.add('leaflet-marker-draggable');
                        } else {
                            marker.dragging.disable();
                            marker._icon?.classList.remove('leaflet-marker-draggable');
                        }
                    }
                });
            }
            
            console.log('Edit mode:', isEditMode ? 'ON' : 'OFF');
        }
        
        function updateEditModeUI() {
            const badge = document.getElementById('editModeBadge');
            const btn = document.getElementById('editModeBtn');
            
            if (isEditMode) {
                badge.style.display = 'block';
                if (btn) {
                    btn.classList.add('active');
                    btn.innerHTML = '‚úèÔ∏è Exit Edit Mode';
                }
            } else {
                badge.style.display = 'none';
                if (btn) {
                    btn.classList.remove('active');
                    btn.innerHTML = '‚úèÔ∏è Edit Markers';
                }
            }
        }
        
        // ============================================================================
        // MARKER CORRECTION SYSTEM
        // ============================================================================
        
        let pendingCorrection = null; // Stores marker data during correction dialog
        
        function showCorrectionDialog(marker, dragEvent) {
            const data = marker._questData;
            if (!data) {
                console.error('No quest data on marker');
                return;
            }
            
            // Get new position from marker
            const newLatLng = marker.getLatLng();
            const mapKey = document.getElementById('mapSelect')?.value || activeMapTab || 'customs';
            const mapCfg = MAP_CONFIG[mapKey] || { scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true };
            
            // Convert Leaflet coordinates back to percent
            // Reverse the conversion from drawQuestMarkers
            let pixelX = newLatLng.lng;
            let pixelY = mapCfg.invertLeafletY !== false ? (currentMapHeight - newLatLng.lat) : newLatLng.lat;
            
            // Convert pixel to percent
            let newLeftPercent = (pixelX / currentMapWidth) * 100;
            let newTopPercent = (pixelY / currentMapHeight) * 100;
            
            // Reverse map-specific corrections
            if (mapCfg.flipY) {
                newTopPercent = 100 - newTopPercent;
            }
            newLeftPercent = (newLeftPercent - mapCfg.offsetX) / mapCfg.scaleX;
            newTopPercent = (newTopPercent - mapCfg.offsetY) / mapCfg.scaleY;
            
            // Calculate delta
            const deltaLeft = newLeftPercent - data.originalLeftPercent;
            const deltaTop = newTopPercent - data.originalTopPercent;
            
            // Store pending correction
            pendingCorrection = {
                marker: marker,
                questId: data.questId,
                questName: data.questName,
                objectiveId: data.objectiveId,
                objectiveIndex: data.objectiveIndex,
                mapKey: mapKey,
                originalLeftPercent: data.originalLeftPercent,
                originalTopPercent: data.originalTopPercent,
                newLeftPercent: newLeftPercent,
                newTopPercent: newTopPercent,
                deltaLeft: deltaLeft,
                deltaTop: deltaTop
            };
            
            // Populate dialog
            document.getElementById('correctionQuestName').textContent = data.questName;
            document.getElementById('correctionObjective').textContent = `#${data.objectiveIndex}: ${data.description || 'Objective'}`;
            document.getElementById('correctionOldCoords').textContent = `(${data.originalLeftPercent.toFixed(2)}%, ${data.originalTopPercent.toFixed(2)}%)`;
            document.getElementById('correctionNewCoords').textContent = `(${newLeftPercent.toFixed(2)}%, ${newTopPercent.toFixed(2)}%)`;
            
            const deltaLeftStr = deltaLeft >= 0 ? `+${deltaLeft.toFixed(2)}` : deltaLeft.toFixed(2);
            const deltaTopStr = deltaTop >= 0 ? `+${deltaTop.toFixed(2)}` : deltaTop.toFixed(2);
            document.getElementById('correctionDelta').textContent = `(${deltaLeftStr}%, ${deltaTopStr}%)`;
            
            // Show dialog
            document.getElementById('correctionDialogOverlay').style.display = 'block';
        }
        
        function cancelCorrection() {
            // Reset marker to original position
            if (pendingCorrection && pendingCorrection.marker) {
                const data = pendingCorrection.marker._questData;
                const mapKey = pendingCorrection.mapKey;
                const mapCfg = MAP_CONFIG[mapKey] || { scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true };
                
                // Recalculate original position
                let correctedLeftPct = data.originalLeftPercent * mapCfg.scaleX + mapCfg.offsetX;
                let correctedTopPct = data.originalTopPercent * mapCfg.scaleY + mapCfg.offsetY;
                if (mapCfg.flipY) {
                    correctedTopPct = 100 - correctedTopPct;
                }
                const pixelX = (correctedLeftPct / 100) * currentMapWidth;
                const pixelY = (correctedTopPct / 100) * currentMapHeight;
                const leafletY = mapCfg.invertLeafletY !== false ? (currentMapHeight - pixelY) : pixelY;
                
                pendingCorrection.marker.setLatLng([leafletY, pixelX]);
            }
            
            pendingCorrection = null;
            document.getElementById('correctionDialogOverlay').style.display = 'none';
        }
        
        async function saveCorrection() {
            if (!pendingCorrection || !currentUser || !supabaseClient) {
                alert('Unable to save correction. Please ensure you are logged in.');
                return;
            }
            
            const btn = document.getElementById('saveCorrectionBtn');
            btn.disabled = true;
            btn.textContent = 'Saving...';
            
            try {
                // Build correction record matching existing schema
                const correctionData = {
                    quest_id: pendingCorrection.questId,
                    objective_index: pendingCorrection.objectiveIndex,
                    original_left_percent: pendingCorrection.originalLeftPercent,
                    original_top_percent: pendingCorrection.originalTopPercent,
                    corrected_left_percent: pendingCorrection.newLeftPercent,
                    corrected_top_percent: pendingCorrection.newTopPercent,
                    corrected_by: currentUser.id,
                    notes: `Map: ${pendingCorrection.mapKey}, Delta: (${pendingCorrection.deltaLeft.toFixed(2)}%, ${pendingCorrection.deltaTop.toFixed(2)}%)`
                };
                
                // Upsert to Supabase (insert or update on conflict)
                const { data, error } = await supabaseClient
                    .from('marker_corrections')
                    .upsert(correctionData, {
                        onConflict: 'quest_id,objective_index'
                    });
                
                if (error) throw error;
                
                // Update marker's stored data with new position
                if (pendingCorrection.marker._questData) {
                    pendingCorrection.marker._questData.originalLeftPercent = pendingCorrection.newLeftPercent;
                    pendingCorrection.marker._questData.originalTopPercent = pendingCorrection.newTopPercent;
                    pendingCorrection.marker._questData.hasDbCorrection = true;
                }
                
                // Clear cache so next load gets fresh data
                clearCorrectionsCache();
                
                console.log('Correction saved:', correctionData);
                
                // Close dialog
                pendingCorrection = null;
                document.getElementById('correctionDialogOverlay').style.display = 'none';
                
            } catch (error) {
                console.error('Error saving correction:', error);
                alert('Failed to save correction: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üíæ Save Correction';
            }
        }
        
        // Cache for loaded marker corrections (global, keyed by quest_id|objective_index)
        let markerCorrectionsCache = null;
        let correctionsCacheLoaded = false;
        
        async function loadMarkerCorrections(mapKey) {
            // Check cache first - corrections are global (not per-map)
            if (correctionsCacheLoaded && markerCorrectionsCache) {
                console.log(`Using cached corrections: ${Object.keys(markerCorrectionsCache).length} entries`);
                return markerCorrectionsCache;
            }
            
            if (!supabaseClient) {
                console.log('Supabase not available, skipping corrections load');
                return {};
            }
            
            try {
                const { data, error } = await supabaseClient
                    .from('marker_corrections')
                    .select('*');
                
                if (error) {
                    console.error('Error loading corrections:', error);
                    return {};
                }
                
                // Build lookup table: quest_id|objective_index -> correction
                markerCorrectionsCache = {};
                (data || []).forEach(c => {
                    const key = `${c.quest_id}|${c.objective_index}`;
                    markerCorrectionsCache[key] = {
                        correctedLeftPercent: parseFloat(c.corrected_left_percent),
                        correctedTopPercent: parseFloat(c.corrected_top_percent),
                        originalLeftPercent: parseFloat(c.original_left_percent),
                        originalTopPercent: parseFloat(c.original_top_percent),
                        correctedBy: c.corrected_by,
                        correctedAt: c.corrected_at,
                        notes: c.notes
                    };
                });
                
                correctionsCacheLoaded = true;
                console.log(`Loaded ${Object.keys(markerCorrectionsCache).length} marker corrections from database`);
                return markerCorrectionsCache;
                
            } catch (err) {
                console.error('Exception loading corrections:', err);
                return {};
            }
        }
        
        function getMarkerCorrection(questId, objectiveIndex) {
            if (!markerCorrectionsCache) return null;
            const key = `${questId}|${objectiveIndex}`;
            return markerCorrectionsCache[key] || null;
        }
        
        function clearCorrectionsCache() {
            markerCorrectionsCache = null;
            correctionsCacheLoaded = false;
            console.log('Corrections cache cleared');
        }
        
        // Check auth state on page load
        async function initAuth() {
            // Initialize Supabase first
            const sb = initSupabase();
            if (!sb) {
                console.warn('Supabase not available - auth disabled');
                return;
            }
            
            try {
                const { data: { session } } = await sb.auth.getSession();
                if (session?.user) {
                    updateAuthUI(session.user);
                }
                
                // Listen for auth changes
                sb.auth.onAuthStateChange((event, session) => {
                    updateAuthUI(session?.user || null);
                });
            } catch (error) {
                console.error('Auth init error:', error);
            }
        }
        
        // ============================================================================
        // CONFIGURATION
        // ============================================================================
        const API_BASE = '/api';
        const STORAGE_KEY_QUESTS = 'tarkov_planner_quests_v3';
        const STORAGE_KEY_AMMO = 'tarkov_planner_ammo_v3';
        const STORAGE_KEY_QUEST_ITEMS = 'tarkov_planner_quest_items_v1';
        
        // Map configuration - using tarkovdata SVG maps (coordinates match 1:1)
        // Map coordinate correction factors
        // The tarkovdata GPS coordinates (leftPercent, topPercent) are designed for tarkovdata SVG maps
        // They should work 1:1 without offsets if using the original SVGs from the repo
        // scaleX/scaleY: multiply the percent value
        // offsetX/offsetY: add after scaling (in percent) - should be 0 for original SVGs
        // flipY: if true, invert Y axis (100 - topPercent) BEFORE pixel conversion
        // invertLeafletY: if false, don't do (height - pixelY) for Leaflet
        const MAP_CONFIG = {
            customs:     { file: 'maps/Customs.svg', scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true },
            woods:       { file: 'maps/Woods.svg', scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true },
            shoreline:   { file: 'maps/Shoreline.svg', scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true },
            interchange: { file: 'maps/Interchange.svg', scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true },
            reserve:     { file: 'maps/Reserve.svg', scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true },
            lighthouse:  { file: 'maps/Lighthouse.svg', scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true },
            streets:     { file: 'maps/StreetsOfTarkov.svg', scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true },
            groundzero:  { file: 'maps/GroundZero.svg', scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true },
            factory:     { file: 'maps/Factory.svg', scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true },
            labs:        { file: 'maps/Labs.svg', scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false, invertLeafletY: true }
        };

        // ============================================================================
        // STAT DEFINITIONS - All available stats per category from the game
        // direction: 'higher' = higher is better, 'lower' = lower is better
        // ============================================================================
        
        const STAT_DEFINITIONS = {
            ammo: {
                pen:          { label: 'Penetration',       direction: 'higher', defaults: { S: 55, A: 45, B: 35, C: 25, D: 15 } },
                dmg:          { label: 'Damage',            direction: 'higher', defaults: { S: 80, A: 65, B: 50, C: 40, D: 30 } },
                armorDmg:     { label: 'Armor Damage %',    direction: 'higher', defaults: { S: 70, A: 55, B: 40, C: 30, D: 20 } },
                fragChance:   { label: 'Frag Chance %',     direction: 'higher', defaults: { S: 50, A: 35, B: 20, C: 10, D: 5 } },
                initialSpeed: { label: 'Muzzle Velocity',   direction: 'higher', defaults: { S: 900, A: 750, B: 600, C: 450, D: 300 } },
                projCount:    { label: 'Projectile Count',  direction: 'higher', defaults: { S: 8, A: 6, B: 4, C: 2, D: 1 } },
                accMod:       { label: 'Accuracy Mod %',    direction: 'lower',  defaults: { S: -5, A: 0, B: 5, C: 10, D: 20 } },
                recoilMod:    { label: 'Recoil Mod %',      direction: 'lower',  defaults: { S: -10, A: 0, B: 5, C: 10, D: 20 } },
                lightBleed:   { label: 'Light Bleed %',     direction: 'higher', defaults: { S: 50, A: 35, B: 20, C: 10, D: 5 } },
                heavyBleed:   { label: 'Heavy Bleed %',     direction: 'higher', defaults: { S: 40, A: 25, B: 15, C: 8, D: 3 } },
            },
            weapons: {
                ergo:         { label: 'Ergonomics',        direction: 'higher', defaults: { S: 70, A: 55, B: 40, C: 28, D: 15 } },
                recoilVert:   { label: 'Vertical Recoil',   direction: 'lower',  defaults: { S: 40, A: 60, B: 90, C: 130, D: 180 } },
                recoilHoriz:  { label: 'Horizontal Recoil', direction: 'lower',  defaults: { S: 150, A: 250, B: 350, C: 450, D: 550 } },
                fireRate:     { label: 'Fire Rate (RPM)',   direction: 'higher', defaults: { S: 850, A: 700, B: 550, C: 400, D: 250 } },
                effectiveDist:{ label: 'Eff. Distance (m)', direction: 'higher', defaults: { S: 600, A: 450, B: 300, C: 150, D: 50 } },
                convergence:  { label: 'Convergence',       direction: 'higher', defaults: { S: 3, A: 2.5, B: 2, C: 1.5, D: 1 } },
                cameraRecoil: { label: 'Camera Recoil',     direction: 'lower',  defaults: { S: 0.03, A: 0.05, B: 0.08, C: 0.12, D: 0.18 } },
                deviationCurve:{ label: 'Deviation Curve',  direction: 'lower',  defaults: { S: 0.2, A: 0.4, B: 0.6, C: 0.8, D: 1.0 } },
                deviationMax: { label: 'Deviation Max',     direction: 'lower',  defaults: { S: 3, A: 5, B: 8, C: 12, D: 18 } },
                sightingRange:{ label: 'Sighting Range',    direction: 'higher', defaults: { S: 1000, A: 700, B: 400, C: 200, D: 100 } },
            },
            gear: {
                armorClass:   { label: 'Armor Class',       direction: 'higher', defaults: { S: 6, A: 5, B: 4, C: 3, D: 2 } },
                durability:   { label: 'Durability',        direction: 'higher', defaults: { S: 70, A: 55, B: 40, C: 30, D: 20 } },
                ergoPenalty:  { label: 'Ergo Penalty',      direction: 'lower',  defaults: { S: -5, A: -10, B: -15, C: -25, D: -35 } },
                speedPenalty: { label: 'Speed Penalty %',   direction: 'lower',  defaults: { S: -2, A: -5, B: -10, C: -18, D: -25 } },
                turnPenalty:  { label: 'Turn Penalty',      direction: 'lower',  defaults: { S: -2, A: -5, B: -8, C: -12, D: -18 } },
                ricochetY:    { label: 'Ricochet Chance',   direction: 'higher', defaults: { S: 0.9, A: 0.7, B: 0.5, C: 0.3, D: 0.1 } },
                capacity:     { label: 'Capacity (slots)',  direction: 'higher', defaults: { S: 50, A: 35, B: 25, C: 15, D: 8 } },
                ambientVol:   { label: 'Ambient Volume',    direction: 'higher', defaults: { S: 1.5, A: 1.3, B: 1.1, C: 0.9, D: 0.7 } },
                distortion:   { label: 'Distortion',        direction: 'lower',  defaults: { S: 0.1, A: 0.2, B: 0.3, C: 0.4, D: 0.5 } },
            },
            attachments: {
                ergoMod:      { label: 'Ergonomics +/-',    direction: 'higher', defaults: { S: 15, A: 10, B: 5, C: 2, D: 0 } },
                recoilMod:    { label: 'Recoil Mod %',      direction: 'lower',  defaults: { S: -5, A: -3, B: -1, C: 0, D: 2 } },
                accMod:       { label: 'Accuracy Mod %',    direction: 'lower',  defaults: { S: -5, A: -2, B: 0, C: 2, D: 5 } },
                magCapacity:  { label: 'Mag Capacity',      direction: 'higher', defaults: { S: 60, A: 45, B: 30, C: 20, D: 10 } },
                sightingRange:{ label: 'Sighting Range',    direction: 'higher', defaults: { S: 1000, A: 600, B: 300, C: 150, D: 50 } },
                zoomLevel:    { label: 'Max Zoom',          direction: 'higher', defaults: { S: 6, A: 4, B: 2.5, C: 1.5, D: 1 } },
            }
        };
        
        // Default active stats per category
        const DEFAULT_ACTIVE_STATS = {
            ammo: [],
            weapons: [],
            gear: [],
            attachments: []
        };
        
        // Item-type specific stat configuration
        // Defines which stats are APPLICABLE (relevant) and which are DEFAULT ACTIVE for each item type
        const ITEM_TYPE_STATS = {
            gear: {
                armor:       { applicable: ['armorClass', 'durability', 'ergoPenalty', 'speedPenalty', 'turnPenalty'], defaultActive: ['armorClass', 'durability'] },
                helmet:      { applicable: ['armorClass', 'durability', 'ergoPenalty', 'speedPenalty', 'turnPenalty', 'ricochetY'], defaultActive: ['armorClass', 'ricochetY'] },
                rig:         { applicable: ['capacity', 'ergoPenalty', 'speedPenalty'], defaultActive: ['capacity'] },
                armored_rig: { applicable: ['armorClass', 'durability', 'capacity', 'ergoPenalty', 'speedPenalty'], defaultActive: ['armorClass', 'capacity'] },
                backpack:    { applicable: ['capacity', 'speedPenalty'], defaultActive: ['capacity'] },
                headphones:  { applicable: ['ambientVol', 'distortion'], defaultActive: ['ambientVol'] },
            },
            attachments: {
                Magazines:        { applicable: ['magCapacity', 'ergoMod'], defaultActive: ['magCapacity'] },
                Scopes:           { applicable: ['zoomLevel', 'sightingRange', 'ergoMod'], defaultActive: ['zoomLevel'] },
                'Assault Scopes': { applicable: ['zoomLevel', 'sightingRange', 'ergoMod'], defaultActive: ['zoomLevel'] },
                'Reflex Sights':  { applicable: ['ergoMod', 'recoilMod'], defaultActive: ['ergoMod'] },
                'Iron Sights':    { applicable: ['ergoMod'], defaultActive: ['ergoMod'] },
                'Thermal/NV':     { applicable: ['zoomLevel', 'ergoMod'], defaultActive: ['zoomLevel'] },
                Suppressors:      { applicable: ['recoilMod', 'ergoMod'], defaultActive: ['recoilMod'] },
                Barrels:          { applicable: ['ergoMod', 'recoilMod', 'accMod'], defaultActive: ['ergoMod', 'recoilMod'] },
                'Muzzle Devices': { applicable: ['ergoMod', 'recoilMod', 'accMod'], defaultActive: ['recoilMod'] },
                'Pistol Grips':   { applicable: ['ergoMod', 'recoilMod'], defaultActive: ['ergoMod'] },
                Stocks:           { applicable: ['ergoMod', 'recoilMod'], defaultActive: ['ergoMod', 'recoilMod'] },
                Handguards:       { applicable: ['ergoMod', 'recoilMod'], defaultActive: ['ergoMod'] },
                Foregrips:        { applicable: ['ergoMod', 'recoilMod'], defaultActive: ['ergoMod', 'recoilMod'] },
                Mounts:           { applicable: ['ergoMod', 'recoilMod'], defaultActive: ['ergoMod'] },
                Flashlights:      { applicable: ['ergoMod'], defaultActive: ['ergoMod'] },
                Lasers:           { applicable: ['ergoMod'], defaultActive: ['ergoMod'] },
                'Light/Laser':    { applicable: ['ergoMod'], defaultActive: ['ergoMod'] },
                'Tactical Devices': { applicable: ['ergoMod'], defaultActive: ['ergoMod'] },
                Rails:            { applicable: ['ergoMod'], defaultActive: ['ergoMod'] },
                Receivers:        { applicable: ['ergoMod', 'recoilMod'], defaultActive: ['ergoMod'] },
                'Charging Handles': { applicable: ['ergoMod'], defaultActive: ['ergoMod'] },
                'Gas Blocks':     { applicable: ['ergoMod', 'recoilMod'], defaultActive: ['ergoMod'] },
                'Auxiliary Parts': { applicable: ['ergoMod', 'recoilMod'], defaultActive: ['ergoMod'] },
                Bipods:           { applicable: ['ergoMod', 'recoilMod'], defaultActive: ['recoilMod'] },
                Other:            { applicable: ['ergoMod', 'recoilMod', 'accMod'], defaultActive: ['ergoMod'] },
                _default:         { applicable: ['ergoMod', 'recoilMod', 'accMod'], defaultActive: ['ergoMod', 'recoilMod'] }
            },
            // Ammo and weapons don't need type-specific handling (all stats apply)
            ammo: {
                _default: { applicable: null, defaultActive: ['pen', 'dmg'] } // null = all stats applicable
            },
            weapons: {
                _default: { applicable: null, defaultActive: ['ergo', 'recoilVert'] }
            }
        };
        
        // Get applicable stats for an item type
        function getApplicableStats(category, itemType) {
            const typeConfig = ITEM_TYPE_STATS[category];
            if (!typeConfig) return Object.keys(STAT_DEFINITIONS[category]);
            
            const config = typeConfig[itemType] || typeConfig._default;
            if (!config || config.applicable === null) {
                return Object.keys(STAT_DEFINITIONS[category]);
            }
            return config.applicable;
        }
        
        // Get default active stats for an item type
        function getDefaultActiveStats(category, itemType) {
            const typeConfig = ITEM_TYPE_STATS[category];
            if (!typeConfig) return DEFAULT_ACTIVE_STATS[category];
            
            const config = typeConfig[itemType] || typeConfig._default;
            return config?.defaultActive || DEFAULT_ACTIVE_STATS[category];
        }
        
        // Build default thresholds from stat definitions
        function buildDefaultThresholds(category) {
            const thresholds = {};
            for (const [statKey, statDef] of Object.entries(STAT_DEFINITIONS[category])) {
                thresholds[statKey] = { ...statDef.defaults };
            }
            return thresholds;
        }
        
        // Storage keys
        const STORAGE_KEY_TIER_THRESHOLDS = 'tarkov_planner_thresholds_v2';
        const STORAGE_KEY_TIER_OVERRIDES = 'tarkov_planner_overrides_v2';
        const STORAGE_KEY_ACTIVE_STATS = 'tarkov_planner_active_stats_v2';
        const STORAGE_KEY_WEAPONS = 'tarkov_planner_weapons_v1';
        const STORAGE_KEY_GEAR = 'tarkov_planner_gear_v1';
        const STORAGE_KEY_ATTACHMENTS = 'tarkov_planner_attachments_v1';
        
        // Tier configuration
        const TIER_NAMES = ['S', 'A', 'B', 'C', 'D', 'F'];
        const TIER_ORDER = ['S', 'A', 'B', 'C', 'D', 'F'];
        
        // State
        let mapInstance = null;
        let currentMapLayer = null;
        let imageBounds = null;
        let allQuestsGlobal = [];
        let questLocationsData = null;
        let questMarkersLayer = null;
        let currentMapHeight = 0;
        let currentMapWidth = 0;
        let currentMapOffsetX = 0; // viewBox minX offset
        let currentMapOffsetY = 0; // viewBox minY offset
        let selectedQuestNamesForMarkers = [];
        let currentQuestGrouping = 'trader'; // 'trader' or 'map'
        let selectedQuestsForMarkers = []; // Full quest objects for marker drawing
        let requiredMapsForQuests = new Set();
        
        // Unified tier system state
        let tierThresholds = {
            ammo: buildDefaultThresholds('ammo'),
            weapons: buildDefaultThresholds('weapons'),
            gear: buildDefaultThresholds('gear'),
            attachments: buildDefaultThresholds('attachments')
        };
        let activeStats = JSON.parse(JSON.stringify(DEFAULT_ACTIVE_STATS));
        let tierOverrides = { ammo: {}, weapons: {}, gear: {}, attachments: {} };
        let keepTierThreshold = { ammo: 'B', weapons: 'B', gear: 'B', attachments: 'B' };
        
        // Data state
        let allAmmoData = null;
        let ownedAmmo = new Set();
        let allWeaponsData = null;
        let ownedWeapons = new Set();
        let allGearData = null;
        let ownedGear = new Set();
        let allAttachmentsData = null;
        let ownedAttachments = new Set();
        
        // Filter state
        let weaponTypeFilter = 'ALL';
        let weaponSearchQuery = '';
        let gearTypeFilter = 'ALL';
        let gearSearchQuery = '';
        let attachmentTypeFilter = 'ALL';
        let attachmentSearchQuery = '';

        // ============================================================================
        // STATUS INDICATOR
        // ============================================================================
        
        function updateStatus(connected, version = '1.0&beta;') {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            if (connected) {
                dot.classList.remove('offline');
                text.textContent = `v${version} connected`;
            } else {
                dot.classList.add('offline');
                text.textContent = 'Offline';
            }
        }

        // ============================================================================
        // TARKOVDATA INTEGRATION - Quest Locations
        // ============================================================================
        
        const TARKOVDATA_QUESTS_URL = 'https://raw.githubusercontent.com/TarkovTracker/tarkovdata/master/quests.json';
        
        async function loadQuestLocationsData() {
            try {
                const response = await fetch(TARKOVDATA_QUESTS_URL);
                if (!response.ok) throw new Error('Failed to load tarkovdata');
                const data = await response.json();
                
                // Parse quest locations - index by quest name for matching
                questLocationsData = { byMap: {}, byQuestName: {} };
                let totalLocations = 0;
                
                for (const [questId, quest] of Object.entries(data)) {
                    const questTitle = (quest.title || quest.name || '').toLowerCase().trim();
                    
                    if (quest.objectives) {
                        let objIndex = 0;
                        quest.objectives.forEach(obj => {
                            if (obj.gps && obj.gps.leftPercent !== undefined && obj.gps.topPercent !== undefined) {
                                const mapKey = getMapKeyFromLocation(obj.location, quest);
                                if (!mapKey) return;
                                
                                objIndex++;
                                
                                // Build human-readable description - filter out raw MongoDB IDs
                                const isMongoId = (str) => /^[a-f0-9]{24}$/i.test(str);
                                
                                // Get readable type label
                                const typeLabels = {
                                    'mark': 'Mark location',
                                    'find': 'Find item',
                                    'pickup': 'Pick up item',
                                    'place': 'Place item',
                                    'locate': 'Locate',
                                    'key': 'Use key',
                                    'shoot': 'Shoot',
                                    'kill': 'Eliminate target',
                                    'extract': 'Extract',
                                    'visit': 'Visit location',
                                    'build': 'Build/Install',
                                    'plantItem': 'Plant item',
                                    'giveItem': 'Hand over item',
                                    'findItem': 'Find in raid'
                                };
                                
                                const typeLabel = typeLabels[obj.type] || (obj.type ? obj.type.charAt(0).toUpperCase() + obj.type.slice(1) : 'Objective');
                                
                                // Build description from available fields, excluding IDs
                                let description = typeLabel;
                                if (obj.target && !isMongoId(obj.target)) {
                                    description = obj.target;
                                }
                                // Don't include 'tool' if it's a raw ID
                                if (obj.tool && !isMongoId(obj.tool)) {
                                    description += ` (using ${obj.tool})`;
                                }
                                
                                // Truncate and clean up
                                description = description.substring(0, 100).trim();
                                if (!description || description === typeLabel) {
                                    description = `${typeLabel} #${objIndex}`;
                                }
                                
                                const locData = {
                                    questId: questId,
                                    questName: quest.title || quest.name || `Quest ${questId}`,
                                    objectiveIndex: objIndex,
                                    objectiveId: obj.id,
                                    type: obj.type || 'unknown',
                                    description: description,
                                    target: obj.target || '',
                                    tool: obj.tool || '',
                                    leftPercent: obj.gps.leftPercent,
                                    topPercent: obj.gps.topPercent,
                                    floor: obj.gps.floor || 'Ground_Level',
                                    mapKey: mapKey
                                };
                                
                                // Index by map
                                if (!questLocationsData.byMap[mapKey]) {
                                    questLocationsData.byMap[mapKey] = [];
                                }
                                questLocationsData.byMap[mapKey].push(locData);
                                
                                // Index by quest name (lowercase for matching)
                                if (!questLocationsData.byQuestName[questTitle]) {
                                    questLocationsData.byQuestName[questTitle] = [];
                                }
                                questLocationsData.byQuestName[questTitle].push(locData);
                                
                                totalLocations++;
                            }
                        });
                    }
                }
                
                console.log('Quest locations loaded:', totalLocations, 'objectives');
                return questLocationsData;
            } catch (error) {
                console.error('Error loading quest locations:', error);
                return null;
            }
        }
        
        function getMapKeyFromLocation(locationId, quest) {
            const locationMap = {
                0: 'customs',
                1: 'factory',
                2: 'woods',
                3: 'shoreline',
                4: 'interchange',
                5: 'lighthouse',
                6: 'reserve',
                7: 'labs',
                8: 'streets',
                9: 'groundzero'
            };
            
            if (locationId !== undefined && locationMap[locationId]) {
                return locationMap[locationId];
            }
            if (quest.location !== undefined && locationMap[quest.location]) {
                return locationMap[quest.location];
            }
            return null;
        }
        
        // Quest color palette - distinct colors for each quest
        const QUEST_COLORS = [
            { fill: '#2d7a2d', border: '#7fff7f' },  // Green
            { fill: '#7a2d7a', border: '#ff7fff' },  // Magenta
            { fill: '#2d5a7a', border: '#7fdfff' },  // Cyan
            { fill: '#7a5a2d', border: '#ffc77f' },  // Orange
            { fill: '#5a2d7a', border: '#bf7fff' },  // Purple
            { fill: '#7a2d2d', border: '#ff7f7f' },  // Red
            { fill: '#2d7a5a', border: '#7fffbf' },  // Teal
            { fill: '#7a7a2d', border: '#ffff7f' },  // Yellow
            { fill: '#4a4a7a', border: '#9f9fff' },  // Lavender
            { fill: '#7a4a4a', border: '#ffafaf' },  // Pink
            { fill: '#2d4a4a', border: '#7fbfbf' },  // Dark Cyan
            { fill: '#4a7a4a', border: '#afdfaf' },  // Lime
        ];
        
        let currentQuestColors = {};
        
        async function drawQuestMarkers(mapKey, mapWidth, mapHeight, questNames = [], selectedQuests = []) {
            if (!questMarkersLayer) {
                questMarkersLayer = L.layerGroup();
            }
            questMarkersLayer.clearLayers();
            
            const legend = document.getElementById('mapLegend');
            const legendItems = document.getElementById('legendItems');
            
            // Get map config for coordinate corrections
            const mapCfg = MAP_CONFIG[mapKey] || { scaleX: 1, scaleY: 1, offsetX: 0, offsetY: 0, flipY: false };
            
            // Load marker corrections from database
            const corrections = await loadMarkerCorrections(mapKey);
            
            // Only draw markers if we have selected quests
            if (!questLocationsData || questNames.length === 0) {
                updateMarkerCount(0);
                legend.style.display = 'none';
                return;
            }
            
            // Build a map of quest name -> API map key for validation
            const questApiMaps = {};
            selectedQuests.forEach(q => {
                const normalizedName = q.name.toLowerCase().trim();
                if (q.map?.name && q.map.name.toLowerCase() !== 'any') {
                    questApiMaps[normalizedName] = mapNameToKey(q.map.name);
                }
            });
            
            // Assign colors to quests
            currentQuestColors = {};
            questNames.forEach((qName, index) => {
                currentQuestColors[qName.toLowerCase().trim()] = QUEST_COLORS[index % QUEST_COLORS.length];
            });
            
            // Build legend
            legendItems.innerHTML = questNames.map((qName, index) => {
                const color = QUEST_COLORS[index % QUEST_COLORS.length];
                return `<div class="legend-item">
                    <div class="legend-color" style="background: ${color.fill}; border-color: ${color.border};"></div>
                    <span>${qName}</span>
                </div>`;
            }).join('');
            legend.style.display = 'block';
            
            let markerCount = 0;
            
            // Draw markers only for selected quests
            questNames.forEach((qName, questIndex) => {
                const normalizedName = qName.toLowerCase().trim();
                const locations = questLocationsData.byQuestName[normalizedName] || [];
                const color = QUEST_COLORS[questIndex % QUEST_COLORS.length];
                
                // Get the authoritative API map for this quest (if any)
                const apiMapKey = questApiMaps[normalizedName];
                
                locations.forEach(loc => {
                    // Determine if we should draw this marker:
                    // 1. If quest has a specific API map, draw ALL its locations on that map (trust API over tarkovdata location IDs)
                    // 2. If quest is "any" map, use the tarkovdata location ID
                    let shouldDraw = false;
                    
                    if (apiMapKey) {
                        // Quest has specific map from API - draw all locations if we're on that map
                        shouldDraw = (mapKey === apiMapKey);
                    } else {
                        // Quest is "any" - use tarkovdata location ID
                        shouldDraw = (loc.mapKey === mapKey);
                    }
                    
                    if (!shouldDraw) return;
                    
                    // Check for database correction for this marker (keyed by quest_id|objective_index)
                    const correctionKey = `${loc.questId}|${loc.objectiveIndex}`;
                    const correction = corrections[correctionKey];
                    
                    // Use corrected coordinates if available, otherwise original
                    let baseLeftPercent = loc.leftPercent;
                    let baseTopPercent = loc.topPercent;
                    let hasCorrection = false;
                    
                    if (correction) {
                        baseLeftPercent = correction.correctedLeftPercent;
                        baseTopPercent = correction.correctedTopPercent;
                        hasCorrection = true;
                        console.log(`Applied correction for ${loc.questName} #${loc.objectiveIndex} (${loc.questId})`);
                    }
                    
                    // Apply map-specific coordinate corrections
                    let correctedLeftPct = baseLeftPercent * mapCfg.scaleX + mapCfg.offsetX;
                    let correctedTopPct = baseTopPercent * mapCfg.scaleY + mapCfg.offsetY;
                    
                    // Optional Y-axis flip (before pixel conversion)
                    if (mapCfg.flipY) {
                        correctedTopPct = 100 - correctedTopPct;
                    }
                    
                    // Convert percent to pixel coordinates
                    const pixelX = (correctedLeftPct / 100) * mapWidth;
                    const pixelY = (correctedTopPct / 100) * mapHeight;
                    
                    // Leaflet CRS.Simple: optionally invert Y
                    const leafletX = pixelX;
                    const leafletY = mapCfg.invertLeafletY !== false ? (mapHeight - pixelY) : pixelY;
                    
                    // Debug logging for coordinate issues
                    if (markerCount < 3) {
                        console.log(`Quest marker ${qName} #${markerCount+1}:`, {
                            original: { leftPercent: loc.leftPercent, topPercent: loc.topPercent },
                            corrected: { leftPct: correctedLeftPct, topPct: correctedTopPct },
                            mapSize: { width: mapWidth, height: mapHeight },
                            pixel: { x: pixelX, y: pixelY },
                            leaflet: { x: leafletX, y: leafletY },
                            mapCfg: { flipY: mapCfg.flipY, invertLeafletY: mapCfg.invertLeafletY }
                        });
                    }
                    
                    markerCount++;
                    
                    // Create custom div icon with number
                    const markerHtml = `
                        <div style="position: relative; width: 24px; height: 24px;">
                            <div style="width: 24px; height: 24px; border-radius: 50%; background: ${color.fill}; border: 3px solid ${color.border};"></div>
                            <div style="position: absolute; top: -6px; right: -6px; background: #c4b896; color: #000; font-weight: 700; font-size: 10px; width: 14px; height: 14px; line-height: 14px; text-align: center; border-radius: 50%;">${loc.objectiveIndex || markerCount}</div>
                        </div>
                    `;
                    
                    const icon = L.divIcon({
                        html: markerHtml,
                        className: 'quest-marker-icon',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                    
                    // Create marker with draggable option (disabled by default)
                    const marker = L.marker([leafletY, leafletX], { 
                        icon: icon,
                        draggable: false  // Disabled by default, enabled in edit mode
                    });
                    
                    // Store metadata for corrections system
                    // Use corrected coordinates as base if available
                    marker._questData = {
                        questId: loc.questId,
                        questName: loc.questName,
                        objectiveId: loc.objectiveId,
                        objectiveIndex: loc.objectiveIndex,
                        mapKey: mapKey,
                        originalLeftPercent: baseLeftPercent,  // Use corrected coords if available
                        originalTopPercent: baseTopPercent,
                        description: loc.description,
                        hasDbCorrection: hasCorrection
                    };
                    
                    // Note: dragging is controlled via toggleEditMode() after marker is added to map
                    
                    // Drag event handlers
                    marker.on('dragstart', function(e) {
                        this._icon?.classList.add('marker-dragging');
                    });
                    
                    marker.on('dragend', function(e) {
                        this._icon?.classList.remove('marker-dragging');
                        if (isEditMode && currentUser) {
                            showCorrectionDialog(this, e);
                        }
                    });
                    
                    // Build tooltip text: short and informative
                    const typeLabels = {
                        'mark': 'MARK', 'find': 'FIND', 'pickup': 'PICKUP', 'place': 'PLACE',
                        'locate': 'LOCATE', 'key': 'KEY', 'shoot': 'SHOOT', 'kill': 'KILL',
                        'extract': 'EXTRACT', 'visit': 'VISIT', 'plantItem': 'PLANT', 'giveItem': 'GIVE'
                    };
                    const typeLabel = typeLabels[loc.type] || loc.type.toUpperCase();
                    const shortDesc = loc.description.length > 40 ? loc.description.substring(0, 37) + '...' : loc.description;
                    const tooltipText = `${loc.questName}`;
                    
                    // Get appropriate color class for objective type
                    const typeColorClass = {
                        'mark': 'obj-mark', 'find': 'obj-find', 'pickup': 'obj-pickup', 'place': 'obj-place',
                        'locate': 'obj-locate', 'kill': 'obj-kill', 'shoot': 'obj-kill',
                        'key': 'obj-find', 'visit': 'obj-locate', 'plantItem': 'obj-place', 'giveItem': 'obj-place'
                    }[loc.type] || 'obj-find';
                    
                    const popupContent = `
                        <div class="quest-marker-popup">
                            <span class="obj-num">#${loc.objectiveIndex || markerCount}</span>
                            <span class="obj-type ${typeColorClass}">${typeLabel}</span>
                            <h6>${loc.questName}</h6>
                            <p>${loc.description}</p>
                            ${loc.floor && loc.floor !== 'Ground_Level' ? `<div class="popup-footer">üìç Floor: ${loc.floor.replace(/_/g, ' ')}</div>` : ''}
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                    marker.bindTooltip(tooltipText, { 
                        direction: 'auto',  // Auto-adjust direction to avoid clipping
                        className: 'marker-label', 
                        offset: [0, -10],
                        sticky: false
                    });
                    
                    questMarkersLayer.addLayer(marker);
                });
            });
            
            if (mapInstance) {
                questMarkersLayer.addTo(mapInstance);
            }
            
            updateMarkerCount(markerCount);
        }
        
        function updateMarkerCount(questCount = null) {
            // If no count provided, calculate quest markers from DOM
            if (questCount === null) {
                questCount = document.querySelectorAll('.leaflet-marker-icon:not(.overlay-marker)').length;
            }
            // Add overlay markers
            const overlayCount = Object.values(overlayLayers).reduce((sum, layer) => sum + layer.markers.length, 0);
            const total = questCount + overlayCount;
            document.getElementById('markerCount').textContent = total + ' marker' + (total !== 1 ? 's' : '');
        }

        // ============================================================================
        // TAB NAVIGATION
        // ============================================================================
        
        function switchTab(tabId) {
            // Remove active from all tabs
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            // Find and activate the correct tab button
            const tabIndex = ['planner', 'hideout', 'penetration', 'ammo', 'weapons', 'gear', 'attachments'].indexOf(tabId);
            if (tabIndex >= 0) {
                const tabButtons = document.querySelectorAll('.nav-tab');
                if (tabButtons[tabIndex]) tabButtons[tabIndex].classList.add('active');
            }
            
            // Activate tab content
            const tabContent = document.getElementById('tab-' + tabId);
            if (tabContent) tabContent.classList.add('active');
            
            // Special handling for penetration tab
            if (tabId === 'penetration' && allAmmoData) {
                renderPenMatrix();
            }
            
            // Show/hide dashboard based on tab
            const dashboard = document.getElementById('inventoryDashboard');
            if (dashboard) {
                dashboard.style.display = ['ammo', 'weapons', 'gear', 'attachments'].includes(tabId) ? 'block' : 'none';
            }
        }

        // ============================================================================
        // QUEST MANAGEMENT
        // ============================================================================
        
        function getSavedQuests() {
            const saved = localStorage.getItem(STORAGE_KEY_QUESTS);
            return saved ? new Set(JSON.parse(saved)) : new Set();
        }
        
        function saveQuestState(questId, isSelected) {
            const saved = getSavedQuests();
            isSelected ? saved.add(questId) : saved.delete(questId);
            localStorage.setItem(STORAGE_KEY_QUESTS, JSON.stringify([...saved]));
            updateSelectedQuestCount();
        }
        
        function deselectAllQuests() {
            // Clear storage
            localStorage.setItem(STORAGE_KEY_QUESTS, JSON.stringify([]));
            
            // Uncheck all checkboxes in UI
            document.querySelectorAll('#quest-list input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
                const row = cb.closest('.quest-row');
                if (row) row.classList.remove('selected');
            });
            
            // Update all trader badges
            document.querySelectorAll('.trader-header').forEach(header => {
                const groupId = header.id?.replace('btn-', '');
                if (groupId) updateTraderBadge(groupId);
            });
            
            // Update counter
            updateSelectedQuestCount();
            
            // Update map selection hint
            updateMapSelection();
        }
        
        function updateSelectedQuestCount() {
            const count = getSavedQuests().size;
            const el = document.getElementById('selectedQuestCount');
            if (el) el.textContent = count;
        }
        
        // ============================================================================
        // QUEST COMPLETION TRACKING
        // ============================================================================
        
        const STORAGE_KEY_COMPLETED = 'tarkov_planner_completed_v1';
        
        function getCompletedQuests() {
            const saved = localStorage.getItem(STORAGE_KEY_COMPLETED);
            return saved ? new Set(JSON.parse(saved)) : new Set();
        }
        
        function setQuestCompleted(questId, isCompleted) {
            const completed = getCompletedQuests();
            isCompleted ? completed.add(questId) : completed.delete(questId);
            localStorage.setItem(STORAGE_KEY_COMPLETED, JSON.stringify([...completed]));
        }
        
        function toggleQuestCompleted(questId, event) {
            event.stopPropagation();
            const completed = getCompletedQuests();
            const isNowCompleted = !completed.has(questId);
            setQuestCompleted(questId, isNowCompleted);
            
            // Update UI
            const row = document.querySelector(`#cb-${questId}`)?.closest('.quest-row');
            if (row) {
                row.classList.toggle('completed', isNowCompleted);
                const btn = row.querySelector('.complete-btn');
                if (btn) btn.textContent = isNowCompleted ? '‚úì' : '‚óã';
            }
            
            // Update trader badge
            const groupId = document.querySelector(`#cb-${questId}`)?.dataset.parentGroup;
            if (groupId) updateTraderBadge(groupId);
            
            // Re-apply filter if "hide completed" is active
            const hideToggle = document.getElementById('hideCompletedToggle');
            if (hideToggle?.checked) filterQuests();
        }
        
        // ============================================================================
        // QUEST PREREQUISITES
        // ============================================================================
        
        function getQuestPrereqs(quest) {
            if (!quest.taskRequirements || quest.taskRequirements.length === 0) return [];
            
            const completed = getCompletedQuests();
            return quest.taskRequirements.map(req => {
                const prereqQuest = allQuestsGlobal.find(q => q.id === req.task?.id);
                return {
                    id: req.task?.id,
                    name: prereqQuest?.name || req.task?.name || 'Unknown',
                    isDone: completed.has(req.task?.id)
                };
            }).filter(p => p.id); // Filter out any without valid IDs
        }
        
        function isQuestLocked(quest) {
            const prereqs = getQuestPrereqs(quest);
            return prereqs.length > 0 && prereqs.some(p => !p.isDone);
        }
        
        function renderPrereqsHtml(prereqs) {
            if (!prereqs || prereqs.length === 0) return '';
            
            // Just show prerequisite names - purely informational
            const prereqHtml = prereqs.map(p => 
                `<span class="prereq-tag ${p.isDone ? 'prereq-done' : 'prereq-pending'}">${p.name}</span>`
            ).join('');
            
            return `<div class="quest-prereqs">Requires: ${prereqHtml}</div>`;
        }
        
        // ============================================================================
        // HIDEOUT TRACKER
        // ============================================================================
        
        const STORAGE_KEY_HIDEOUT = 'tarkov_planner_hideout_v1';
        const HIDEOUT_GRAPHQL_URL = 'https://api.tarkov.dev/graphql';
        
        let hideoutData = null;
        let hideoutDataLoaded = false;
        let hideoutProgress = {}; // stationId -> level completed
        
        function getHideoutProgress() {
            const saved = localStorage.getItem(STORAGE_KEY_HIDEOUT);
            return saved ? JSON.parse(saved) : {};
        }
        
        function saveHideoutProgress() {
            localStorage.setItem(STORAGE_KEY_HIDEOUT, JSON.stringify(hideoutProgress));
        }
        
        function setStationLevel(stationId, level) {
            hideoutProgress[stationId] = level;
            saveHideoutProgress();
            renderHideoutList();
            updateHideoutStats();
        }
        
        async function loadHideoutData() {
            const loading = document.getElementById('hideout-loading');
            const content = document.getElementById('hideout-content');
            const error = document.getElementById('hideout-error');
            
            loading.classList.remove('d-none');
            content.classList.add('d-none');
            error.classList.add('d-none');
            
            try {
                const query = `{
                    hideoutStations {
                        id
                        name
                        normalizedName
                        imageLink
                        levels {
                            level
                            constructionTime
                            itemRequirements {
                                item {
                                    id
                                    name
                                    shortName
                                    iconLink
                                }
                                count
                                attributes {
                                    type
                                    value
                                }
                            }
                            stationLevelRequirements {
                                station {
                                    id
                                    name
                                }
                                level
                            }
                            traderRequirements {
                                trader {
                                    name
                                }
                                level
                            }
                            skillRequirements {
                                name
                                level
                            }
                        }
                    }
                }`;
                
                const response = await fetch(HIDEOUT_GRAPHQL_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                
                if (!response.ok) throw new Error('API error: ' + response.status);
                
                const result = await response.json();
                hideoutData = result.data.hideoutStations;
                hideoutProgress = getHideoutProgress();
                hideoutDataLoaded = true;
                
                console.log(`Loaded ${hideoutData.length} hideout stations`);
                
                renderHideoutList();
                updateHideoutStats();
                
                loading.classList.add('d-none');
                content.classList.remove('d-none');
                
            } catch (err) {
                console.error('Error loading hideout data:', err);
                error.innerHTML = `<strong>ERROR:</strong> ${err.message}`;
                error.classList.remove('d-none');
                loading.classList.add('d-none');
            }
        }
        
        function renderHideoutList() {
            if (!hideoutData) return;
            
            const container = document.getElementById('hideout-stations-list');
            const searchTerm = document.getElementById('hideoutSearch')?.value.toLowerCase() || '';
            const hideCompleted = document.getElementById('hideCompletedStations')?.checked || false;
            
            // Sort stations alphabetically
            const sortedStations = [...hideoutData].sort((a, b) => a.name.localeCompare(b.name));
            
            let html = '';
            let shoppingListItems = new Map(); // itemId -> { item, count, stations[] }
            
            sortedStations.forEach(station => {
                const maxLevel = station.levels.length;
                const currentLevel = hideoutProgress[station.id] || 0;
                const isMaxed = currentLevel >= maxLevel;
                
                // Filter by search
                if (searchTerm && !station.name.toLowerCase().includes(searchTerm)) return;
                
                // Filter by completion
                if (hideCompleted && isMaxed) return;
                
                // Collect items for shopping list (next level only)
                if (currentLevel < maxLevel) {
                    const nextLevel = station.levels.find(l => l.level === currentLevel + 1);
                    if (nextLevel && nextLevel.itemRequirements) {
                        nextLevel.itemRequirements.forEach(req => {
                            const key = req.item.id;
                            const fir = isFoundInRaid(req.attributes);
                            if (shoppingListItems.has(key)) {
                                shoppingListItems.get(key).count += req.count;
                                shoppingListItems.get(key).stations.push(station.name);
                                // Mark as FIR if any requirement needs FIR
                                if (fir) shoppingListItems.get(key).fir = true;
                            } else {
                                shoppingListItems.set(key, {
                                    item: req.item,
                                    count: req.count,
                                    stations: [station.name],
                                    fir: fir
                                });
                            }
                        });
                    }
                }
                
                html += `
                    <div class="hideout-station ${isMaxed ? 'maxed' : ''}" data-station-id="${station.id}">
                        <div class="hideout-station-header" onclick="toggleHideoutStation('${station.id}')">
                            ${station.imageLink ? `<img src="${station.imageLink}" alt="${station.name}">` : '<div style="width:48px;height:48px;background:var(--bg-dark);"></div>'}
                            <div class="station-info">
                                <div class="station-name">${station.name}</div>
                                <div class="station-level">Level <span class="current">${currentLevel}</span> / ${maxLevel}</div>
                            </div>
                            <span class="badge-tarkov ${isMaxed ? 'badge-active' : ''}">${isMaxed ? '‚úì MAXED' : `${maxLevel - currentLevel} to go`}</span>
                        </div>
                        <div class="hideout-station-levels" id="levels-${station.id}">
                            ${renderStationLevels(station, currentLevel)}
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html || '<div class="text-sub text-center p-3">No stations found</div>';
            
            // Render shopping list
            renderShoppingList(shoppingListItems);
        }
        
        function renderStationLevels(station, currentLevel) {
            let html = '';
            
            station.levels.forEach(level => {
                const isCompleted = currentLevel >= level.level;
                const isNext = level.level === currentLevel + 1;
                
                html += `
                    <div class="hideout-level ${isCompleted ? 'completed' : ''} ${isNext ? 'current-target' : ''}">
                        <div class="hideout-level-header">
                            <h6>Level ${level.level}</h6>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <span class="level-status ${isCompleted ? 'done' : 'locked'}">${isCompleted ? '‚úì Done' : 'Locked'}</span>
                                <button class="level-complete-btn ${isCompleted ? 'completed' : ''}" 
                                        onclick="event.stopPropagation(); toggleStationLevel('${station.id}', ${level.level}, ${isCompleted})">
                                    ${isCompleted ? '‚Ü© Undo' : '‚úì Complete'}
                                </button>
                            </div>
                        </div>
                        <div class="hideout-requirements">
                            ${renderLevelRequirements(level)}
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function isFoundInRaid(attributes) {
            if (!attributes || !Array.isArray(attributes)) return false;
            return attributes.some(attr => 
                attr.type === 'foundInRaid' && (attr.value === 'true' || attr.value === true)
            );
        }
        
        function renderLevelRequirements(level) {
            let html = '';
            
            // Item requirements
            if (level.itemRequirements && level.itemRequirements.length > 0) {
                html += `
                    <div class="hideout-req-section">
                        <div class="req-title">üì¶ Items Required</div>
                        <div class="hideout-req-items">
                            ${level.itemRequirements.map(req => {
                                const fir = isFoundInRaid(req.attributes);
                                return `
                                <div class="hideout-req-item ${fir ? 'fir-required' : ''}">
                                    ${req.item.iconLink ? `<img src="${req.item.iconLink}" alt="${req.item.shortName}">` : ''}
                                    <span class="item-count">${req.count}x</span>
                                    <span class="item-name" title="${req.item.name}">${req.item.shortName || req.item.name}</span>
                                    ${fir ? '<span class="fir-badge" title="Found in Raid required">FIR</span>' : ''}
                                </div>
                            `}).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Station requirements
            if (level.stationLevelRequirements && level.stationLevelRequirements.length > 0) {
                html += `
                    <div class="hideout-req-section">
                        <div class="req-title">üè† Station Requirements</div>
                        <div class="hideout-req-items">
                            ${level.stationLevelRequirements.map(req => `
                                <div class="hideout-req-item">
                                    <span class="item-name">${req.station.name} Lv${req.level}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Trader requirements
            if (level.traderRequirements && level.traderRequirements.length > 0) {
                html += `
                    <div class="hideout-req-section">
                        <div class="req-title">ü§ù Trader Requirements</div>
                        <div class="hideout-req-items">
                            ${level.traderRequirements.map(req => `
                                <div class="hideout-req-item">
                                    <span class="item-name">${req.trader.name} LL${req.level}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Skill requirements
            if (level.skillRequirements && level.skillRequirements.length > 0) {
                html += `
                    <div class="hideout-req-section">
                        <div class="req-title">üìà Skill Requirements</div>
                        <div class="hideout-req-items">
                            ${level.skillRequirements.map(req => `
                                <div class="hideout-req-item">
                                    <span class="item-name">${req.name} Lv${req.level}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Construction time
            if (level.constructionTime > 0) {
                const hours = Math.floor(level.constructionTime / 3600);
                const minutes = Math.floor((level.constructionTime % 3600) / 60);
                html += `
                    <div class="hideout-req-section">
                        <div class="req-title">‚è±Ô∏è Build Time: ${hours}h ${minutes}m</div>
                    </div>
                `;
            }
            
            return html || '<div class="text-sub small">No requirements</div>';
        }
        
        function renderShoppingList(itemsMap) {
            const container = document.getElementById('hideout-shopping-list');
            
            if (itemsMap.size === 0) {
                container.innerHTML = '<div class="text-sub text-center p-3">All next levels have no item requirements!</div>';
                return;
            }
            
            // Sort by count (most needed first)
            const sortedItems = [...itemsMap.values()].sort((a, b) => b.count - a.count);
            
            let html = '';
            sortedItems.forEach(data => {
                html += `
                    <div class="shopping-item ${data.fir ? 'fir-required' : ''}">
                        ${data.item.iconLink ? `<img src="${data.item.iconLink}" alt="${data.item.shortName}">` : ''}
                        <div class="item-info">
                            <div class="item-name">${data.item.shortName || data.item.name} ${data.fir ? '<span class="fir-badge">FIR</span>' : ''}</div>
                            <div class="item-for">For: ${data.stations.slice(0, 2).join(', ')}${data.stations.length > 2 ? ` +${data.stations.length - 2} more` : ''}</div>
                        </div>
                        <span class="item-count">${data.count}x</span>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function toggleHideoutStation(stationId) {
            const levelsEl = document.getElementById('levels-' + stationId);
            if (levelsEl) {
                levelsEl.classList.toggle('show');
            }
        }
        
        function toggleStationLevel(stationId, level, isCurrentlyCompleted) {
            if (isCurrentlyCompleted) {
                // Undo: set to level - 1
                setStationLevel(stationId, level - 1);
            } else {
                // Complete: set to this level
                setStationLevel(stationId, level);
            }
        }
        
        function filterHideoutStations() {
            renderHideoutList();
        }
        
        function updateHideoutStats() {
            if (!hideoutData) return;
            
            let totalLevels = 0;
            let completedLevels = 0;
            let stationsMaxed = 0;
            let stationsInProgress = 0;
            let stationsNotStarted = 0;
            
            hideoutData.forEach(station => {
                const maxLevel = station.levels.length;
                const currentLevel = hideoutProgress[station.id] || 0;
                
                totalLevels += maxLevel;
                completedLevels += currentLevel;
                
                if (currentLevel >= maxLevel) {
                    stationsMaxed++;
                } else if (currentLevel > 0) {
                    stationsInProgress++;
                } else {
                    stationsNotStarted++;
                }
            });
            
            // Update progress bar
            const progressPercent = totalLevels > 0 ? (completedLevels / totalLevels) * 100 : 0;
            document.getElementById('hideout-progress-fill').style.width = progressPercent + '%';
            document.getElementById('hideout-progress-text').textContent = `${completedLevels} / ${totalLevels} Levels`;
            
            // Update stats
            document.getElementById('stat-stations-count').textContent = hideoutData.length;
            document.getElementById('stat-completed-count').textContent = stationsMaxed;
            document.getElementById('stat-inprogress-count').textContent = stationsInProgress;
            document.getElementById('stat-notstarted-count').textContent = stationsNotStarted;
        }
        
        function getWikiUrl(questName) {
            return 'https://escapefromtarkov.fandom.com/wiki/' + encodeURIComponent(questName.replace(/ /g, '_'));
        }
        
        async function loadQuests() {
            const loading = document.getElementById('quest-loading');
            const list = document.getElementById('quest-list');
            const error = document.getElementById('quest-error');
            
            try {
                const response = await fetch(API_BASE + '/quests/ALL');
                if (!response.ok) throw new Error('Server error: ' + response.status);
                const data = await response.json();
                
                // Handle both array and object response
                allQuestsGlobal = Array.isArray(data) ? data : (data.quests || []);
                
                // Update connection status
                updateStatus(true, '1.0&beta;');
                
                // Render quest list
                renderQuestList();
                
                list.classList.remove('d-none');
                loading.classList.add('d-none');
                
            } catch (err) {
                updateStatus(false);
                error.innerHTML = `<strong>ERROR:</strong> ${err.message}<br><small>Make sure the backend is running</small>`;
                error.classList.remove('d-none');
                loading.classList.add('d-none');
            }
        }
        
        function setQuestGrouping(grouping) {
            currentQuestGrouping = grouping;
            
            // Update button states
            document.getElementById('groupByTrader').style.background = grouping === 'trader' ? 'var(--eft-gold)' : 'transparent';
            document.getElementById('groupByTrader').style.color = grouping === 'trader' ? '#000' : 'var(--text-sub)';
            document.getElementById('groupByMap').style.background = grouping === 'map' ? 'var(--eft-gold)' : 'transparent';
            document.getElementById('groupByMap').style.color = grouping === 'map' ? '#000' : 'var(--text-sub)';
            
            // Re-render quest list
            renderQuestList();
        }
        
        function renderQuestList() {
            const list = document.getElementById('quest-list');
            const savedQuests = getSavedQuests();
            const completedQuests = getCompletedQuests();
            
            if (!allQuestsGlobal || allQuestsGlobal.length === 0) {
                list.innerHTML = '<div class="text-sub text-center p-3">No tasks loaded</div>';
                return;
            }
            
            let html = '';
            
            if (currentQuestGrouping === 'trader') {
                // Group by trader
                const byTrader = {};
                allQuestsGlobal.forEach(q => {
                    const trader = q.trader?.name || 'Unknown';
                    if (!byTrader[trader]) byTrader[trader] = { quests: [], image: q.trader?.imageLink };
                    byTrader[trader].quests.push(q);
                });
                
                for (const [trader, data] of Object.entries(byTrader)) {
                    const groupId = 'trader-' + trader.replace(/\s+/g, '-');
                    html += `
                        <div class="trader-group">
                            <div class="trader-header" onclick="toggleTrader('${groupId}')" id="btn-${groupId}" data-total="${data.quests.length}">
                                ${data.image ? `<img src="${data.image}" alt="${trader}">` : ''}
                                <h6>${trader}</h6>
                                <span class="badge-tarkov">${data.quests.length} Tasks</span>
                            </div>
                            <div class="trader-quests" id="${groupId}">
                    `;
                    
                    data.quests.forEach(q => {
                        const isSelected = savedQuests.has(q.id);
                        const isCompleted = completedQuests.has(q.id);
                        const prereqs = getQuestPrereqs(q);
                        const prereqsHtml = renderPrereqsHtml(prereqs);
                        const questLevel = q.minPlayerLevel || 1;
                        
                        html += `
                            <div class="quest-row ${isSelected ? 'selected' : ''} ${isCompleted ? 'completed' : ''}" onclick="toggleSelection('${q.id}', this, event)" data-quest-id="${q.id}" data-quest-level="${questLevel}">
                                <input type="checkbox" id="cb-${q.id}" ${isSelected ? 'checked' : ''} data-parent-group="${groupId}" data-quest-name="${q.name}">
                                <button class="complete-btn" onclick="toggleQuestCompleted('${q.id}', event)" title="${isCompleted ? 'Mark as not done' : 'Mark as done'}">${isCompleted ? '‚úì' : '‚óã'}</button>
                                <div class="quest-info">
                                    <div class="quest-name">
                                        <a href="${getWikiUrl(q.name)}" target="_blank" rel="noopener noreferrer" onclick="event.stopPropagation()">${q.name}</a>
                                    </div>
                                    <div class="quest-meta">
                                        <span>${q.map?.name || 'Any'}</span>
                                        <span>Lvl ${q.minPlayerLevel || '?'}</span>
                                    </div>
                                    ${prereqsHtml}
                                </div>
                            </div>
                        `;
                    });
                    
                    html += '</div></div>';
                }
                
                list.innerHTML = html;
                
                // Update badges
                for (const trader of Object.keys(byTrader)) {
                    const groupId = 'trader-' + trader.replace(/\s+/g, '-');
                    updateTraderBadge(groupId);
                }
                
            } else {
                // Group by map
                const byMap = {};
                allQuestsGlobal.forEach(q => {
                    const mapName = q.map?.name || 'Any';
                    if (!byMap[mapName]) byMap[mapName] = [];
                    byMap[mapName].push(q);
                });
                
                // Sort maps alphabetically, but put "Any" at the end
                const mapNames = Object.keys(byMap).sort((a, b) => {
                    if (a === 'Any') return 1;
                    if (b === 'Any') return -1;
                    return a.localeCompare(b);
                });
                
                for (const mapName of mapNames) {
                    const quests = byMap[mapName];
                    const groupId = 'map-' + mapName.replace(/\s+/g, '-');
                    const mapKey = mapNameToKey(mapName);
                    
                    // Map icons
                    const mapIcons = {
                        'Customs': 'üè≠', 'Woods': 'üå≤', 'Shoreline': 'üèñÔ∏è', 'Interchange': 'üõí',
                        'Reserve': 'üè∞', 'Lighthouse': 'üóº', 'Streets of Tarkov': 'üèôÔ∏è',
                        'Ground Zero': '‚ò¢Ô∏è', 'Factory': 'üèóÔ∏è', 'The Lab': 'üî¨', 'Any': 'üåç'
                    };
                    const icon = mapIcons[mapName] || 'üìç';
                    
                    html += `
                        <div class="trader-group">
                            <div class="trader-header" onclick="toggleTrader('${groupId}')" id="btn-${groupId}" data-total="${quests.length}">
                                <span style="font-size: 1.5rem; margin-right: 8px;">${icon}</span>
                                <h6>${mapName}</h6>
                                <span class="badge-tarkov">${quests.length} Tasks</span>
                            </div>
                            <div class="trader-quests" id="${groupId}">
                    `;
                    
                    quests.forEach(q => {
                        const isSelected = savedQuests.has(q.id);
                        const isCompleted = completedQuests.has(q.id);
                        const prereqs = getQuestPrereqs(q);
                        const prereqsHtml = renderPrereqsHtml(prereqs);
                        const questLevel = q.minPlayerLevel || 1;
                        
                        html += `
                            <div class="quest-row ${isSelected ? 'selected' : ''} ${isCompleted ? 'completed' : ''}" onclick="toggleSelection('${q.id}', this, event)" data-quest-id="${q.id}" data-quest-level="${questLevel}">
                                <input type="checkbox" id="cb-${q.id}" ${isSelected ? 'checked' : ''} data-parent-group="${groupId}" data-quest-name="${q.name}">
                                <button class="complete-btn" onclick="toggleQuestCompleted('${q.id}', event)" title="${isCompleted ? 'Mark as not done' : 'Mark as done'}">${isCompleted ? '‚úì' : '‚óã'}</button>
                                <div class="quest-info">
                                    <div class="quest-name">
                                        <a href="${getWikiUrl(q.name)}" target="_blank" rel="noopener noreferrer" onclick="event.stopPropagation()">${q.name}</a>
                                    </div>
                                    <div class="quest-meta">
                                        <span>${q.trader?.name || 'Unknown'}</span>
                                        <span>Lvl ${q.minPlayerLevel || '?'}</span>
                                    </div>
                                    ${prereqsHtml}
                                </div>
                            </div>
                        `;
                    });
                    
                    html += '</div></div>';
                }
                
                list.innerHTML = html;
                
                // Update badges
                for (const mapName of mapNames) {
                    const groupId = 'map-' + mapName.replace(/\s+/g, '-');
                    updateTraderBadge(groupId);
                }
            }
            
            // Update selected quest count
            updateSelectedQuestCount();
        }
        
        function toggleTrader(groupId) {
            document.getElementById(groupId).classList.toggle('show');
        }
        
        function toggleSelection(questId, div, ev) {
            const cb = document.getElementById('cb-' + questId);
            if (ev.target !== cb && ev.target.tagName !== 'A') {
                cb.checked = !cb.checked;
            }
            cb.checked ? div.classList.add('selected') : div.classList.remove('selected');
            saveQuestState(questId, cb.checked);
            
            const groupId = cb.getAttribute('data-parent-group');
            if (groupId) updateTraderBadge(groupId);
            
            // Update map selection based on selected quests
            updateMapSelection();
        }
        
        function updateMapSelection() {
            const savedQuests = getSavedQuests();
            const selectedQuests = allQuestsGlobal.filter(q => savedQuests.has(q.id));
            const mapSelect = document.getElementById('mapSelect');
            const mapHint = document.getElementById('mapHint');
            
            if (selectedQuests.length === 0) {
                // No quests selected - enable all maps, hide hint
                Array.from(mapSelect.options).forEach(opt => opt.disabled = false);
                mapHint.style.display = 'none';
                requiredMapsForQuests = new Set();
                return;
            }
            
            // Collect required maps from API quest data AND tarkovdata locations
            requiredMapsForQuests = new Set();
            
            selectedQuests.forEach(q => {
                // Get the authoritative map from API (if specific, not "any")
                const apiMapKey = (q.map?.name && q.map.name.toLowerCase() !== 'any') 
                    ? mapNameToKey(q.map.name) 
                    : null;
                
                // If API specifies a map, that's the primary source
                if (apiMapKey) {
                    requiredMapsForQuests.add(apiMapKey);
                }
                
                // From tarkovdata GPS locations - but validate against API map
                if (questLocationsData) {
                    const questTitle = q.name.toLowerCase().trim();
                    const locations = questLocationsData.byQuestName[questTitle] || [];
                    locations.forEach(loc => {
                        if (loc.mapKey) {
                            // If quest has specific API map, only add GPS locations that match
                            // This filters out erroneous location IDs in tarkovdata
                            if (apiMapKey) {
                                if (loc.mapKey === apiMapKey) {
                                    requiredMapsForQuests.add(loc.mapKey);
                                }
                                // Silently ignore mismatched GPS locations (data error in tarkovdata)
                            } else {
                                // Quest is "any" map - trust GPS locations
                                requiredMapsForQuests.add(loc.mapKey);
                            }
                        }
                    });
                }
            });
            
            // If no specific maps found (all "any" quests), enable all
            if (requiredMapsForQuests.size === 0) {
                Array.from(mapSelect.options).forEach(opt => opt.disabled = false);
                mapHint.textContent = 'Selected tasks can be completed on any map';
                mapHint.className = 'map-hint';
                mapHint.style.display = 'block';
                return;
            }
            
            // Enable/disable map options
            const mapNames = [];
            Array.from(mapSelect.options).forEach(opt => {
                const isRequired = requiredMapsForQuests.has(opt.value);
                opt.disabled = !isRequired;
                if (isRequired) {
                    mapNames.push(opt.textContent);
                }
            });
            
            // Sort alphabetically and select first
            mapNames.sort();
            const sortedMaps = Array.from(requiredMapsForQuests).sort();
            
            // Auto-select first available map if current selection is disabled
            const currentSelected = mapSelect.value;
            if (!requiredMapsForQuests.has(currentSelected)) {
                mapSelect.value = sortedMaps[0];
            }
            
            // Show hint
            if (requiredMapsForQuests.size === 1) {
                mapHint.textContent = `Task location: ${mapNames[0]}`;
                mapHint.className = 'map-hint';
            } else {
                mapHint.textContent = `Tasks require ${requiredMapsForQuests.size} maps: ${mapNames.join(', ')}`;
                mapHint.className = 'map-hint warning';
            }
            mapHint.style.display = 'block';
        }
        
        function mapNameToKey(mapName) {
            const nameMap = {
                'customs': 'customs',
                'woods': 'woods',
                'shoreline': 'shoreline',
                'interchange': 'interchange',
                'reserve': 'reserve',
                'lighthouse': 'lighthouse',
                'streets of tarkov': 'streets',
                'streets': 'streets',
                'ground zero': 'groundzero',
                'factory': 'factory',
                'the lab': 'labs',
                'laboratory': 'labs',
                'labs': 'labs'
            };
            return nameMap[mapName.toLowerCase()] || null;
        }
        
        function updateTraderBadge(groupId) {
            const btn = document.getElementById('btn-' + groupId);
            if (!btn) return;
            const count = document.querySelectorAll(`input[data-parent-group="${groupId}"]:checked`).length;
            const badge = btn.querySelector('.badge-tarkov');
            badge.textContent = count > 0 ? count + ' Active' : btn.dataset.total + ' Tasks';
            badge.classList.toggle('badge-active', count > 0);
        }
        
        function filterQuests() {
            const search = document.getElementById('questSearch').value.toLowerCase();
            const hideCompleted = document.getElementById('hideCompletedToggle')?.checked || false;
            const maxLevel = parseInt(document.getElementById('levelFilter')?.value) || 0;
            const completedQuests = getCompletedQuests();
            
            // Filter individual quest rows
            document.querySelectorAll('.quest-row').forEach(row => {
                const name = row.querySelector('.quest-name').textContent.toLowerCase();
                const questId = row.dataset.questId;
                const questLevel = parseInt(row.dataset.questLevel) || 1;
                const matchesSearch = name.includes(search);
                const isCompleted = questId && completedQuests.has(questId);
                const matchesLevel = maxLevel === 0 || questLevel <= maxLevel;
                
                // Show if: matches search AND matches level AND (not hiding completed OR not completed)
                const shouldShow = matchesSearch && matchesLevel && (!hideCompleted || !isCompleted);
                row.style.display = shouldShow ? '' : 'none';
            });
            
            // Hide/show groups based on whether they have visible quests
            document.querySelectorAll('.trader-group').forEach(group => {
                const allRows = group.querySelectorAll('.quest-row');
                let hasVisible = false;
                
                allRows.forEach(row => {
                    if (row.style.display !== 'none') {
                        hasVisible = true;
                    }
                });
                
                group.style.display = hasVisible ? '' : 'none';
                
                // Auto-expand groups that have matches when searching
                if (search && hasVisible) {
                    const questsContainer = group.querySelector('.trader-quests');
                    if (questsContainer) questsContainer.classList.add('show');
                }
                
                // Collapse groups when search is cleared
                if (!search) {
                    const questsContainer = group.querySelector('.trader-quests');
                    if (questsContainer) questsContainer.classList.remove('show');
                }
            });
        }

        // ============================================================================
        // MAP MANAGEMENT
        // ============================================================================
        
        async function initMap(mapName, questNames = [], selectedQuests = []) {
            const cfg = MAP_CONFIG[mapName];
            if (!cfg) return;
            
            if (mapInstance) {
                mapInstance.remove();
                mapInstance = null;
            }
            
            const isSvg = cfg.file.toLowerCase().endsWith('.svg');
            
            try {
                if (isSvg) {
                    // For SVG: fetch and parse viewBox to get dimensions
                    const response = await fetch(cfg.file);
                    if (!response.ok) throw new Error('SVG not found');
                    const svgText = await response.text();
                    
                    // Parse viewBox from SVG
                    const viewBoxMatch = svgText.match(/viewBox=["']([^"']+)["']/);
                    if (viewBoxMatch) {
                        const [minX, minY, width, height] = viewBoxMatch[1].split(/\s+/).map(Number);
                        currentMapOffsetX = minX || 0;
                        currentMapOffsetY = minY || 0;
                        currentMapWidth = width;
                        currentMapHeight = height;
                        console.log(`SVG viewBox: minX=${minX}, minY=${minY}, width=${width}, height=${height}`);
                    } else {
                        // Fallback: try width/height attributes
                        const widthMatch = svgText.match(/width=["'](\d+)/);
                        const heightMatch = svgText.match(/height=["'](\d+)/);
                        currentMapWidth = widthMatch ? parseInt(widthMatch[1]) : 1000;
                        currentMapHeight = heightMatch ? parseInt(heightMatch[1]) : 1000;
                        currentMapOffsetX = 0;
                        currentMapOffsetY = 0;
                    }
                } else {
                    // For raster images: use Image object
                    const img = new Image();
                    img.src = cfg.file;
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                    });
                    currentMapWidth = img.naturalWidth;
                    currentMapHeight = img.naturalHeight;
                }
            } catch (e) {
                document.getElementById('map').innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--eft-red);">
                        <div class="text-center">
                            <div style="font-size: 2rem;">!</div>
                            <div>Map not found: ${cfg.file}</div>
                        </div>
                    </div>
                `;
                return;
            }
            
            imageBounds = [[0, 0], [currentMapHeight, currentMapWidth]];
            
            // Get map container dimensions to calculate optimal zoom
            const mapContainer = document.getElementById('map');
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            
            // Calculate the zoom level that makes the image fit exactly in the container
            // This will be our minZoom (can't zoom out further than full image visible)
            const zoomX = Math.log2(containerWidth / currentMapWidth);
            const zoomY = Math.log2(containerHeight / currentMapHeight);
            const fitZoom = Math.min(zoomX, zoomY);
            
            // Set minZoom slightly below fitZoom to allow small margin, but not too much
            const calculatedMinZoom = Math.floor(fitZoom * 4) / 4; // Round to nearest 0.25
            
            console.log(`Map zoom calculation: container=${containerWidth}x${containerHeight}, image=${currentMapWidth}x${currentMapHeight}, fitZoom=${fitZoom.toFixed(2)}, minZoom=${calculatedMinZoom}`);
            
            mapInstance = L.map('map', {
                crs: L.CRS.Simple,
                minZoom: calculatedMinZoom,
                maxZoom: 5,  // Allow much more zoom in for detail work
                zoomSnap: 0.25,
                zoomDelta: 0.5,
                attributionControl: false,
                maxBounds: imageBounds,  // Restrict panning to image bounds
                maxBoundsViscosity: 1.0  // Hard boundary (no elastic effect)
            });
            
            currentMapLayer = L.imageOverlay(cfg.file, imageBounds).addTo(mapInstance);
            
            // Fit bounds and set view to show full map centered
            mapInstance.fitBounds(imageBounds);
            
            // Ensure the map stays within bounds after any zoom
            mapInstance.setMaxBounds(imageBounds);
            
            questMarkersLayer = L.layerGroup().addTo(mapInstance);
            
            // Draw quest markers only for selected quests
            await drawQuestMarkers(mapName, currentMapWidth, currentMapHeight, questNames, selectedQuests);
            
            setTimeout(() => mapInstance.invalidateSize(), 200);
        }
        
        function resetMapView() {
            if (mapInstance && imageBounds) {
                mapInstance.fitBounds(imageBounds, { animate: true });
            }
        }
        
        // Recalculate map bounds on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (mapInstance && imageBounds) {
                    // Recalculate minZoom based on new container size
                    const mapContainer = document.getElementById('map');
                    const containerWidth = mapContainer.clientWidth;
                    const containerHeight = mapContainer.clientHeight;
                    
                    const zoomX = Math.log2(containerWidth / currentMapWidth);
                    const zoomY = Math.log2(containerHeight / currentMapHeight);
                    const fitZoom = Math.min(zoomX, zoomY);
                    const calculatedMinZoom = Math.floor(fitZoom * 4) / 4;
                    
                    mapInstance.setMinZoom(calculatedMinZoom);
                    mapInstance.invalidateSize();
                }
            }, 250);
        });
        
        async function onMapChange() {
            const mapName = document.getElementById('mapSelect').value;
            // Redraw with currently selected quests (if any)
            await initMap(mapName, selectedQuestNamesForMarkers, selectedQuestsForMarkers);
            // Also render spawn markers
            await renderOverlayMarkers();
        }

        // ============================================================================
        // RAID PLANNING
        // ============================================================================
        
        async function planRaid() {
            const resultBox = document.getElementById('planning-result');
            const mapSelect = document.getElementById('mapSelect');
            const savedQuests = getSavedQuests();
            
            if (savedQuests.size === 0) {
                alert('No tasks selected. Please select at least one task.');
                return;
            }
            
            const selectedQuests = allQuestsGlobal.filter(q => savedQuests.has(q.id));
            
            // Store selected quest names and full objects for markers
            selectedQuestNamesForMarkers = selectedQuests.map(q => q.name);
            selectedQuestsForMarkers = selectedQuests;
            
            // Analyze which maps are needed for selected quests
            const mapAnalysis = analyzeQuestMaps(selectedQuests);
            
            // Setup multi-map tabs if multiple maps needed
            if (mapAnalysis.maps.length > 1) {
                setupMultiMapTabs(mapAnalysis.maps, mapAnalysis.questsByMap);
            } else {
                resetMultiMapMode();
            }
            
            resultBox.style.display = 'block';
            resultBox.scrollIntoView({ behavior: 'smooth' });
            
            // Determine which map to show
            let mapName;
            if (multiMapMode && mapAnalysis.maps.length > 0) {
                mapName = mapAnalysis.maps[0]; // First required map
            } else {
                mapName = mapSelect.value;
            }
            
            // Initialize map with selected quest markers
            await initMap(mapName, selectedQuestNamesForMarkers, selectedQuestsForMarkers);
            
            // Render spawn markers if any layers are enabled
            await renderOverlayMarkers();
            
            // Collect items provided by quest starts
            const providedItemIds = new Set();
            selectedQuests.forEach(q => {
                if (q.startRewards?.items) {
                    q.startRewards.items.forEach(r => {
                        if (r.item?.id) providedItemIds.add(r.item.id);
                    });
                }
            });
            
            // Collect required keys, items, objectives, unlocks
            const neededKeys = new Map();
            const itemsMap = new Map();
            const objectives = [];
            const unlocks = [];
            
            // NEW: Quest Item Tracker - collect items grouped by quest with more details
            const questItemsData = [];
            
            selectedQuests.forEach(q => {
                if (q.neededKeys) {
                    q.neededKeys.forEach(g => {
                        if (g.keys?.length > 0) {
                            neededKeys.set(g.keys[0].name, g.keys[0]);
                        }
                    });
                }
                
                if (q.objectives) {
                    q.objectives.forEach(o => {
                        objectives.push({ quest: q.name, desc: o.description });
                        
                        const item = o.item || o.markerItem;
                        if (item) {
                            const isProvided = providedItemIds.has(item.id);
                            if (!itemsMap.has(item.id)) {
                                itemsMap.set(item.id, { name: item.name, icon: item.iconLink, count: 0, isProvided });
                            }
                            itemsMap.get(item.id).count += (o.count || 1);
                            if (isProvided) itemsMap.get(item.id).isProvided = true;
                        }
                    });
                }
                
                // Collect and GROUP items for this quest (combine same items)
                const questItemsMap = new Map();
                if (q.objectives) {
                    q.objectives.forEach(o => {
                        const item = o.item || o.markerItem;
                        if (item) {
                            const isProvided = providedItemIds.has(item.id);
                            const itemCount = o.count || 1;
                            
                            if (questItemsMap.has(item.id)) {
                                // Add to existing item count
                                questItemsMap.get(item.id).count += itemCount;
                            } else {
                                // New item entry
                                questItemsMap.set(item.id, {
                                    id: item.id,
                                    name: item.name,
                                    shortName: item.shortName || item.name,
                                    icon: item.iconLink,
                                    count: itemCount,
                                    type: o.type || 'giveItem',
                                    // FIR only if EXPLICITLY true in API - markers etc. are NOT FIR
                                    foundInRaid: o.foundInRaid === true,
                                    isProvided: isProvided,
                                    description: o.description
                                });
                            }
                        }
                    });
                }
                
                const questItems = Array.from(questItemsMap.values());
                
                if (questItems.length > 0) {
                    questItemsData.push({
                        questId: q.id,
                        questName: q.name,
                        trader: q.trader?.name || 'Unknown',
                        items: questItems
                    });
                }
                
                if (q.derived_unlocks) {
                    q.derived_unlocks.forEach(u => unlocks.push({ from: q.name, ...u }));
                }
            });
            
            // Render results
            document.getElementById('required-keys').innerHTML = neededKeys.size > 0 
                ? Array.from(neededKeys.values()).map(k => `
                    <div class="item-box">
                        ${k.iconLink ? `<img src="${k.iconLink}">` : ''}
                        <span>${k.shortName || k.name}</span>
                    </div>
                `).join('') 
                : '<span class="text-sub p-2">None required.</span>';
            
            // NEW: Render Quest Item Tracker instead of simple required-items
            renderQuestItemTracker(questItemsData);
            
            // Group objectives by quest for better readability
            const objectivesByQuest = {};
            selectedQuests.forEach(q => {
                if (q.objectives) {
                    objectivesByQuest[q.name] = q.objectives.map(o => o.description);
                }
            });
            
            let objectivesHtml = '';
            Object.entries(objectivesByQuest).forEach(([questName, objs], index) => {
                const color = QUEST_COLORS[index % QUEST_COLORS.length];
                objectivesHtml += `
                    <div class="quest-objectives-group">
                        <div class="quest-objectives-header">
                            <div class="legend-color" style="background: ${color.fill}; border-color: ${color.border}; width: 14px; height: 14px;"></div>
                            <span>${questName}</span>
                        </div>
                        <ul class="quest-objectives-list">
                            ${objs.map((desc, i) => `<li><span class="obj-index">${i + 1}.</span> ${desc}</li>`).join('')}
                        </ul>
                    </div>
                `;
            });
            document.getElementById('mission-steps').innerHTML = objectivesHtml;
            
            document.getElementById('progression-list').innerHTML = unlocks.length > 0 
                ? unlocks.map(u => `
                    <div class="unlock-card">
                        <div style="font-size: 0.8rem; color: var(--text-sub);">From ${u.from}:</div>
                        <div class="fw-bold">
                            <a href="${getWikiUrl(u.name)}" target="_blank" rel="noopener noreferrer" class="unlock-link">${u.name}</a>
                        </div>
                        <div class="small text-sub">${u.map} | ${u.trader}</div>
                    </div>
                `).join('') 
                : '<div class="text-sub p-2">No immediate unlocks.</div>';
        }
        
        // ============================================================================
        // RAID PLAN SHARING
        // ============================================================================
        
        function showRaidExportModal() {
            const savedQuests = getSavedQuests();
            
            if (savedQuests.size === 0) {
                alert('No tasks selected. Select some tasks first, then click "Plan Raid" before sharing.');
                return;
            }
            
            const selectedQuests = allQuestsGlobal.filter(q => savedQuests.has(q.id));
            const currentMap = document.getElementById('mapSelect')?.value || 'customs';
            
            // Build raid plan data
            const raidPlan = {
                v: 1, // version
                m: currentMap,
                q: selectedQuests.map(q => ({ id: q.id, n: q.name }))
            };
            
            // Encode as Base64
            const json = JSON.stringify(raidPlan);
            const code = btoa(unescape(encodeURIComponent(json)));
            
            // Build summary
            const mapNames = {
                customs: 'Customs', factory: 'Factory', groundzero: 'Ground Zero',
                interchange: 'Interchange', labs: 'The Lab', lighthouse: 'Lighthouse',
                reserve: 'Reserve', shoreline: 'Shoreline', streets: 'Streets of Tarkov', woods: 'Woods'
            };
            
            const summary = `
                <div style="color: var(--eft-gold); margin-bottom: 8px;">üó∫Ô∏è ${mapNames[currentMap] || currentMap}</div>
                <div style="color: var(--text-beige);">${selectedQuests.length} Tasks:</div>
                <ul style="margin: 5px 0 0 20px; padding: 0; color: var(--text-sub); font-size: 0.8rem;">
                    ${selectedQuests.slice(0, 5).map(q => `<li>${q.name}</li>`).join('')}
                    ${selectedQuests.length > 5 ? `<li>... and ${selectedQuests.length - 5} more</li>` : ''}
                </ul>
            `;
            
            // Build Discord text
            const neededKeys = new Set();
            const neededItems = new Map();
            
            selectedQuests.forEach(q => {
                // Collect keys
                if (q.neededKeys) {
                    q.neededKeys.forEach(g => {
                        if (g.keys?.length > 0) {
                            neededKeys.add(g.keys[0].name);
                        }
                    });
                }
                // Collect items from objectives
                if (q.objectives) {
                    q.objectives.forEach(o => {
                        const item = o.item || o.markerItem;
                        if (item) {
                            const count = o.count || 1;
                            if (neededItems.has(item.name)) {
                                neededItems.set(item.name, neededItems.get(item.name) + count);
                            } else {
                                neededItems.set(item.name, count);
                            }
                        }
                    });
                }
            });
            
            let discordText = `üéØ **${mapNames[currentMap] || currentMap} Raid Plan**\n`;
            discordText += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
            discordText += `üìã **${selectedQuests.length} Tasks:**\n`;
            selectedQuests.forEach(q => {
                discordText += `‚Ä¢ ${q.name}\n`;
            });
            
            if (neededKeys.size > 0) {
                discordText += `\nüîë **Keys Needed:**\n`;
                [...neededKeys].forEach(k => {
                    discordText += `‚Ä¢ ${k}\n`;
                });
            }
            
            if (neededItems.size > 0) {
                discordText += `\nüì¶ **Items to Bring:**\n`;
                [...neededItems.entries()].forEach(([name, count]) => {
                    discordText += `‚Ä¢ ${count}x ${name}\n`;
                });
            }
            
            discordText += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
            discordText += `üì• Import: \`${code.substring(0, 30)}...\``;
            
            document.getElementById('raidShareSummary').innerHTML = summary;
            document.getElementById('raidShareCode').value = code;
            document.getElementById('raidShareText').value = discordText;
            document.getElementById('raidShareModal').style.display = 'flex';
        }
        
        function hideRaidShareModal() {
            document.getElementById('raidShareModal').style.display = 'none';
        }
        
        function copyRaidCode() {
            const input = document.getElementById('raidShareCode');
            input.select();
            document.execCommand('copy');
            navigator.clipboard.writeText(input.value).catch(() => {});
            
            // Visual feedback
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '‚úì Copied!';
            btn.style.background = 'var(--eft-green)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 2000);
        }
        
        function copyRaidText() {
            const textarea = document.getElementById('raidShareText');
            textarea.select();
            document.execCommand('copy');
            navigator.clipboard.writeText(textarea.value).catch(() => {});
            
            // Visual feedback
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '‚úì Copied to clipboard!';
            btn.style.background = 'var(--eft-green)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 2000);
        }
        
        function showRaidImportModal() {
            document.getElementById('raidImportCode').value = '';
            document.getElementById('raidImportPreview').style.display = 'none';
            document.getElementById('raidImportModal').style.display = 'flex';
            document.getElementById('raidImportCode').focus();
            
            // Add input listener for preview
            document.getElementById('raidImportCode').oninput = previewRaidImport;
        }
        
        function hideRaidImportModal() {
            document.getElementById('raidImportModal').style.display = 'none';
        }
        
        function previewRaidImport() {
            const code = document.getElementById('raidImportCode').value.trim();
            const preview = document.getElementById('raidImportPreview');
            
            if (!code) {
                preview.style.display = 'none';
                return;
            }
            
            try {
                const json = decodeURIComponent(escape(atob(code)));
                const raidPlan = JSON.parse(json);
                
                if (!raidPlan.q || !Array.isArray(raidPlan.q)) {
                    throw new Error('Invalid raid plan format');
                }
                
                const mapNames = {
                    customs: 'Customs', factory: 'Factory', groundzero: 'Ground Zero',
                    interchange: 'Interchange', labs: 'The Lab', lighthouse: 'Lighthouse',
                    reserve: 'Reserve', shoreline: 'Shoreline', streets: 'Streets of Tarkov', woods: 'Woods'
                };
                
                preview.innerHTML = `
                    <div style="color: var(--eft-green); margin-bottom: 5px;">‚úì Valid raid plan</div>
                    <div style="color: var(--eft-gold);">üó∫Ô∏è ${mapNames[raidPlan.m] || raidPlan.m || 'Unknown'}</div>
                    <div style="color: var(--text-beige);">${raidPlan.q.length} Tasks</div>
                `;
                preview.style.display = 'block';
                
            } catch (e) {
                preview.innerHTML = `<div style="color: var(--eft-red);">‚ö† Invalid code</div>`;
                preview.style.display = 'block';
            }
        }
        
        async function importRaidPlan() {
            const code = document.getElementById('raidImportCode').value.trim();
            
            if (!code) {
                alert('Please paste a raid code first.');
                return;
            }
            
            try {
                const json = decodeURIComponent(escape(atob(code)));
                const raidPlan = JSON.parse(json);
                
                if (!raidPlan.q || !Array.isArray(raidPlan.q)) {
                    throw new Error('Invalid raid plan format');
                }
                
                // Clear current selection
                localStorage.setItem(STORAGE_KEY_QUESTS, JSON.stringify([]));
                
                // Select the imported quests
                const questIds = raidPlan.q.map(q => q.id);
                localStorage.setItem(STORAGE_KEY_QUESTS, JSON.stringify(questIds));
                
                // Set map if provided
                if (raidPlan.m) {
                    const mapSelect = document.getElementById('mapSelect');
                    if (mapSelect) {
                        mapSelect.value = raidPlan.m;
                    }
                }
                
                // Re-render quest list with new selection
                renderQuestList();
                updateSelectedQuestCount();
                
                // Close modal
                hideRaidImportModal();
                
                // Auto-plan the raid
                await planRaid();
                
                // Show success message
                const questNames = raidPlan.q.map(q => q.n).slice(0, 3).join(', ');
                const moreText = raidPlan.q.length > 3 ? ` +${raidPlan.q.length - 3} more` : '';
                alert(`Raid plan loaded!\n\nTasks: ${questNames}${moreText}`);
                
            } catch (e) {
                alert('Error importing raid plan: ' + e.message);
            }
        }

        // ============================================================================
        // AMMO MANAGEMENT
        // ============================================================================
        
        function loadSavedAmmo() {
            const saved = localStorage.getItem(STORAGE_KEY_AMMO);
            ownedAmmo = saved ? new Set(JSON.parse(saved)) : new Set();
        }
        
        function saveOwnedAmmo() {
            localStorage.setItem(STORAGE_KEY_AMMO, JSON.stringify([...ownedAmmo]));
        }
        
        async function loadAmmoData() {
            const loading = document.getElementById('ammo-loading');
            const content = document.getElementById('ammo-content');
            const error = document.getElementById('ammo-error');
            const btn = document.getElementById('btn-load-ammo');
            
            content.classList.add('d-none');
            loading.classList.remove('d-none');
            error.classList.add('d-none');
            
            try {
                const response = await fetch(API_BASE + '/ammo');
                if (!response.ok) throw new Error('Server error: ' + response.status);
                
                allAmmoData = await response.json();
                
                const caliberSelect = document.getElementById('caliberFilter');
                caliberSelect.innerHTML = '<option value="ALL">All Calibers</option>';
                allAmmoData.calibers.forEach(cal => {
                    caliberSelect.innerHTML += `<option value="${cal}">${cal}</option>`;
                });
                
                document.getElementById('ammo-count').textContent = allAmmoData.all.length + ' types';
                renderAmmoList();
                
                content.classList.remove('d-none');
                btn.textContent = 'üîÑ Refresh Data';
                btn.style.display = 'block';
                
            } catch (err) {
                error.innerHTML = `<strong>ERROR:</strong> ${err.message}`;
                error.classList.remove('d-none');
                btn.textContent = 'üîÑ Retry';
                btn.style.display = 'block';
            } finally {
                loading.classList.add('d-none');
                btn.disabled = false;
            }
        }
        
        function filterAmmoByCaliber() { renderAmmoList(); }
        function filterAmmoBySearch() { renderAmmoList(); }
        
        function updateTierThreshold() {
            const value = parseInt(document.getElementById('tierSlider').value);
            currentTierThreshold = TIER_NAMES[value];
            document.getElementById('tierDisplay').textContent = 'Keep ' + currentTierThreshold + '-Tier+';
            updateAmmoAnalysis();
        }
        
        function renderAmmoList() {
            if (!allAmmoData) return;
            
            const container = document.getElementById('ammo-list');
            const caliberFilter = document.getElementById('caliberFilter').value;
            const searchFilter = document.getElementById('ammoSearch').value.toLowerCase();
            
            let html = '';
            
            if (caliberFilter === 'ALL') {
                for (const [caliber, ammos] of Object.entries(allAmmoData.byCaliber)) {
                    const filtered = ammos.filter(a => 
                        a.name.toLowerCase().includes(searchFilter) || 
                        a.shortName.toLowerCase().includes(searchFilter)
                    );
                    if (filtered.length > 0) {
                        html += renderCaliberGroup(caliber, filtered);
                    }
                }
            } else {
                const ammos = allAmmoData.byCaliber[caliberFilter] || [];
                const filtered = ammos.filter(a => 
                    a.name.toLowerCase().includes(searchFilter) || 
                    a.shortName.toLowerCase().includes(searchFilter)
                );
                html += renderCaliberGroup(caliberFilter, filtered);
            }
            
            container.innerHTML = html;
            updateAmmoAnalysis();
        }
        
        function renderCaliberGroup(caliber, ammos) {
            let html = `
                <div class="caliber-group">
                    <div class="caliber-header">${caliber} <span class="text-sub small">(${ammos.length})</span></div>
            `;
            
            ammos.forEach(a => {
                const isOwned = ownedAmmo.has(a.id);
                const tierInfo = getAmmoTier(a);
                const displayTier = tierInfo.tier;
                const tierSource = tierInfo.source;
                const isOverridden = tierOverrides.ammo[a.id] !== undefined;
                const sourceClass = tierSource.includes('+') ? 'source-both' : 'source-pen';
                const isBulkSelected = bulkSelected.ammo.has(a.id);
                
                html += `
                    <div class="ammo-card ${isOwned ? 'owned' : ''} ${isOverridden ? 'overridden' : ''} ${isBulkSelected ? 'bulk-selected' : ''}" 
                         data-id="${a.id}"
                         onclick="${bulkMode.ammo ? `toggleBulkItem('ammo', '${a.id}', event)` : `toggleAmmoOwned('${a.id}')`}">
                        <input type="checkbox" class="item-checkbox" ${isBulkSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleBulkItem('ammo', '${a.id}', event)">
                        <span class="tier-badge tier-${displayTier}">${displayTier}</span>
                        ${a.iconLink ? `<img src="${a.iconLink}">` : ''}
                        <div class="flex-grow-1">
                            <div class="fw-bold" style="color: var(--text-main);">${a.shortName}</div>
                            <div class="ammo-stats">
                                <span class="stat-dmg">DMG ${a.damage}</span>
                                <span class="stat-pen">PEN ${a.penetration}</span>
                                ${a.sellPrice > 0 ? `<span class="stat-price">${a.sellPrice.toLocaleString()} RUB</span>` : ''}
                            </div>
                        </div>
                        <span class="tier-source ${sourceClass}">${tierSource}</span>
                        ${isOwned ? '<span class="badge-tarkov badge-active">OWNED</span>' : ''}
                        <select class="tier-select-mini" onclick="event.stopPropagation()" onchange="setTierOverride('${a.id}', this.value)">
                            <option value="" ${!isOverridden ? 'selected' : ''}>Auto</option>
                            ${TIER_NAMES.map(t => `<option value="${t}" ${tierOverrides.ammo[a.id] === t ? 'selected' : ''}>${t}</option>`).join('')}
                        </select>
                    </div>
                `;
            });
            
            return html + '</div>';
        }
        
        function getAmmoTier(ammo) {
            return getItemTier('ammo', ammo.id, {
                pen: ammo.penetration,
                dmg: ammo.damage,
                armorDmg: ammo.armorDamage || 0,
                fragChance: (ammo.fragmentationChance || 0) * 100,
                initialSpeed: ammo.initialSpeed || 0,
                projCount: ammo.projectileCount || 1,
                accMod: (ammo.accuracyModifier || 0) * 100,
                recoilMod: (ammo.recoilModifier || 0) * 100,
                lightBleed: (ammo.lightBleedModifier || 0) * 100,
                heavyBleed: (ammo.heavyBleedModifier || 0) * 100
            });
        }
        
        function setTierOverride(ammoId, tier) {
            setItemTierOverride('ammo', ammoId, tier);
            renderAmmoList();
        }
        
        // ============================================================================
        // GENERIC TIER SYSTEM
        // ============================================================================
        
        function getItemTier(category, itemId, statValues, itemType = null) {
            // Check for manual override first
            if (tierOverrides[category][itemId]) {
                return { tier: tierOverrides[category][itemId], source: 'CUSTOM' };
            }
            
            const categoryStats = STAT_DEFINITIONS[category];
            const categoryThresholds = tierThresholds[category];
            
            // Use item-type-specific stats if itemType provided, otherwise global activeStats
            let statsToCheck;
            if (itemType && ITEM_TYPE_STATS[category]) {
                // Get the applicable stats for this item type
                const applicable = getApplicableStats(category, itemType);
                // Intersect with user's active stats selection
                statsToCheck = activeStats[category].filter(s => applicable.includes(s));
                // If no intersection, use the default active stats for this type
                if (statsToCheck.length === 0) {
                    statsToCheck = getDefaultActiveStats(category, itemType);
                }
            } else {
                statsToCheck = activeStats[category];
            }
            
            // Check each tier level
            for (const tier of ['S', 'A', 'B', 'C', 'D']) {
                const metStats = [];
                
                for (const statKey of statsToCheck) {
                    const statDef = categoryStats[statKey];
                    const threshold = categoryThresholds[statKey]?.[tier];
                    const value = statValues[statKey];
                    
                    if (threshold === undefined || value === undefined) continue;
                    
                    let met = false;
                    if (statDef.direction === 'higher') {
                        met = value >= threshold;
                    } else {
                        met = value <= threshold;
                    }
                    
                    if (met) {
                        metStats.push(statDef.label.split(' ')[0].toUpperCase().substring(0, 4));
                    }
                }
                
                if (metStats.length > 0) {
                    const source = metStats.length > 2 ? metStats.slice(0, 2).join('+') + '+' : metStats.join('+');
                    return { tier, source };
                }
            }
            
            return { tier: 'F', source: '-' };
        }
        
        function setItemTierOverride(category, itemId, tier) {
            if (tier === '') {
                delete tierOverrides[category][itemId];
            } else {
                tierOverrides[category][itemId] = tier;
            }
            saveTierData();
        }
        
        function toggleStatActive(category, statKey) {
            const idx = activeStats[category].indexOf(statKey);
            if (idx >= 0) {
                activeStats[category].splice(idx, 1);
            } else {
                activeStats[category].push(statKey);
            }
            saveTierData();
            renderStatCheckboxes(category);
            renderCategoryList(category);
        }
        
        function updateThresholdValue(category, statKey, tier, value) {
            tierThresholds[category][statKey][tier] = parseFloat(value) || 0;
            saveTierData();
            renderCategoryList(category);
        }
        
        function renderStatCheckboxes(category) {
            const container = document.getElementById(`${category}StatCheckboxes`);
            const select = document.getElementById(`${category}StatSelect`);
            const stats = STAT_DEFINITIONS[category];
            
            // Get the current filter for this category to determine applicable stats
            let currentFilterType = null;
            if (category === 'gear') {
                const filterValue = document.getElementById('gearTypeFilter')?.value;
                if (filterValue && filterValue !== 'ALL') {
                    // Map filter value to ITEM_TYPE_STATS key
                    const filterMap = { 'armor': 'armor', 'helmet': 'helmet', 'rig': 'rig', 'backpack': 'backpack', 'headphones': 'headphones' };
                    currentFilterType = filterMap[filterValue];
                }
            } else if (category === 'attachments') {
                const filterValue = document.getElementById('attachmentTypeFilter')?.value;
                if (filterValue && filterValue !== 'ALL') {
                    currentFilterType = filterValue; // Already matches ITEM_TYPE_STATS keys
                }
            }
            
            // Get applicable stats for the current filter
            const applicableStats = currentFilterType ? getApplicableStats(category, currentFilterType) : null;
            
            // Checkboxes - grey out non-applicable stats
            container.innerHTML = Object.entries(stats).map(([key, def]) => {
                const isActive = activeStats[category].includes(key);
                const isApplicable = !applicableStats || applicableStats.includes(key);
                const disabledClass = !isApplicable ? 'disabled' : '';
                const disabledAttr = !isApplicable ? 'style="opacity: 0.4; pointer-events: none;"' : '';
                
                return `<div class="stat-checkbox ${isActive ? 'active' : ''} ${disabledClass}" 
                    ${isApplicable ? `onclick="toggleStatActive('${category}', '${key}')"` : ''}
                    ${disabledAttr}
                    title="${!isApplicable ? 'Not applicable for selected type' : def.label}">
                    <input type="checkbox" ${isActive ? 'checked' : ''} ${!isApplicable ? 'disabled' : ''}>
                    ${def.label}
                </div>`;
            }).join('');
            
            // Dropdown - also filter to applicable stats
            select.innerHTML = Object.entries(stats).map(([key, def]) => {
                const isApplicable = !applicableStats || applicableStats.includes(key);
                return `<option value="${key}" ${!isApplicable ? 'disabled style="color: #666;"' : ''}>${def.label}${!isApplicable ? ' (N/A)' : ''}</option>`;
            }).join('');
            
            renderThresholdEditor(category);
        }
        
        function renderThresholdEditor(category) {
            const select = document.getElementById(`${category}StatSelect`);
            const grid = document.getElementById(`${category}ThresholdGrid`);
            const directionEl = document.getElementById(`${category}StatDirection`);
            
            const statKey = select.value;
            const statDef = STAT_DEFINITIONS[category][statKey];
            const thresholds = tierThresholds[category][statKey];
            
            if (!statDef || !thresholds) return;
            
            directionEl.textContent = statDef.direction === 'higher' ? '‚Üí higher = better' : '‚Üì lower = better';
            directionEl.className = `threshold-direction ${statDef.direction}`;
            
            grid.innerHTML = ['S', 'A', 'B', 'C', 'D'].map(tier => `
                <div class="threshold-item">
                    <span class="tier-badge tier-${tier}">${tier}</span>
                    <input type="number" value="${thresholds[tier]}" step="any"
                        onchange="updateThresholdValue('${category}', '${statKey}', '${tier}', this.value)">
                </div>
            `).join('');
        }
        
        function resetCategoryConfig(category) {
            tierThresholds[category] = buildDefaultThresholds(category);
            activeStats[category] = [...DEFAULT_ACTIVE_STATS[category]];
            saveTierData();
            renderStatCheckboxes(category);
            renderCategoryList(category);
        }
        
        function clearCategoryOverrides(category) {
            tierOverrides[category] = {};
            saveTierData();
            renderCategoryList(category);
        }
        
        function updateKeepThreshold(category) {
            const val = parseInt(document.getElementById(`${category}TierSlider`).value);
            keepTierThreshold[category] = TIER_ORDER[val];
            document.getElementById(`${category}TierDisplay`).textContent = `Keep ${keepTierThreshold[category]}-Tier+`;
            updateCategoryAnalysis(category);
        }
        
        function renderCategoryList(category) {
            switch(category) {
                case 'ammo': renderAmmoList(); break;
                case 'weapons': renderWeaponsList(); break;
                case 'gear': renderGearList(); break;
                case 'attachments': renderAttachmentsList(); break;
            }
        }
        
        function updateCategoryAnalysis(category) {
            switch(category) {
                case 'ammo': updateAmmoAnalysis(); break;
                case 'weapons': updateWeaponAnalysis(); break;
                case 'gear': updateGearAnalysis(); break;
                case 'attachments': updateAttachmentAnalysis(); break;
            }
        }
        
        // Save/Load tier data
        function saveTierData() {
            localStorage.setItem(STORAGE_KEY_TIER_THRESHOLDS, JSON.stringify(tierThresholds));
            localStorage.setItem(STORAGE_KEY_TIER_OVERRIDES, JSON.stringify(tierOverrides));
            localStorage.setItem(STORAGE_KEY_ACTIVE_STATS, JSON.stringify(activeStats));
        }
        
        function loadTierData() {
            const savedThresholds = localStorage.getItem(STORAGE_KEY_TIER_THRESHOLDS);
            const savedOverrides = localStorage.getItem(STORAGE_KEY_TIER_OVERRIDES);
            const savedActive = localStorage.getItem(STORAGE_KEY_ACTIVE_STATS);
            
            if (savedThresholds) {
                const parsed = JSON.parse(savedThresholds);
                // Merge with defaults to handle new stats
                for (const cat of ['ammo', 'weapons', 'gear', 'attachments']) {
                    if (parsed[cat]) {
                        tierThresholds[cat] = { ...buildDefaultThresholds(cat), ...parsed[cat] };
                    }
                }
            }
            if (savedOverrides) tierOverrides = JSON.parse(savedOverrides);
            if (savedActive) {
                const parsed = JSON.parse(savedActive);
                for (const cat of ['ammo', 'weapons', 'gear', 'attachments']) {
                    if (parsed[cat]) activeStats[cat] = parsed[cat];
                }
            }
        }
        
        // ============================================================================
        // EXPORT/IMPORT CONFIGURATION
        // ============================================================================
        
        function exportConfig() {
            // Show export modal with options
            const config = {
                version: '1.1-beta',
                exportDate: new Date().toISOString(),
                tierThresholds: tierThresholds,
                activeStats: activeStats,
                tierOverrides: tierOverrides,
                ownedItems: {
                    ammo: [...ownedAmmo],
                    weapons: [...ownedWeapons],
                    gear: [...ownedGear],
                    attachments: [...ownedAttachments]
                },
                collectedQuestItems: collectedQuestItems,
                completedQuests: [...getCompletedQuests()],
                hideoutProgress: hideoutProgress
            };
            
            const json = JSON.stringify(config);
            const base64 = btoa(unescape(encodeURIComponent(json)));
            
            // Store for modal use
            window._exportData = { json, base64, config };
            
            document.getElementById('exportModal').style.display = 'flex';
            document.getElementById('exportCode').value = base64;
        }
        
        function downloadExportFile() {
            if (!window._exportData) return;
            
            const json = JSON.stringify(window._exportData.config, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `tarkov-planner-config-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            hideExportModal();
        }
        
        function copyExportCode() {
            const textarea = document.getElementById('exportCode');
            textarea.select();
            document.execCommand('copy');
            
            // Also try modern API
            navigator.clipboard.writeText(textarea.value).catch(() => {});
            
            // Visual feedback
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '‚úì Copied!';
            btn.style.background = 'var(--eft-green)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 2000);
        }
        
        function showExportModal() {
            exportConfig();
        }
        
        function hideExportModal() {
            document.getElementById('exportModal').style.display = 'none';
            window._exportData = null;
        }
        
        function showImportModal() {
            document.getElementById('importModal').style.display = 'flex';
            document.getElementById('importTextarea').value = '';
        }
        
        function hideImportModal() {
            document.getElementById('importModal').style.display = 'none';
        }
        
        function importFromText() {
            const text = document.getElementById('importTextarea').value.trim();
            if (!text) {
                alert('Please paste configuration JSON first.');
                return;
            }
            applyImportedConfig(text);
        }
        
        function importFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                applyImportedConfig(e.target.result);
            };
            reader.readAsText(file);
        }
        
        function applyImportedConfig(input) {
            try {
                let jsonString = input;
                
                // Check if input is Base64 encoded (no whitespace, no braces at start)
                if (!input.startsWith('{') && !input.includes(' ') && !input.includes('\n')) {
                    try {
                        jsonString = decodeURIComponent(escape(atob(input)));
                    } catch (e) {
                        // Not valid Base64, treat as JSON
                    }
                }
                
                const config = JSON.parse(jsonString);
                
                // Validate basic structure
                if (!config.tierThresholds && !config.activeStats && !config.tierOverrides && !config.ownedItems) {
                    throw new Error('Invalid configuration format');
                }
                
                // Apply tier thresholds
                if (config.tierThresholds) {
                    for (const cat of ['ammo', 'weapons', 'gear', 'attachments']) {
                        if (config.tierThresholds[cat]) {
                            tierThresholds[cat] = { ...buildDefaultThresholds(cat), ...config.tierThresholds[cat] };
                        }
                    }
                }
                
                // Apply active stats
                if (config.activeStats) {
                    for (const cat of ['ammo', 'weapons', 'gear', 'attachments']) {
                        if (config.activeStats[cat]) {
                            activeStats[cat] = config.activeStats[cat];
                        }
                    }
                }
                
                // Apply tier overrides
                if (config.tierOverrides) {
                    for (const cat of ['ammo', 'weapons', 'gear', 'attachments']) {
                        if (config.tierOverrides[cat]) {
                            tierOverrides[cat] = config.tierOverrides[cat];
                        }
                    }
                }
                
                // Apply owned items
                if (config.ownedItems) {
                    if (config.ownedItems.ammo) {
                        ownedAmmo = new Set(config.ownedItems.ammo);
                        saveOwnedAmmo();
                    }
                    if (config.ownedItems.weapons) {
                        ownedWeapons = new Set(config.ownedItems.weapons);
                        saveOwnedWeapons();
                    }
                    if (config.ownedItems.gear) {
                        ownedGear = new Set(config.ownedItems.gear);
                        saveOwnedGear();
                    }
                    if (config.ownedItems.attachments) {
                        ownedAttachments = new Set(config.ownedItems.attachments);
                        saveOwnedAttachments();
                    }
                }
                
                // Apply collected quest items
                if (config.collectedQuestItems) {
                    collectedQuestItems = config.collectedQuestItems;
                    saveCollectedQuestItems();
                }
                
                // Apply completed quests
                if (config.completedQuests) {
                    const completed = new Set(config.completedQuests);
                    localStorage.setItem(STORAGE_KEY_COMPLETED, JSON.stringify([...completed]));
                    // Re-render quest list if loaded
                    if (allQuestsGlobal && allQuestsGlobal.length > 0) {
                        renderQuestList();
                    }
                }
                
                // Apply hideout progress
                if (config.hideoutProgress) {
                    hideoutProgress = config.hideoutProgress;
                    saveHideoutProgress();
                    // Re-render hideout list if loaded
                    if (hideoutDataLoaded) {
                        renderHideoutList();
                        updateHideoutStats();
                    }
                }
                
                // Save and refresh UI
                saveTierData();
                initTierConfigUI();
                
                // Refresh lists if data is loaded
                if (allAmmoData) renderAmmoList();
                if (allWeaponsData) renderWeaponsList();
                if (allGearData) renderGearList();
                if (allAttachmentsData) renderAttachmentsList();
                
                hideImportModal();
                alert(`Configuration imported successfully!\nVersion: ${config.version || 'unknown'}\nExport date: ${config.exportDate || 'unknown'}`);
                
            } catch (e) {
                alert('Error importing configuration: ' + e.message);
            }
        }
        
        function initTierConfigUI() {
            for (const category of ['ammo', 'weapons', 'gear', 'attachments']) {
                renderStatCheckboxes(category);
            }
        }
        
        function toggleAmmoOwned(id) {
            ownedAmmo.has(id) ? ownedAmmo.delete(id) : ownedAmmo.add(id);
            saveOwnedAmmo();
            renderAmmoList();
            updateDashboard();
        }
        
        function updateAmmoAnalysis() {
            if (!allAmmoData) return;
            
            const keepList = document.getElementById('ammo-keep-list');
            const sellList = document.getElementById('ammo-sell-list');
            const keepCount = document.getElementById('ammo-keep-count');
            const sellCount = document.getElementById('ammo-sell-count');
            const totalValue = document.getElementById('ammo-total-sell-value');
            
            const tierIndex = TIER_ORDER.indexOf(keepTierThreshold.ammo);
            const keepTiers = TIER_ORDER.slice(0, tierIndex + 1);
            
            const owned = allAmmoData.all.filter(a => ownedAmmo.has(a.id));
            const keep = owned.filter(a => keepTiers.includes(getAmmoTier(a).tier));
            const sell = owned.filter(a => !keepTiers.includes(getAmmoTier(a).tier));
            
            keepCount.textContent = keep.length;
            sellCount.textContent = sell.length;
            
            keepList.innerHTML = keep.length > 0 
                ? keep.map(a => renderAnalysisItem(a, 'keep', 'ammo')).join('') 
                : '<div class="text-sub p-2 small">No ammo to keep marked.</div>';
            
            sellList.innerHTML = sell.length > 0 
                ? sell.map(a => renderAnalysisItem(a, 'sell', 'ammo')).join('') 
                : '<div class="text-sub p-2 small">No ammo to sell.</div>';
            
            totalValue.textContent = sell.reduce((sum, a) => sum + (a.sellPrice || 0), 0).toLocaleString() + ' RUB';
        }
        
        function renderAnalysisItem(item, type, category) {
            const tierInfo = category === 'ammo' ? getAmmoTier(item) : 
                             category === 'weapons' ? getWeaponTier(item) :
                             category === 'gear' ? getGearTier(item) : getAttachmentTier(item);
            const displayTier = tierInfo.tier;
            const subText = item.caliber || item.gearType || item.attachType || '';
            return `
                <div class="item-box ${type === 'keep' ? 'status-provided' : 'status-acquire'} w-100 mb-1">
                    <span class="tier-badge tier-${displayTier}" style="width:24px;height:24px;line-height:24px;font-size:0.75rem;">${displayTier}</span>
                    ${item.iconLink ? `<img src="${item.iconLink}" style="width:28px;height:28px;">` : ''}
                    <div class="flex-grow-1">
                        <div style="font-size:0.85rem;">${item.shortName}</div>
                        <div style="font-size:0.7rem;color:var(--text-sub);">${subText}</div>
                    </div>
                    ${type === 'sell' && item.sellPrice > 0 ? `<span class="stat-price small">${item.sellPrice.toLocaleString()} RUB</span>` : ''}
                </div>
            `;
        }

        // ============================================================================
        // WEAPONS MANAGER
        // ============================================================================
        
        async function loadWeaponsData() {
            const loading = document.getElementById('weapons-loading');
            const content = document.getElementById('weapons-content');
            const error = document.getElementById('weapons-error');
            const btn = document.getElementById('btn-load-weapons');
            
            loading.classList.remove('d-none');
            content.classList.add('d-none');
            error.classList.add('d-none');
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            try {
                const query = `{
                    items(types: [gun]) {
                        id
                        name
                        shortName
                        iconLink
                        avg24hPrice
                        sellFor { price vendor { name } }
                        types
                        properties {
                            ... on ItemPropertiesWeapon {
                                caliber
                                fireRate
                                ergonomics
                                recoilVertical
                                recoilHorizontal
                                effectiveDistance
                                convergence
                                cameraRecoil
                                deviationCurve
                                deviationMax
                                repairCost
                                sightingRange
                            }
                        }
                    }
                }`;
                
                const response = await fetch('https://api.tarkov.dev/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                
                const data = await response.json();
                
                if (data.errors) throw new Error(data.errors[0].message);
                
                // Process weapons
                const weapons = data.data.items.map(w => {
                    const props = w.properties || {};
                    const bestSell = w.sellFor?.reduce((best, s) => s.price > best.price ? s : best, { price: 0 }) || { price: 0 };
                    return {
                        id: w.id,
                        name: w.name,
                        shortName: w.shortName,
                        iconLink: w.iconLink,
                        caliber: props.caliber || 'Unknown',
                        fireRate: props.fireRate || 0,
                        ergonomics: props.ergonomics || 0,
                        recoilVertical: props.recoilVertical || 0,
                        recoilHorizontal: props.recoilHorizontal || 0,
                        totalRecoil: (props.recoilVertical || 0) + (props.recoilHorizontal || 0),
                        effectiveDistance: props.effectiveDistance || 0,
                        convergence: props.convergence || 0,
                        cameraRecoil: props.cameraRecoil || 0,
                        deviationCurve: props.deviationCurve || 0,
                        deviationMax: props.deviationMax || 0,
                        sightingRange: props.sightingRange || 0,
                        sellPrice: bestSell.price,
                        sellTo: bestSell.vendor?.name || 'Fence',
                        types: w.types || []
                    };
                }).filter(w => w.ergonomics > 0); // Filter out items without weapon stats
                
                // Group by caliber
                const byCaliber = {};
                weapons.forEach(w => {
                    const cal = w.caliber || 'Other';
                    if (!byCaliber[cal]) byCaliber[cal] = [];
                    byCaliber[cal].push(w);
                });
                
                // Sort within each caliber by tier
                Object.values(byCaliber).forEach(arr => {
                    arr.sort((a, b) => {
                        const tierA = TIER_ORDER.indexOf(getWeaponTier(a).tier);
                        const tierB = TIER_ORDER.indexOf(getWeaponTier(b).tier);
                        return tierA - tierB;
                    });
                });
                
                allWeaponsData = { all: weapons, byCaliber };
                
                // Populate type filter
                const typeFilter = document.getElementById('weaponTypeFilter');
                const calibers = Object.keys(byCaliber).sort();
                typeFilter.innerHTML = '<option value="ALL">All Calibers (' + weapons.length + ')</option>' +
                    calibers.map(c => `<option value="${c}">${c} (${byCaliber[c].length})</option>`).join('');
                
                document.getElementById('weapon-count').textContent = weapons.length;
                
                loading.classList.add('d-none');
                content.classList.remove('d-none');
                btn.textContent = 'üîÑ Refresh Data';
                btn.style.display = 'block';
                btn.disabled = false;
                
                loadOwnedWeapons();
                renderWeaponsList();
                
            } catch (err) {
                loading.classList.add('d-none');
                error.classList.remove('d-none');
                error.textContent = 'Error loading weapons: ' + err.message;
                btn.textContent = 'üîÑ Retry';
                btn.style.display = 'block';
                btn.disabled = false;
            }
        }
        
        function renderWeaponsList() {
            if (!allWeaponsData) return;
            
            const container = document.getElementById('weapons-list');
            let html = '';
            
            const calibers = weaponTypeFilter === 'ALL' 
                ? Object.keys(allWeaponsData.byCaliber).sort()
                : [weaponTypeFilter];
            
            calibers.forEach(cal => {
                let weapons = allWeaponsData.byCaliber[cal] || [];
                
                // Apply search filter
                if (weaponSearchQuery) {
                    const q = weaponSearchQuery.toLowerCase();
                    weapons = weapons.filter(w => 
                        w.name.toLowerCase().includes(q) || 
                        w.shortName.toLowerCase().includes(q)
                    );
                }
                
                if (weapons.length === 0) return;
                
                html += `<div class="caliber-group mb-3">
                    <div class="caliber-header">${cal} (${weapons.length})</div>
                    <div class="ammo-grid">`;
                
                weapons.forEach(w => {
                    const isOwned = ownedWeapons.has(w.id);
                    const tierInfo = getWeaponTier(w);
                    const isOverridden = tierOverrides.weapons[w.id] !== undefined;
                    const sourceClass = tierInfo.source.includes('+') ? 'source-both' : 'source-pen';
                    const isBulkSelected = bulkSelected.weapons.has(w.id);
                    
                    html += `
                        <div class="ammo-card weapon-card ${isOwned ? 'owned' : ''} ${isOverridden ? 'overridden' : ''} ${isBulkSelected ? 'bulk-selected' : ''}" 
                             data-id="${w.id}"
                             onclick="${bulkMode.weapons ? `toggleBulkItem('weapons', '${w.id}', event)` : `toggleWeaponOwned('${w.id}')`}">
                            <input type="checkbox" class="item-checkbox" ${isBulkSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleBulkItem('weapons', '${w.id}', event)">
                            <span class="tier-badge tier-${tierInfo.tier}">${tierInfo.tier}</span>
                            ${w.iconLink ? `<img src="${w.iconLink}">` : ''}
                            <div class="flex-grow-1">
                                <div class="fw-bold" style="color: var(--text-main);">${w.shortName}</div>
                                <div class="ammo-stats">
                                    <span class="stat-pen">ERG ${w.ergonomics}</span>
                                    <span class="stat-dmg">V.REC ${w.recoilVertical}</span>
                                    ${w.sellPrice > 0 ? `<span class="stat-price">${w.sellPrice.toLocaleString()}</span>` : ''}
                                </div>
                            </div>
                            <span class="tier-source ${sourceClass}">${tierInfo.source}</span>
                            ${isOwned ? '<span class="badge-tarkov badge-active">OWNED</span>' : ''}
                            <select class="tier-select-mini" onclick="event.stopPropagation()" onchange="setWeaponTierOverride('${w.id}', this.value)">
                                <option value="" ${!isOverridden ? 'selected' : ''}>Auto</option>
                                ${TIER_NAMES.map(t => `<option value="${t}" ${tierOverrides.weapons[w.id] === t ? 'selected' : ''}>${t}</option>`).join('')}
                            </select>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            container.innerHTML = html || '<div class="text-sub p-3">No weapons match your filter.</div>';
            updateWeaponAnalysis();
        }
        
        function getWeaponTier(weapon) {
            return getItemTier('weapons', weapon.id, {
                ergo: weapon.ergonomics,
                recoilVert: weapon.recoilVertical,
                recoilHoriz: weapon.recoilHorizontal,
                fireRate: weapon.fireRate,
                effectiveDist: weapon.effectiveDistance,
                convergence: weapon.convergence || 0,
                cameraRecoil: weapon.cameraRecoil || 0,
                deviationCurve: weapon.deviationCurve || 0,
                deviationMax: weapon.deviationMax || 0,
                sightingRange: weapon.sightingRange || 0
            });
        }
        
        function filterWeapons() {
            weaponTypeFilter = document.getElementById('weaponTypeFilter').value;
            weaponSearchQuery = document.getElementById('weaponSearch').value;
            renderWeaponsList();
        }
        
        function toggleWeaponOwned(id) {
            ownedWeapons.has(id) ? ownedWeapons.delete(id) : ownedWeapons.add(id);
            saveOwnedWeapons();
            renderWeaponsList();
            updateDashboard();
        }
        
        function setWeaponTierOverride(id, tier) {
            setItemTierOverride('weapons', id, tier);
            renderWeaponsList();
        }
        
        function updateWeaponAnalysis() {
            if (!allWeaponsData) return;
            
            const tierIndex = TIER_ORDER.indexOf(keepTierThreshold.weapons);
            const keepTiers = TIER_ORDER.slice(0, tierIndex + 1);
            
            const owned = allWeaponsData.all.filter(w => ownedWeapons.has(w.id));
            const keep = owned.filter(w => keepTiers.includes(getWeaponTier(w).tier));
            const sell = owned.filter(w => !keepTiers.includes(getWeaponTier(w).tier));
            
            document.getElementById('weapons-keep-count').textContent = keep.length;
            document.getElementById('weapons-sell-count').textContent = sell.length;
            
            document.getElementById('weapons-keep-list').innerHTML = keep.length > 0
                ? keep.map(w => renderAnalysisItem(w, 'keep', 'weapons')).join('')
                : '<div class="text-sub p-2 small">No weapons to keep marked.</div>';
            
            document.getElementById('weapons-sell-list').innerHTML = sell.length > 0
                ? sell.map(w => renderAnalysisItem(w, 'sell', 'weapons')).join('')
                : '<div class="text-sub p-2 small">No weapons to sell.</div>';
            
            document.getElementById('weapons-total-sell-value').textContent = 
                sell.reduce((sum, w) => sum + (w.sellPrice || 0), 0).toLocaleString() + ' RUB';
        }
        
        function saveOwnedWeapons() { localStorage.setItem(STORAGE_KEY_WEAPONS, JSON.stringify([...ownedWeapons])); }
        function loadOwnedWeapons() { const s = localStorage.getItem(STORAGE_KEY_WEAPONS); if (s) ownedWeapons = new Set(JSON.parse(s)); }
        
        // ============================================================================
        // GEAR MANAGER
        // ============================================================================
        
        async function loadGearData() {
            const loading = document.getElementById('gear-loading');
            const content = document.getElementById('gear-content');
            const error = document.getElementById('gear-error');
            const btn = document.getElementById('btn-load-gear');
            
            loading.classList.remove('d-none');
            content.classList.add('d-none');
            error.classList.add('d-none');
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            try {
                const query = `{
                    items(types: [armor, helmet, rig, backpack, headphones]) {
                        id
                        name
                        shortName
                        iconLink
                        avg24hPrice
                        sellFor { price vendor { name } }
                        types
                        properties {
                            ... on ItemPropertiesArmor {
                                class
                                durability
                                material { name }
                                ergoPenalty
                                speedPenalty
                                turnPenalty
                            }
                            ... on ItemPropertiesHelmet {
                                class
                                durability
                                material { name }
                                ergoPenalty
                                speedPenalty
                                turnPenalty
                                ricochetY
                            }
                            ... on ItemPropertiesChestRig {
                                class
                                durability
                                material { name }
                                capacity
                            }
                            ... on ItemPropertiesBackpack {
                                capacity
                                speedPenalty
                            }
                            ... on ItemPropertiesHeadphone {
                                ambientVolume
                                distortion
                            }
                        }
                    }
                }`;
                
                const response = await fetch('https://api.tarkov.dev/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                
                const data = await response.json();
                if (data.errors) throw new Error(data.errors[0].message);
                
                const gear = data.data.items.map(g => {
                    const props = g.properties || {};
                    const bestSell = g.sellFor?.reduce((best, s) => s.price > best.price ? s : best, { price: 0 }) || { price: 0 };
                    
                    // Determine gear type
                    let gearType = 'other';
                    if (g.types?.includes('armor')) gearType = 'armor';
                    else if (g.types?.includes('helmet')) gearType = 'helmet';
                    else if (g.types?.includes('backpack')) gearType = 'backpack';
                    else if (g.types?.includes('rig')) gearType = 'rig';
                    else if (g.types?.includes('headphones')) gearType = 'headphones';
                    
                    return {
                        id: g.id,
                        name: g.name,
                        shortName: g.shortName,
                        iconLink: g.iconLink,
                        gearType,
                        armorClass: props.class || 0,
                        durability: props.durability || 0,
                        material: props.material?.name || '',
                        capacity: props.capacity || 0,
                        ergoPenalty: props.ergoPenalty || 0,
                        speedPenalty: props.speedPenalty || 0,
                        turnPenalty: props.turnPenalty || 0,
                        ricochetY: props.ricochetY || 0,
                        ambientVolume: props.ambientVolume || 0,
                        distortion: props.distortion || 0,
                        sellPrice: bestSell.price,
                        sellTo: bestSell.vendor?.name || 'Fence'
                    };
                });
                
                // Group by type
                const byType = {};
                gear.forEach(g => {
                    if (!byType[g.gearType]) byType[g.gearType] = [];
                    byType[g.gearType].push(g);
                });
                
                // Sort by tier
                Object.values(byType).forEach(arr => {
                    arr.sort((a, b) => TIER_ORDER.indexOf(getGearTier(a).tier) - TIER_ORDER.indexOf(getGearTier(b).tier));
                });
                
                allGearData = { all: gear, byType };
                document.getElementById('gear-count').textContent = gear.length;
                
                loading.classList.add('d-none');
                content.classList.remove('d-none');
                btn.textContent = 'üîÑ Refresh Data';
                btn.style.display = 'block';
                btn.disabled = false;
                
                loadOwnedGear();
                renderGearList();
                
            } catch (err) {
                loading.classList.add('d-none');
                error.classList.remove('d-none');
                error.textContent = 'Error loading gear: ' + err.message;
                btn.textContent = 'üîÑ Retry';
                btn.style.display = 'block';
                btn.disabled = false;
            }
        }
        
        function renderGearList() {
            if (!allGearData) return;
            
            const container = document.getElementById('gear-list');
            let html = '';
            
            const typeLabels = { armor: 'Body Armor', helmet: 'Helmets', rig: 'Tactical Rigs', backpack: 'Backpacks', headphones: 'Headsets' };
            const types = gearTypeFilter === 'ALL' ? Object.keys(allGearData.byType) : [gearTypeFilter];
            
            types.forEach(type => {
                let items = allGearData.byType[type] || [];
                
                if (gearSearchQuery) {
                    const q = gearSearchQuery.toLowerCase();
                    items = items.filter(g => g.name.toLowerCase().includes(q) || g.shortName.toLowerCase().includes(q));
                }
                
                if (items.length === 0) return;
                
                html += `<div class="caliber-group mb-3">
                    <div class="caliber-header">${typeLabels[type] || type} (${items.length})</div>
                    <div class="ammo-grid">`;
                
                items.forEach(g => {
                    const isOwned = ownedGear.has(g.id);
                    const tierInfo = getGearTier(g);
                    const isOverridden = tierOverrides.gear[g.id] !== undefined;
                    const sourceClass = tierInfo.source.includes('+') ? 'source-both' : 'source-pen';
                    const isBulkSelected = bulkSelected.gear.has(g.id);
                    
                    // Show relevant stats based on type
                    let statsHtml = '';
                    if (g.armorClass > 0) {
                        statsHtml += `<span class="stat-pen">CL ${g.armorClass}</span>`;
                        statsHtml += `<span class="stat-dmg">DUR ${g.durability}</span>`;
                    } else if (g.gearType === 'backpack') {
                        statsHtml += `<span class="stat-pen">CAP ${g.capacity}</span>`;
                    } else if (g.gearType === 'headphones') {
                        statsHtml += `<span class="stat-pen">VOL ${g.ambientVolume}</span>`;
                    }
                    if (g.sellPrice > 0) statsHtml += `<span class="stat-price">${g.sellPrice.toLocaleString()}</span>`;
                    
                    html += `
                        <div class="ammo-card gear-card ${isOwned ? 'owned' : ''} ${isOverridden ? 'overridden' : ''} ${isBulkSelected ? 'bulk-selected' : ''}" 
                             data-id="${g.id}"
                             onclick="${bulkMode.gear ? `toggleBulkItem('gear', '${g.id}', event)` : `toggleGearOwned('${g.id}')`}">
                            <input type="checkbox" class="item-checkbox" ${isBulkSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleBulkItem('gear', '${g.id}', event)">
                            <span class="tier-badge tier-${tierInfo.tier}">${tierInfo.tier}</span>
                            ${g.iconLink ? `<img src="${g.iconLink}">` : ''}
                            <div class="flex-grow-1">
                                <div class="fw-bold" style="color: var(--text-main);">${g.shortName}</div>
                                <div class="ammo-stats">${statsHtml}</div>
                            </div>
                            <span class="tier-source ${sourceClass}">${tierInfo.source}</span>
                            ${isOwned ? '<span class="badge-tarkov badge-active">OWNED</span>' : ''}
                            <select class="tier-select-mini" onclick="event.stopPropagation()" onchange="setGearTierOverride('${g.id}', this.value)">
                                <option value="" ${!isOverridden ? 'selected' : ''}>Auto</option>
                                ${TIER_NAMES.map(t => `<option value="${t}" ${tierOverrides.gear[g.id] === t ? 'selected' : ''}>${t}</option>`).join('')}
                            </select>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            container.innerHTML = html || '<div class="text-sub p-3">No gear matches your filter.</div>';
            updateGearAnalysis();
        }
        
        function getGearTier(gear) {
            // For armored rigs, use special type
            let effectiveType = gear.gearType;
            if (gear.gearType === 'rig' && gear.armorClass > 0) {
                effectiveType = 'armored_rig';
            }
            
            return getItemTier('gear', gear.id, {
                armorClass: gear.armorClass,
                durability: gear.durability,
                ergoPenalty: gear.ergoPenalty,
                speedPenalty: gear.speedPenalty,
                turnPenalty: gear.turnPenalty || 0,
                ricochetY: gear.ricochetY || 0,
                capacity: gear.capacity,
                ambientVol: gear.ambientVolume || 0,
                distortion: gear.distortion || 0
            }, effectiveType);
        }
        
        function filterGear() {
            gearTypeFilter = document.getElementById('gearTypeFilter').value;
            gearSearchQuery = document.getElementById('gearSearch').value;
            renderGearList();
            // Update stat checkboxes to reflect applicable stats for filtered type
            renderStatCheckboxes('gear');
        }
        
        function toggleGearOwned(id) {
            ownedGear.has(id) ? ownedGear.delete(id) : ownedGear.add(id);
            saveOwnedGear();
            renderGearList();
            updateDashboard();
        }
        
        function setGearTierOverride(id, tier) {
            setItemTierOverride('gear', id, tier);
            renderGearList();
        }
        
        function updateGearAnalysis() {
            if (!allGearData) return;
            
            const tierIndex = TIER_ORDER.indexOf(keepTierThreshold.gear);
            const keepTiers = TIER_ORDER.slice(0, tierIndex + 1);
            
            const owned = allGearData.all.filter(g => ownedGear.has(g.id));
            const keep = owned.filter(g => keepTiers.includes(getGearTier(g).tier));
            const sell = owned.filter(g => !keepTiers.includes(getGearTier(g).tier));
            
            document.getElementById('gear-keep-count').textContent = keep.length;
            document.getElementById('gear-sell-count').textContent = sell.length;
            
            document.getElementById('gear-keep-list').innerHTML = keep.length > 0
                ? keep.map(g => renderAnalysisItem(g, 'keep', 'gear')).join('')
                : '<div class="text-sub p-2 small">No gear to keep marked.</div>';
            
            document.getElementById('gear-sell-list').innerHTML = sell.length > 0
                ? sell.map(g => renderAnalysisItem(g, 'sell', 'gear')).join('')
                : '<div class="text-sub p-2 small">No gear to sell.</div>';
            
            document.getElementById('gear-total-sell-value').textContent =
                sell.reduce((sum, g) => sum + (g.sellPrice || 0), 0).toLocaleString() + ' RUB';
        }
        
        function saveOwnedGear() { localStorage.setItem(STORAGE_KEY_GEAR, JSON.stringify([...ownedGear])); }
        function loadOwnedGear() { const s = localStorage.getItem(STORAGE_KEY_GEAR); if (s) ownedGear = new Set(JSON.parse(s)); }
        
        // ============================================================================
        // ATTACHMENTS MANAGER
        // ============================================================================
        
        async function loadAttachmentsData() {
            const loading = document.getElementById('attachments-loading');
            const content = document.getElementById('attachments-content');
            const error = document.getElementById('attachments-error');
            const btn = document.getElementById('btn-load-attachments');
            
            loading.classList.remove('d-none');
            content.classList.add('d-none');
            error.classList.add('d-none');
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            try {
                const query = `{
                    items(types: [mods]) {
                        id
                        name
                        shortName
                        iconLink
                        avg24hPrice
                        sellFor { price vendor { name } }
                        types
                        categories {
                            name
                            normalizedName
                        }
                        properties {
                            ... on ItemPropertiesMagazine {
                                capacity
                                ergonomics
                                recoilModifier
                            }
                            ... on ItemPropertiesBarrel {
                                ergonomics
                                recoilModifier
                                accuracyModifier
                            }
                            ... on ItemPropertiesScope {
                                ergonomics
                                recoilModifier
                                zoomLevels
                                sightingRange
                            }
                            ... on ItemPropertiesWeaponMod {
                                ergonomics
                                recoilModifier
                                accuracyModifier
                            }
                        }
                    }
                }`;
                
                const response = await fetch('https://api.tarkov.dev/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                
                const data = await response.json();
                if (data.errors) throw new Error(data.errors[0].message);
                
                // Debug: Log first few items to see category structure
                console.log('Sample attachment categories:', data.data.items.slice(0, 5).map(i => ({
                    name: i.name,
                    types: i.types,
                    categories: i.categories?.map(c => c.normalizedName)
                })));
                
                const attachments = data.data.items.map(a => {
                    const props = a.properties || {};
                    const bestSell = a.sellFor?.reduce((best, s) => s.price > best.price ? s : best, { price: 0 }) || { price: 0 };
                    
                    // Use categories (more detailed) to determine attachment type
                    const categoryNames = a.categories?.map(c => c.normalizedName?.toLowerCase()) || [];
                    const categoryLabels = a.categories?.map(c => c.name) || [];
                    
                    // Category mapping - order matters (more specific first)
                    const categoryMap = {
                        'compact-reflex-sights': 'Reflex Sights',
                        'reflex-sights': 'Reflex Sights',
                        'iron-sights': 'Iron Sights',
                        'assault-scopes': 'Assault Scopes',
                        'optic-scopes': 'Scopes',
                        'special-scopes': 'Scopes',
                        'scopes': 'Scopes',
                        'night-vision-and-thermal-scopes': 'Thermal/NV',
                        'thermal-vision': 'Thermal/NV',
                        'night-vision': 'Thermal/NV',
                        'stocks': 'Stocks',
                        'pistol-grips': 'Pistol Grips',
                        'foregrips': 'Foregrips',
                        'muzzle-adapters': 'Muzzle Devices',
                        'muzzle-devices': 'Muzzle Devices',
                        'flash-hiders-and-muzzle-brakes': 'Muzzle Devices',
                        'suppressors': 'Suppressors',
                        'silencers': 'Suppressors',
                        'barrels': 'Barrels',
                        'handguards': 'Handguards',
                        'magazines': 'Magazines',
                        'mounts': 'Mounts',
                        'auxiliary-parts': 'Auxiliary Parts',
                        'bipods': 'Bipods',
                        'flashlights': 'Flashlights',
                        'tactical-combo-devices': 'Tactical Devices',
                        'laser-target-pointers': 'Lasers',
                        'charging-handles': 'Charging Handles',
                        'receivers-and-slides': 'Receivers',
                        'gas-blocks': 'Gas Blocks',
                        'rails': 'Rails',
                        'light-laser-devices': 'Light/Laser'
                    };
                    
                    let attachType = 'Other';
                    
                    // Check categories first (most reliable)
                    for (const [catKey, label] of Object.entries(categoryMap)) {
                        if (categoryNames.some(c => c && c.includes(catKey))) {
                            attachType = label;
                            break;
                        }
                    }
                    
                    // Fallback: use first category name if available
                    if (attachType === 'Other' && categoryLabels.length > 0) {
                        // Find the most specific (non-generic) category
                        const specificCat = categoryLabels.find(c => 
                            c && !['Mods', 'Weapon mods', 'Gear mods', 'Functional mods', 'Master mods'].includes(c)
                        );
                        if (specificCat) {
                            attachType = specificCat;
                        }
                    }
                    
                    return {
                        id: a.id,
                        name: a.name,
                        shortName: a.shortName,
                        iconLink: a.iconLink,
                        attachType,
                        ergonomics: props.ergonomics || 0,
                        recoilModifier: props.recoilModifier || 0,
                        accuracyModifier: props.accuracyModifier || 0,
                        capacity: props.capacity || 0,
                        checkTimeModifier: props.checkTimeModifier || 0,
                        loadModifier: props.loadModifier || 0,
                        zoomLevels: props.zoomLevels || [],
                        sightingRange: props.sightingRange || 0,
                        centerOfImpact: props.centerOfImpact || 0,
                        deviationCurve: props.deviationCurve || 0,
                        deviationMax: props.deviationMax || 0,
                        sellPrice: bestSell.price,
                        sellTo: bestSell.vendor?.name || 'Fence'
                    };
                });
                
                // Group by type
                const byType = {};
                attachments.forEach(a => {
                    if (!byType[a.attachType]) byType[a.attachType] = [];
                    byType[a.attachType].push(a);
                });
                
                // Log category distribution
                console.log('Attachment categories:', Object.entries(byType).map(([k, v]) => `${k}: ${v.length}`).join(', '));
                
                // Sort by tier
                Object.values(byType).forEach(arr => {
                    arr.sort((a, b) => TIER_ORDER.indexOf(getAttachmentTier(a).tier) - TIER_ORDER.indexOf(getAttachmentTier(b).tier));
                });
                
                allAttachmentsData = { all: attachments, byType };
                
                // Populate type filter
                const typeFilter = document.getElementById('attachmentTypeFilter');
                const types = Object.keys(byType).sort();
                typeFilter.innerHTML = '<option value="ALL">All Types (' + attachments.length + ')</option>' +
                    types.map(t => `<option value="${t}">${t} (${byType[t].length})</option>`).join('');
                
                document.getElementById('attachment-count').textContent = attachments.length;
                
                loading.classList.add('d-none');
                content.classList.remove('d-none');
                btn.textContent = 'üîÑ Refresh Data';
                btn.style.display = 'block';
                btn.disabled = false;
                
                loadOwnedAttachments();
                renderAttachmentsList();
                
            } catch (err) {
                loading.classList.add('d-none');
                error.classList.remove('d-none');
                error.textContent = 'Error loading attachments: ' + err.message;
                btn.textContent = 'üîÑ Retry';
                btn.style.display = 'block';
                btn.disabled = false;
            }
        }
        
        function renderAttachmentsList() {
            if (!allAttachmentsData) return;
            
            const container = document.getElementById('attachments-list');
            let html = '';
            
            const types = attachmentTypeFilter === 'ALL'
                ? Object.keys(allAttachmentsData.byType).sort()
                : [attachmentTypeFilter];
            
            types.forEach(type => {
                let items = allAttachmentsData.byType[type] || [];
                
                if (attachmentSearchQuery) {
                    const q = attachmentSearchQuery.toLowerCase();
                    items = items.filter(a => a.name.toLowerCase().includes(q) || a.shortName.toLowerCase().includes(q));
                }
                
                if (items.length === 0) return;
                
                html += `<div class="caliber-group mb-3">
                    <div class="caliber-header">${type} (${items.length})</div>
                    <div class="ammo-grid">`;
                
                items.forEach(a => {
                    const isOwned = ownedAttachments.has(a.id);
                    const tierInfo = getAttachmentTier(a);
                    const isOverridden = tierOverrides.attachments[a.id] !== undefined;
                    const sourceClass = tierInfo.source.includes('+') ? 'source-both' : 'source-pen';
                    const isBulkSelected = bulkSelected.attachments.has(a.id);
                    
                    const ergoDisplay = a.ergonomics >= 0 ? `+${a.ergonomics}` : a.ergonomics;
                    const recoilDisplay = a.recoilModifier >= 0 ? `+${a.recoilModifier}%` : `${a.recoilModifier}%`;
                    
                    html += `
                        <div class="ammo-card attachment-card ${isOwned ? 'owned' : ''} ${isOverridden ? 'overridden' : ''} ${isBulkSelected ? 'bulk-selected' : ''}" 
                             data-id="${a.id}"
                             onclick="${bulkMode.attachments ? `toggleBulkItem('attachments', '${a.id}', event)` : `toggleAttachmentOwned('${a.id}')`}">
                            <input type="checkbox" class="item-checkbox" ${isBulkSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleBulkItem('attachments', '${a.id}', event)">
                            <span class="tier-badge tier-${tierInfo.tier}">${tierInfo.tier}</span>
                            ${a.iconLink ? `<img src="${a.iconLink}">` : ''}
                            <div class="flex-grow-1">
                                <div class="fw-bold" style="color: var(--text-main);">${a.shortName}</div>
                                <div class="ammo-stats">
                                    <span class="stat-pen">ERG ${ergoDisplay}</span>
                                    <span class="stat-dmg">REC ${recoilDisplay}</span>
                                    ${a.sellPrice > 0 ? `<span class="stat-price">${a.sellPrice.toLocaleString()}</span>` : ''}
                                </div>
                            </div>
                            <span class="tier-source ${sourceClass}">${tierInfo.source}</span>
                            ${isOwned ? '<span class="badge-tarkov badge-active">OWNED</span>' : ''}
                            <select class="tier-select-mini" onclick="event.stopPropagation()" onchange="setAttachmentTierOverride('${a.id}', this.value)">
                                <option value="" ${!isOverridden ? 'selected' : ''}>Auto</option>
                                ${TIER_NAMES.map(t => `<option value="${t}" ${tierOverrides.attachments[a.id] === t ? 'selected' : ''}>${t}</option>`).join('')}
                            </select>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            container.innerHTML = html || '<div class="text-sub p-3">No attachments match your filter.</div>';
            updateAttachmentAnalysis();
        }
        
        function getAttachmentTier(attach) {
            return getItemTier('attachments', attach.id, {
                ergoMod: attach.ergonomics,
                recoilMod: attach.recoilModifier,
                accMod: attach.accuracyModifier || 0,
                magCapacity: attach.capacity || 0,
                sightingRange: attach.sightingRange || 0,
                zoomLevel: (attach.zoomLevels?.length > 0 ? Math.max(...attach.zoomLevels) : 1)
            }, attach.attachType);
        }
        
        function filterAttachments() {
            attachmentTypeFilter = document.getElementById('attachmentTypeFilter').value;
            attachmentSearchQuery = document.getElementById('attachmentSearch').value;
            renderAttachmentsList();
            // Update stat checkboxes to reflect applicable stats for filtered type
            renderStatCheckboxes('attachments');
        }
        
        function toggleAttachmentOwned(id) {
            ownedAttachments.has(id) ? ownedAttachments.delete(id) : ownedAttachments.add(id);
            saveOwnedAttachments();
            renderAttachmentsList();
            updateDashboard();
        }
        
        function setAttachmentTierOverride(id, tier) {
            setItemTierOverride('attachments', id, tier);
            renderAttachmentsList();
        }
        
        function updateAttachmentAnalysis() {
            if (!allAttachmentsData) return;
            
            const tierIndex = TIER_ORDER.indexOf(keepTierThreshold.attachments);
            const keepTiers = TIER_ORDER.slice(0, tierIndex + 1);
            
            const owned = allAttachmentsData.all.filter(a => ownedAttachments.has(a.id));
            const keep = owned.filter(a => keepTiers.includes(getAttachmentTier(a).tier));
            const sell = owned.filter(a => !keepTiers.includes(getAttachmentTier(a).tier));
            
            document.getElementById('attachments-keep-count').textContent = keep.length;
            document.getElementById('attachments-sell-count').textContent = sell.length;
            
            document.getElementById('attachments-keep-list').innerHTML = keep.length > 0
                ? keep.map(a => renderAnalysisItem(a, 'keep', 'attachments')).join('')
                : '<div class="text-sub p-2 small">No attachments to keep marked.</div>';
            
            document.getElementById('attachments-sell-list').innerHTML = sell.length > 0
                ? sell.map(a => renderAnalysisItem(a, 'sell', 'attachments')).join('')
                : '<div class="text-sub p-2 small">No attachments to sell.</div>';
            
            document.getElementById('attachments-total-sell-value').textContent =
                sell.reduce((sum, a) => sum + (a.sellPrice || 0), 0).toLocaleString() + ' RUB';
        }
        
        function saveOwnedAttachments() { localStorage.setItem(STORAGE_KEY_ATTACHMENTS, JSON.stringify([...ownedAttachments])); }
        function loadOwnedAttachments() { const s = localStorage.getItem(STORAGE_KEY_ATTACHMENTS); if (s) ownedAttachments = new Set(JSON.parse(s)); }
        
        // ============================================================================
        // SHARED EQUIPMENT ANALYSIS RENDERER
        // ============================================================================
        
        function renderEquipmentAnalysisItem(item, type, tierInfo) {
            return `
                <div class="item-box ${type === 'keep' ? 'status-provided' : 'status-acquire'} w-100 mb-1">
                    <span class="tier-badge tier-${tierInfo.tier}" style="width:24px;height:24px;line-height:24px;font-size:0.75rem;">${tierInfo.tier}</span>
                    ${item.iconLink ? `<img src="${item.iconLink}" style="width:28px;height:28px;">` : ''}
                    <div class="flex-grow-1">
                        <div style="font-size:0.85rem;">${item.shortName}</div>
                        <div style="font-size:0.7rem;color:var(--text-sub);">${item.caliber || item.gearType || item.attachType || ''}</div>
                    </div>
                    ${type === 'sell' && item.sellPrice > 0 ? `<span class="stat-price small">${item.sellPrice.toLocaleString()} RUB</span>` : ''}
                </div>
            `;
        }

        // ============================================================================
        // PENETRATION MATRIX
        // ============================================================================
        
        function renderPenMatrix() {
            if (!allAmmoData) {
                document.getElementById('pen-loading').classList.remove('d-none');
                document.getElementById('pen-matrix-container').classList.add('d-none');
                return;
            }
            
            document.getElementById('pen-loading').classList.add('d-none');
            document.getElementById('pen-matrix-container').classList.remove('d-none');
            
            // Populate caliber filter if not done
            const caliberSelect = document.getElementById('penCaliberFilter');
            if (caliberSelect.options.length <= 1) {
                allAmmoData.calibers.forEach(cal => {
                    caliberSelect.innerHTML += `<option value="${cal}">${cal}</option>`;
                });
            }
            
            const caliberFilter = document.getElementById('penCaliberFilter').value;
            const sortBy = document.getElementById('penSortBy').value;
            const showOnlyOwned = document.getElementById('penShowOwned').checked;
            
            // Filter ammo
            let ammoList = allAmmoData.all;
            if (caliberFilter !== 'ALL') {
                ammoList = ammoList.filter(a => a.caliber === caliberFilter);
            }
            if (showOnlyOwned) {
                ammoList = ammoList.filter(a => ownedAmmo.has(a.id));
            }
            
            // Sort
            ammoList = [...ammoList].sort((a, b) => {
                if (sortBy === 'pen') return b.penetration - a.penetration;
                if (sortBy === 'damage') return b.damage - a.damage;
                return a.name.localeCompare(b.name);
            });
            
            // Build matrix
            const armorClasses = [1, 2, 3, 4, 5, 6];
            
            let html = '<table class="pen-matrix"><thead><tr>';
            html += '<th class="ammo-name">Ammo</th>';
            html += '<th class="ammo-pen">PEN</th>';
            armorClasses.forEach(ac => {
                html += `<th>Class ${ac}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Group by caliber for better readability
            const byCaliber = {};
            ammoList.forEach(a => {
                if (!byCaliber[a.caliber]) byCaliber[a.caliber] = [];
                byCaliber[a.caliber].push(a);
            });
            
            for (const [caliber, ammos] of Object.entries(byCaliber)) {
                if (caliberFilter === 'ALL' && ammos.length > 0) {
                    html += `<tr><td colspan="${armorClasses.length + 2}" class="caliber-header">${caliber}</td></tr>`;
                }
                
                ammos.forEach(a => {
                    html += '<tr>';
                    html += `<td class="ammo-name">${a.shortName}</td>`;
                    html += `<td class="ammo-pen">${a.penetration}</td>`;
                    
                    armorClasses.forEach(ac => {
                        const pen = a.penetration;
                        // Simplified penetration effectiveness calculation
                        // Based on armor class thresholds
                        const classThreshold = ac * 10;
                        let penClass, penText;
                        
                        if (pen >= classThreshold + 10) {
                            penClass = 'pen-high';
                            penText = '‚úì‚úì‚úì';
                        } else if (pen >= classThreshold) {
                            penClass = 'pen-high';
                            penText = '‚úì‚úì';
                        } else if (pen >= classThreshold - 10) {
                            penClass = 'pen-mid';
                            penText = '‚úì';
                        } else if (pen >= classThreshold - 20) {
                            penClass = 'pen-low';
                            penText = '~';
                        } else {
                            penClass = 'pen-none';
                            penText = '‚úó';
                        }
                        
                        html += `<td class="pen-cell ${penClass}">${penText}</td>`;
                    });
                    
                    html += '</tr>';
                });
            }
            
            html += '</tbody></table>';
            document.getElementById('pen-matrix-container').innerHTML = html;
        }

        // ============================================================================
        // INVENTORY DASHBOARD
        // ============================================================================
        
        let dashboardCollapsed = false;
        
        function toggleDashboard() {
            dashboardCollapsed = !dashboardCollapsed;
            document.getElementById('dashboardContent').classList.toggle('collapsed', dashboardCollapsed);
            document.getElementById('dashboardArrow').textContent = dashboardCollapsed ? '√¢‚Äì¬∂' : '‚ñº';
        }
        
        function updateDashboard() {
            const stats = {
                ammo: { owned: ownedAmmo.size, total: allAmmoData?.all?.length || 0, value: 0 },
                weapons: { owned: ownedWeapons.size, total: allWeaponsData?.all?.length || 0, value: 0 },
                gear: { owned: ownedGear.size, total: allGearData?.all?.length || 0, value: 0 },
                attachments: { owned: ownedAttachments.size, total: allAttachmentsData?.all?.length || 0, value: 0 }
            };
            
            // Calculate values
            if (allAmmoData) {
                allAmmoData.all.filter(a => ownedAmmo.has(a.id)).forEach(a => stats.ammo.value += a.sellPrice || 0);
            }
            if (allWeaponsData) {
                allWeaponsData.all.filter(w => ownedWeapons.has(w.id)).forEach(w => stats.weapons.value += w.sellPrice || 0);
            }
            if (allGearData) {
                allGearData.all.filter(g => ownedGear.has(g.id)).forEach(g => stats.gear.value += g.sellPrice || 0);
            }
            if (allAttachmentsData) {
                allAttachmentsData.all.filter(a => ownedAttachments.has(a.id)).forEach(a => stats.attachments.value += a.sellPrice || 0);
            }
            
            // Update UI
            for (const [cat, s] of Object.entries(stats)) {
                document.getElementById(`dash-${cat}-count`).textContent = `${s.owned}/${s.total}`;
                document.getElementById(`dash-${cat}-pct`).textContent = s.total > 0 ? `${Math.round(s.owned / s.total * 100)}%` : '-';
                document.getElementById(`dash-${cat}-value`).textContent = s.value.toLocaleString() + ' ‚ÇΩ';
            }
            
            // Totals
            const totalOwned = stats.ammo.owned + stats.weapons.owned + stats.gear.owned + stats.attachments.owned;
            const totalItems = stats.ammo.total + stats.weapons.total + stats.gear.total + stats.attachments.total;
            const totalValue = stats.ammo.value + stats.weapons.value + stats.gear.value + stats.attachments.value;
            
            document.getElementById('dash-total-count').textContent = totalOwned;
            document.getElementById('dash-total-pct').textContent = totalItems > 0 ? `${Math.round(totalOwned / totalItems * 100)}%` : '-';
            document.getElementById('dash-total-value').textContent = totalValue.toLocaleString() + ' ‚ÇΩ';
        }


        // ============================================================================
        // MAP OVERLAY SYSTEM
        // ============================================================================
        
        // Overlay data cache per map
        let mapOverlayData = {};
        let allMapsCache = null;
        
        // Overlay state
        let overlayLayers = {
            extracts_pmc: { enabled: false, markers: [] },
            extracts_scav: { enabled: false, markers: [] },
            hazards: { enabled: false, markers: [] },
            locks: { enabled: false, markers: [] }
        };
        
        // Currently active map in multi-map mode
        let activeMapTab = null;
        let multiMapMode = false;
        let requiredMaps = [];
        
        async function loadMapOverlayData(mapName) {
            // Check cache first
            if (mapOverlayData[mapName]) {
                console.log('Using cached overlay data for:', mapName);
                return mapOverlayData[mapName];
            }
            
            // Map key to API name mapping
            const apiMapNames = {
                customs: 'Customs',
                woods: 'Woods',
                shoreline: 'Shoreline',
                interchange: 'Interchange',
                reserve: 'Reserve',
                lighthouse: 'Lighthouse',
                streets: 'Streets of Tarkov',
                groundzero: 'Ground Zero',
                factory: 'Factory',
                labs: 'The Lab'
            };
            
            const apiMapName = apiMapNames[mapName] || mapName;
            console.log('Loading overlay data for:', mapName);
            
            try {
                // Use cached all-maps data or fetch new
                let allMaps;
                if (allMapsCache) {
                    allMaps = allMapsCache;
                } else {
                    const query = `{
                        maps {
                            name
                            normalizedName
                            extracts {
                                name
                                faction
                                position { x y z }
                                outline { x y z }
                                top
                                bottom
                                switches {
                                    name
                                    position { x y z }
                                }
                            }
                            hazards {
                                name
                                position { x y z }
                                outline { x y z }
                                top
                                bottom
                            }
                            locks {
                                lockType
                                key {
                                    name
                                    shortName
                                }
                                needsPower
                                position { x y z }
                                outline { x y z }
                                top
                                bottom
                            }
                        }
                    }`;
                    
                    const response = await fetch('https://api.tarkov.dev/graphql', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query })
                    });
                    
                    if (!response.ok) {
                        console.error('API error:', response.status);
                        return null;
                    }
                    
                    const data = await response.json();
                    if (data.errors) {
                        console.error('GraphQL errors:', data.errors);
                        return null;
                    }
                    
                    allMaps = data?.data?.maps || [];
                    if (allMaps.length > 0) {
                        allMapsCache = allMaps;
                        console.log('Loaded', allMaps.length, 'maps from API');
                    }
                }
                
                // Find the correct map
                const mapData = allMaps.find(m => 
                    m.normalizedName === mapName || 
                    m.name.toLowerCase() === apiMapName.toLowerCase()
                );
                
                if (!mapData) {
                    console.warn('Map not found:', mapName);
                    return null;
                }
                
                // Process overlay data
                const processed = {
                    extracts_pmc: [],
                    extracts_scav: [],
                    hazards: [],
                    locks: []
                };
                
                // Process extracts
                if (mapData.extracts) {
                    mapData.extracts.forEach(extract => {
                        const pos = extract.position || (extract.outline && extract.outline[0]);
                        if (!pos) return;
                        
                        const extractInfo = {
                            name: extract.name,
                            faction: extract.faction,
                            x: pos.x,
                            y: pos.z,
                            switches: extract.switches || []
                        };
                        
                        if (extract.faction === 'pmc' || extract.faction === 'all') {
                            processed.extracts_pmc.push(extractInfo);
                        }
                        if (extract.faction === 'scav' || extract.faction === 'all') {
                            processed.extracts_scav.push({...extractInfo});
                        }
                    });
                }
                
                // Process hazards
                if (mapData.hazards) {
                    mapData.hazards.forEach(hazard => {
                        const pos = hazard.position || (hazard.outline && hazard.outline[0]);
                        if (!pos) return;
                        
                        processed.hazards.push({
                            name: hazard.name,
                            x: pos.x,
                            y: pos.z
                        });
                    });
                }
                
                // Process locks
                if (mapData.locks) {
                    mapData.locks.forEach(lock => {
                        const pos = lock.position || (lock.outline && lock.outline[0]);
                        if (!pos) return;
                        
                        processed.locks.push({
                            name: lock.key?.name || 'Unknown',
                            shortName: lock.key?.shortName || '',
                            lockType: lock.lockType,
                            needsPower: lock.needsPower,
                            x: pos.x,
                            y: pos.z
                        });
                    });
                }
                
                mapOverlayData[mapName] = processed;
                console.log('Overlay data for', mapName, '- PMC Exits:', processed.extracts_pmc.length, 
                    'Scav Exits:', processed.extracts_scav.length,
                    'Hazards:', processed.hazards.length, 
                    'Locks:', processed.locks.length);
                    
                return processed;
                
            } catch (err) {
                console.error('Error loading overlay data:', err);
                return null;
            }
        }
        
        async function toggleMapOverlay(overlayType) {
            const checkbox = document.getElementById('overlay-' + overlayType.replace('_', '-'));
            overlayLayers[overlayType].enabled = checkbox?.checked || false;
            
            console.log(`toggleMapOverlay: ${overlayType} = ${overlayLayers[overlayType].enabled}`);
            
            await renderOverlayMarkers();
        }
        
        async function renderOverlayMarkers() {
            const currentMap = activeMapTab || document.getElementById('mapSelect')?.value || 'customs';
            console.log('renderOverlayMarkers for map:', currentMap);
            
            // Clear existing overlay markers
            Object.values(overlayLayers).forEach(layer => {
                layer.markers.forEach(m => m.remove());
                layer.markers = [];
            });
            
            // Check if any overlays are enabled
            const anyEnabled = Object.values(overlayLayers).some(l => l.enabled);
            if (!anyEnabled) {
                console.log('No overlays enabled');
                updateMarkerCount();
                return;
            }
            
            // Load overlay data for current map
            const overlays = await loadMapOverlayData(currentMap);
            if (!overlays) {
                console.warn('No overlay data for:', currentMap);
                updateMarkerCount();
                return;
            }
            
            if (!mapInstance) {
                console.warn('Map not ready');
                return;
            }
            
            // Render each enabled overlay
            for (const [overlayType, layer] of Object.entries(overlayLayers)) {
                if (!layer.enabled) continue;
                
                const points = overlays[overlayType] || [];
                console.log(`${overlayType}: ${points.length} points`);
                
                points.forEach((point, idx) => {
                    // Convert game coordinates to map coordinates
                    const coords = convertGameCoordsToMap(point.x, point.y, currentMap);
                    if (!coords) return;
                    
                    // Create marker icon based on type
                    const icon = createOverlayIcon(overlayType, point);
                    
                    const marker = L.marker([coords.y, coords.x], { icon })
                        .addTo(mapInstance);
                    
                    // Build popup content
                    let popupHtml = '<div class="overlay-popup">';
                    
                    if (overlayType === 'extracts_pmc') {
                        popupHtml += `<h6>üö™ ${point.name}</h6>`;
                        popupHtml += `<span class="overlay-type pmc">PMC Exit</span>`;
                        if (point.switches?.length > 0) {
                            popupHtml += `<div class="overlay-detail">‚ö° Requires switch activation</div>`;
                        }
                    } else if (overlayType === 'extracts_scav') {
                        popupHtml += `<h6>üö™ ${point.name}</h6>`;
                        popupHtml += `<span class="overlay-type scav">Scav Exit</span>`;
                    } else if (overlayType === 'hazards') {
                        popupHtml += `<h6>‚ö†Ô∏è ${point.name}</h6>`;
                        popupHtml += `<span class="overlay-type hazard">Hazard Zone</span>`;
                    } else if (overlayType === 'locks') {
                        popupHtml += `<h6>üîê ${point.shortName || point.name}</h6>`;
                        popupHtml += `<span class="overlay-type lock">${point.lockType || 'Locked'}</span>`;
                        if (point.needsPower) {
                            popupHtml += `<div class="overlay-detail">‚ö° Requires power</div>`;
                        }
                        popupHtml += `<div class="overlay-detail">Key: ${point.name}</div>`;
                    }
                    
                    popupHtml += '</div>';
                    
                    marker.bindPopup(popupHtml, {
                        className: 'tarkov-popup',
                        maxWidth: 250
                    });
                    
                    // Add tooltip
                    marker.bindTooltip(point.name || overlayType, {
                        direction: 'auto',
                        className: 'tarkov-tooltip'
                    });
                    
                    layer.markers.push(marker);
                });
            }
            
            updateMarkerCount();
        }
        
        function createOverlayIcon(type, point) {
            let html = '';
            let className = 'overlay-marker';
            
            switch(type) {
                case 'extracts_pmc':
                    html = 'üö™';
                    className += ' extract-pmc';
                    break;
                case 'extracts_scav':
                    html = 'üö™';
                    className += ' extract-scav';
                    break;
                case 'hazards':
                    html = '‚ö†Ô∏è';
                    className += ' hazard';
                    break;
                case 'locks':
                    html = 'üîê';
                    className += ' lock';
                    break;
            }
            
            return L.divIcon({
                html: html,
                className: className,
                iconSize: [28, 28],
                iconAnchor: [14, 14]
            });
        }
        
        function convertGameCoordsToMap(gameX, gameZ, mapKey) {
            // Convert game coordinates (in meters) to map pixel coordinates
            const mapBounds = {
                shoreline: { minX: -1100, maxX: 600, minZ: -200, maxZ: 700, flipX: false, flipZ: true },
                customs: { minX: -300, maxX: 500, minZ: -200, maxZ: 350, flipX: false, flipZ: true },
                woods: { minX: -600, maxX: 600, minZ: -800, maxZ: 400, flipX: false, flipZ: true },
                interchange: { minX: -200, maxX: 300, minZ: -300, maxZ: 200, flipX: false, flipZ: true },
                reserve: { minX: -350, maxX: 250, minZ: -350, maxZ: 250, flipX: false, flipZ: true },
                lighthouse: { minX: -300, maxX: 600, minZ: -500, maxZ: 200, flipX: false, flipZ: true },
                streets: { minX: -350, maxX: 450, minZ: -400, maxZ: 400, flipX: false, flipZ: true },
                groundzero: { minX: -200, maxX: 200, minZ: -200, maxZ: 200, flipX: false, flipZ: true },
                factory: { minX: -60, maxX: 60, minZ: -60, maxZ: 60, flipX: false, flipZ: true },
                labs: { minX: -200, maxX: 200, minZ: -200, maxZ: 200, flipX: false, flipZ: true }
            };
            
            const bounds = mapBounds[mapKey];
            if (!bounds) {
                console.warn('No bounds defined for map:', mapKey);
                return null;
            }
            
            // Normalize to 0-1 range
            let normalizedX = (gameX - bounds.minX) / (bounds.maxX - bounds.minX);
            let normalizedZ = (gameZ - bounds.minZ) / (bounds.maxZ - bounds.minZ);
            
            // Apply flips if needed
            if (bounds.flipX) normalizedX = 1 - normalizedX;
            if (bounds.flipZ) normalizedZ = 1 - normalizedZ;
            
            // Clamp to 0-1 range
            normalizedX = Math.max(0, Math.min(1, normalizedX));
            normalizedZ = Math.max(0, Math.min(1, normalizedZ));
            
            // Convert to pixel coordinates
            const pixelX = normalizedX * currentMapWidth;
            const pixelY = normalizedZ * currentMapHeight;
            
            // For Leaflet with CRS.Simple, Y increases downward from top
            return {
                x: pixelX,
                y: currentMapHeight - pixelY
            };
        }

        // ============================================================================
        // MULTI-MAP TAB SYSTEM
        // ============================================================================
        
        function analyzeQuestMaps(selectedQuests) {
            const mapSet = new Set();
            const questsByMap = {};
            
            selectedQuests.forEach(quest => {
                // Check quest's main map - use mapNameToKey to normalize
                const questMapName = quest.map?.name;
                const questMapKey = questMapName ? mapNameToKey(questMapName) : null;
                
                // Check objectives for specific map requirements
                if (quest.objectives) {
                    quest.objectives.forEach(obj => {
                        if (obj.maps && obj.maps.length > 0) {
                            obj.maps.forEach(m => {
                                const mapKey = m.normalizedName || mapNameToKey(m.name);
                                if (mapKey && mapKey !== 'any') {
                                    mapSet.add(mapKey);
                                    if (!questsByMap[mapKey]) questsByMap[mapKey] = [];
                                    if (!questsByMap[mapKey].includes(quest.name)) {
                                        questsByMap[mapKey].push(quest.name);
                                    }
                                }
                            });
                        }
                    });
                }
                
                // If quest has a specific map (not "any"), add it
                if (questMapKey && questMapKey !== 'any') {
                    mapSet.add(questMapKey);
                    if (!questsByMap[questMapKey]) questsByMap[questMapKey] = [];
                    if (!questsByMap[questMapKey].includes(quest.name)) {
                        questsByMap[questMapKey].push(quest.name);
                    }
                }
            });
            
            console.log('Map analysis:', { maps: Array.from(mapSet), questsByMap });
            
            return {
                maps: Array.from(mapSet),
                questsByMap: questsByMap
            };
        }
        
        function setupMultiMapTabs(maps, questsByMap) {
            const tabsContainer = document.getElementById('multiMapTabs');
            const tabsInner = document.getElementById('mapTabsContainer');
            const mapSelect = document.getElementById('mapSelect');
            const mapHint = document.getElementById('mapHint');
            
            console.log('setupMultiMapTabs:', maps, questsByMap);
            
            if (maps.length <= 1) {
                // Single map mode - hide tabs, show dropdown
                tabsContainer.style.display = 'none';
                mapSelect.closest('.col-md-6')?.style.setProperty('display', '');
                if (mapHint) mapHint.style.display = 'block';
                multiMapMode = false;
                requiredMaps = [];
                return;
            }
            
            // Multi-map mode
            multiMapMode = true;
            requiredMaps = maps;
            tabsContainer.style.display = 'block';
            
            // Hide map dropdown and mapHint in multi-map mode
            mapSelect.closest('.col-md-6')?.style.setProperty('display', 'none');
            if (mapHint) mapHint.style.display = 'none';
            
            // Build tabs HTML
            const mapLabels = {
                customs: 'Customs',
                woods: 'Woods',
                shoreline: 'Shoreline',
                interchange: 'Interchange',
                reserve: 'Reserve',
                lighthouse: 'Lighthouse',
                streets: 'Streets',
                groundzero: 'Ground Zero',
                factory: 'Factory',
                labs: 'Labs'
            };
            
            let tabsHtml = '';
            maps.forEach((mapKey, idx) => {
                const questCount = questsByMap[mapKey]?.length || 0;
                const isActive = idx === 0;
                tabsHtml += `
                    <div class="map-tab ${isActive ? 'active' : ''}" data-map="${mapKey}" onclick="switchMapTab('${mapKey}')">
                        ${mapLabels[mapKey] || mapKey}
                        <span class="tab-quest-count">${questCount}</span>
                    </div>
                `;
                
                // Initialize per-map layer settings
                if (!perMapLayerSettings[mapKey]) {
                    perMapLayerSettings[mapKey] = { scav: false, sniper: false, pmc: false, boss: false };
                }
            });
            
            tabsInner.innerHTML = tabsHtml;
            
            // Set first map as active
            activeMapTab = maps[0];
            
            // Show "Apply to All" button
            const applyAllBtn = document.querySelector('.btn-apply-all');
            if (applyAllBtn) applyAllBtn.style.display = 'none'; // Hidden until user changes settings
        }
        
        async function switchMapTab(mapKey) {
            // Update tab UI
            document.querySelectorAll('.map-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.map === mapKey);
            });
            
            activeMapTab = mapKey;
            
            // Restore overlay settings for this map
            if (perMapLayerSettings[mapKey]) {
                Object.entries(perMapLayerSettings[mapKey]).forEach(([overlay, enabled]) => {
                    if (overlayLayers[overlay]) {
                        overlayLayers[overlay].enabled = enabled;
                        const checkbox = document.getElementById('overlay-' + overlay.replace('_', '-'));
                        if (checkbox) checkbox.checked = enabled;
                    }
                });
            }
            
            // Reload map with new content
            await initMap(mapKey, selectedQuestNamesForMarkers, selectedQuestsForMarkers);
            
            // Render overlay markers for new map
            await renderOverlayMarkers();
        }
        
        function resetMultiMapMode() {
            multiMapMode = false;
            activeMapTab = null;
            requiredMaps = [];
            perMapLayerSettings = {};
            
            const tabsContainer = document.getElementById('multiMapTabs');
            if (tabsContainer) tabsContainer.style.display = 'none';
            
            const mapSelect = document.getElementById('mapSelect');
            mapSelect?.closest('.col-md-6')?.style.setProperty('display', '');
            
            // Show mapHint again in single-map mode
            const mapHint = document.getElementById('mapHint');
            if (mapHint) mapHint.style.display = 'block';
            
            // Hide "Apply to All" button
            const applyAllBtn = document.querySelector('.btn-apply-all');
            if (applyAllBtn) applyAllBtn.style.display = 'none';
            
            // Reset overlay toggles
            Object.keys(overlayLayers).forEach(overlay => {
                overlayLayers[overlay].enabled = false;
                const checkbox = document.getElementById('overlay-' + overlay.replace('_', '-'));
                if (checkbox) checkbox.checked = false;
            });
        }

        // ============================================================================
        // QUEST ITEM TRACKER
        // ============================================================================
        
        // Storage for collected quest items: { "questId:itemId": collectedCount }
        let collectedQuestItems = {};
        
        function loadCollectedQuestItems() {
            const saved = localStorage.getItem(STORAGE_KEY_QUEST_ITEMS);
            collectedQuestItems = saved ? JSON.parse(saved) : {};
        }
        
        function saveCollectedQuestItems() {
            localStorage.setItem(STORAGE_KEY_QUEST_ITEMS, JSON.stringify(collectedQuestItems));
        }
        
        function getCollectedCount(questId, itemId) {
            const key = `${questId}:${itemId}`;
            return collectedQuestItems[key] || 0;
        }
        
        function setCollectedCount(questId, itemId, count, maxCount) {
            const key = `${questId}:${itemId}`;
            const clampedCount = Math.max(0, Math.min(count, maxCount));
            collectedQuestItems[key] = clampedCount;
            saveCollectedQuestItems();
            return clampedCount;
        }
        
        function toggleItemCollected(questId, itemId, maxCount) {
            const current = getCollectedCount(questId, itemId);
            const newCount = current >= maxCount ? 0 : maxCount;
            setCollectedCount(questId, itemId, newCount, maxCount);
            updateTrackerItem(questId, itemId, newCount, maxCount);
            updateTrackerProgress();
        }
        
        function updateCollectedInput(questId, itemId, value, maxCount) {
            const newCount = setCollectedCount(questId, itemId, parseInt(value) || 0, maxCount);
            updateTrackerItem(questId, itemId, newCount, maxCount);
            updateTrackerProgress();
        }
        
        function updateTrackerItem(questId, itemId, collected, maxCount) {
            const itemEl = document.querySelector(`[data-tracker-item="${questId}:${itemId}"]`);
            if (itemEl) {
                const isComplete = collected >= maxCount;
                itemEl.classList.toggle('collected', isComplete);
                
                const checkbox = itemEl.querySelector('.item-checkbox');
                if (checkbox) checkbox.checked = isComplete;
                
                const input = itemEl.querySelector('.collected-input input');
                if (input) input.value = collected;
            }
            
            // Update quest group header count
            updateQuestGroupProgress(questId);
        }
        
        function updateQuestGroupProgress(questId) {
            const groupEl = document.querySelector(`[data-quest-group="${questId}"]`);
            if (!groupEl) return;
            
            const items = groupEl.querySelectorAll('.tracker-item');
            let completed = 0;
            let total = items.length;
            
            items.forEach(item => {
                if (item.classList.contains('collected')) completed++;
            });
            
            const countEl = groupEl.querySelector('.quest-item-count');
            if (countEl) {
                countEl.textContent = `${completed}/${total}`;
                countEl.style.color = completed === total ? 'var(--eft-green)' : 'var(--text-sub)';
            }
        }
        
        function updateTrackerProgress() {
            const container = document.getElementById('quest-item-tracker');
            if (!container) return;
            
            const allItems = container.querySelectorAll('.tracker-item');
            let completed = 0;
            let total = allItems.length;
            
            allItems.forEach(item => {
                if (item.classList.contains('collected')) completed++;
            });
            
            document.getElementById('tracker-progress').textContent = `${completed}/${total}`;
            document.getElementById('tracker-progress-bar').style.width = total > 0 ? `${(completed / total) * 100}%` : '0%';
        }
        
        function toggleQuestItemsGroup(questId) {
            const groupEl = document.querySelector(`[data-quest-group="${questId}"]`);
            if (!groupEl) return;
            
            const listEl = groupEl.querySelector('.quest-items-list');
            if (listEl) {
                listEl.classList.toggle('collapsed');
            }
        }
        
        function renderQuestItemTracker(questItemsData) {
            const container = document.getElementById('quest-item-tracker');
            const section = document.getElementById('quest-item-tracker-section');
            
            // Load saved progress
            loadCollectedQuestItems();
            
            if (!questItemsData || questItemsData.length === 0) {
                // Hide entire section when no items needed
                if (section) section.style.display = 'none';
                return;
            }
            
            // Show section
            if (section) section.style.display = '';
            
            let html = '';
            let totalItems = 0;
            let totalCompleted = 0;
            
            questItemsData.forEach((quest, qIndex) => {
                const color = QUEST_COLORS[qIndex % QUEST_COLORS.length];
                
                // Calculate quest completion
                let questCompleted = 0;
                quest.items.forEach(item => {
                    const collected = getCollectedCount(quest.questId, item.id);
                    if (collected >= item.count) questCompleted++;
                });
                
                totalItems += quest.items.length;
                totalCompleted += questCompleted;
                
                html += `
                    <div class="quest-items-group" data-quest-group="${quest.questId}">
                        <div class="quest-items-header" onclick="toggleQuestItemsGroup('${quest.questId}')">
                            <div class="quest-color" style="background: ${color.fill}; border-color: ${color.border};"></div>
                            <span class="quest-name">${quest.questName}</span>
                            <span class="quest-item-count" style="color: ${questCompleted === quest.items.length ? 'var(--eft-green)' : 'var(--text-sub)'}">
                                ${questCompleted}/${quest.items.length}
                            </span>
                        </div>
                        <div class="quest-items-list">
                `;
                
                quest.items.forEach(item => {
                    const collected = getCollectedCount(quest.questId, item.id);
                    const isComplete = collected >= item.count;
                    
                    // Determine badge type
                    let badgeHtml = '';
                    if (item.isProvided) {
                        badgeHtml = '<span class="given-badge">GIVEN</span>';
                    } else if (item.foundInRaid) {
                        badgeHtml = '<span class="fir-badge">FIR</span>';
                    } else {
                        badgeHtml = '<span class="handover-badge">HAND-OVER</span>';
                    }
                    
                    html += `
                        <div class="tracker-item ${isComplete ? 'collected' : ''}" data-tracker-item="${quest.questId}:${item.id}">
                            <input type="checkbox" class="item-checkbox" 
                                ${isComplete ? 'checked' : ''} 
                                ${item.isProvided ? 'disabled' : ''}
                                onchange="toggleItemCollected('${quest.questId}', '${item.id}', ${item.count})">
                            ${item.icon ? `<img src="${item.icon}" alt="${item.shortName}">` : ''}
                            <div class="item-info">
                                <div class="item-name">${item.shortName}</div>
                                <div class="item-meta">
                                    ${badgeHtml}
                                    <span class="item-count">${item.count}x needed</span>
                                </div>
                            </div>
                            ${!item.isProvided ? `
                                <div class="collected-input">
                                    <input type="number" min="0" max="${item.count}" value="${collected}" 
                                        onchange="updateCollectedInput('${quest.questId}', '${item.id}', this.value, ${item.count})"
                                        onclick="event.stopPropagation()">
                                    <span>/ ${item.count}</span>
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            container.innerHTML = html;
            
            // Update global progress
            document.getElementById('tracker-progress').textContent = `${totalCompleted}/${totalItems}`;
            document.getElementById('tracker-progress-bar').style.width = totalItems > 0 ? `${(totalCompleted / totalItems) * 100}%` : '0%';
        }

        // ============================================================================
        // KEYBOARD SHORTCUTS
        // ============================================================================
        
        let shortcutsHelpVisible = false;
        
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger if typing in input/textarea
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                // Tab switching: 1-6
                if (e.key >= '1' && e.key <= '6' && !e.ctrlKey && !e.altKey) {
                    const tabs = ['planner', 'penetration', 'ammo', 'weapons', 'gear', 'attachments'];
                    const tabIndex = parseInt(e.key) - 1;
                    if (tabIndex < tabs.length) {
                        switchTab(tabs[tabIndex]);
                        e.preventDefault();
                    }
                }
                
                // Ctrl+E: Export
                if (e.key === 'e' && e.ctrlKey) {
                    exportConfig();
                    e.preventDefault();
                }
                
                // Ctrl+I: Import
                if (e.key === 'i' && e.ctrlKey) {
                    showImportModal();
                    e.preventDefault();
                }
                
                // Ctrl+F: Focus search
                if (e.key === 'f' && e.ctrlKey) {
                    const activeTab = document.querySelector('.tab-content.active');
                    const searchInput = activeTab?.querySelector('input[type="text"][placeholder*="earch"]');
                    if (searchInput) {
                        searchInput.focus();
                        e.preventDefault();
                    }
                }
                
                // ?: Toggle shortcuts help
                if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
                    toggleShortcutsHelp();
                    e.preventDefault();
                }
                
                // Ctrl+Shift+E: Toggle Edit Mode
                if (e.key === 'E' && e.ctrlKey && e.shiftKey) {
                    toggleEditMode();
                    e.preventDefault();
                }
                
                // Escape: Close modals
                if (e.key === 'Escape') {
                    hideExportModal();
                    hideImportModal();
                    hideLoginModal();
                    hideShortcutsHelp();
                }
            });
        }
        
        function toggleShortcutsHelp() {
            let help = document.getElementById('shortcutsHelp');
            if (!help) {
                help = document.createElement('div');
                help.id = 'shortcutsHelp';
                help.className = 'shortcuts-help';
                help.innerHTML = `
                    <div style="margin-bottom: 5px; color: var(--text-beige); display: flex; justify-content: space-between; align-items: center;">
                        <span>‚å®Ô∏è Shortcuts</span>
                        <span onclick="toggleShortcutsHelp()" style="cursor: pointer; opacity: 0.6; font-size: 1rem;">‚úï</span>
                    </div>
                    <div><kbd>1</kbd>-<kbd>6</kbd> Switch tabs</div>
                    <div><kbd>Ctrl</kbd>+<kbd>E</kbd> Export</div>
                    <div><kbd>Ctrl</kbd>+<kbd>I</kbd> Import</div>
                    <div><kbd>Ctrl</kbd>+<kbd>F</kbd> Search</div>
                    <div><kbd>?</kbd> Toggle this help</div>
                `;
                document.body.appendChild(help);
            }
            shortcutsHelpVisible = !shortcutsHelpVisible;
            help.style.display = shortcutsHelpVisible ? 'block' : 'none';
        }
        
        function initShortcutsHelp() {
            // Create and show shortcuts help on load
            toggleShortcutsHelp();
        }
        
        function hideShortcutsHelp() {
            const help = document.getElementById('shortcutsHelp');
            if (help) help.style.display = 'none';
            shortcutsHelpVisible = false;
        }

        // ============================================================================
        // BULK SELECT MODE
        // ============================================================================
        
        let bulkMode = { ammo: false, weapons: false, gear: false, attachments: false };
        let bulkSelected = { ammo: new Set(), weapons: new Set(), gear: new Set(), attachments: new Set() };
        
        function toggleBulkMode(category) {
            bulkMode[category] = !bulkMode[category];
            bulkSelected[category].clear();
            
            const container = document.getElementById(`tab-${category}`);
            container.classList.toggle('bulk-mode', bulkMode[category]);
            
            // Update button text
            const btn = document.getElementById(`bulk-toggle-${category}`);
            if (btn) btn.textContent = bulkMode[category] ? 'Exit Bulk Select' : 'Bulk Select';
            
            renderCategoryList(category);
        }
        
        function toggleBulkItem(category, id, event) {
            if (event) event.stopPropagation();
            
            if (bulkSelected[category].has(id)) {
                bulkSelected[category].delete(id);
            } else {
                bulkSelected[category].add(id);
            }
            
            updateBulkCount(category);
        }
        
        function updateBulkCount(category) {
            const countEl = document.getElementById(`bulk-count-${category}`);
            if (countEl) countEl.textContent = bulkSelected[category].size + ' selected';
        }
        
        function bulkMarkOwned(category) {
            const ownedSet = category === 'ammo' ? ownedAmmo : 
                            category === 'weapons' ? ownedWeapons :
                            category === 'gear' ? ownedGear : ownedAttachments;
            
            bulkSelected[category].forEach(id => ownedSet.add(id));
            bulkSelected[category].clear();
            
            // Save
            if (category === 'ammo') saveOwnedAmmo();
            if (category === 'weapons') saveOwnedWeapons();
            if (category === 'gear') saveOwnedGear();
            if (category === 'attachments') saveOwnedAttachments();
            
            renderCategoryList(category);
            updateDashboard();
        }
        
        function bulkUnmarkOwned(category) {
            const ownedSet = category === 'ammo' ? ownedAmmo : 
                            category === 'weapons' ? ownedWeapons :
                            category === 'gear' ? ownedGear : ownedAttachments;
            
            bulkSelected[category].forEach(id => ownedSet.delete(id));
            bulkSelected[category].clear();
            
            // Save
            if (category === 'ammo') saveOwnedAmmo();
            if (category === 'weapons') saveOwnedWeapons();
            if (category === 'gear') saveOwnedGear();
            if (category === 'attachments') saveOwnedAttachments();
            
            renderCategoryList(category);
            updateDashboard();
        }
        
        function bulkSelectAll(category) {
            const data = category === 'ammo' ? allAmmoData?.all :
                        category === 'weapons' ? allWeaponsData?.all :
                        category === 'gear' ? allGearData?.all : allAttachmentsData?.all;
            
            if (data) {
                // Select all visible items (apply current filters)
                const visibleItems = document.querySelectorAll(`#tab-${category} .ammo-card, #tab-${category} .weapon-card, #tab-${category} .gear-card, #tab-${category} .attachment-card`);
                visibleItems.forEach(el => {
                    const id = el.dataset.id || el.getAttribute('onclick')?.match(/'([^']+)'/)?.[1];
                    if (id) bulkSelected[category].add(id);
                });
            }
            updateBulkCount(category);
            renderCategoryList(category);
        }
        
        function bulkDeselectAll(category) {
            bulkSelected[category].clear();
            updateBulkCount(category);
            renderCategoryList(category);
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        // ============================================================================
        // APP INITIALIZATION WITH LOADING SCREEN
        // ============================================================================
        
        async function initApp() {
            const loadingScreen = document.getElementById('globalLoadingScreen');
            const loadingStatus = document.getElementById('loadingStatus');
            const loadingProgress = document.getElementById('loadingProgressBar');
            const loadingDetails = document.getElementById('loadingDetails');
            
            const tasks = [
                { name: 'Authentication', fn: initAuth },
                { name: 'Configuration', fn: async () => { loadTierData(); initTierConfigUI(); } },
                { name: 'Shortcuts', fn: async () => { initKeyboardShortcuts(); initShortcutsHelp(); } },
                { name: 'Local Data', fn: async () => { loadSavedAmmo(); loadCollectedQuestItems(); } },
                { name: 'Quest Locations', fn: loadQuestLocationsData },
                { name: 'Quests', fn: loadQuests },
                { name: 'Hideout Data', fn: loadHideoutData },
                { name: 'Ammo Database', fn: loadAmmoData },
                { name: 'Weapons Database', fn: loadWeaponsData },
                { name: 'Gear Database', fn: loadGearData },
                { name: 'Attachments Database', fn: loadAttachmentsData },
            ];
            
            let completed = 0;
            const total = tasks.length;
            
            for (const task of tasks) {
                try {
                    loadingStatus.textContent = `Loading ${task.name}...`;
                    loadingDetails.innerHTML = `<span class="loading-item active">‚è≥ ${task.name}</span>`;
                    
                    await task.fn();
                    
                    completed++;
                    const progress = Math.round((completed / total) * 100);
                    loadingProgress.style.width = progress + '%';
                    
                    loadingDetails.innerHTML = `<span class="loading-item done">‚úì ${task.name}</span>`;
                } catch (err) {
                    console.error(`Error loading ${task.name}:`, err);
                    loadingDetails.innerHTML = `<span class="loading-item error">‚úó ${task.name} (failed)</span>`;
                    // Continue with other tasks even if one fails
                    completed++;
                    const progress = Math.round((completed / total) * 100);
                    loadingProgress.style.width = progress + '%';
                }
            }
            
            // Final setup
            loadingStatus.textContent = 'Initializing map...';
            updateMapSelection();
            await initMap('customs', []);
            updateDashboard();
            
            // Show refresh buttons
            document.getElementById('btn-load-ammo').style.display = 'block';
            document.getElementById('btn-load-weapons').style.display = 'block';
            document.getElementById('btn-load-gear').style.display = 'block';
            document.getElementById('btn-load-attachments').style.display = 'block';
            
            // Hide loading screen
            loadingProgress.style.width = '100%';
            loadingStatus.textContent = 'Ready!';
            
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 300);
        }
        
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
