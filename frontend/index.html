
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarkov Raid Planner v4.0</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root { --bg-black: #0a0a0a; --bg-dark: #0e0e0e; --bg-panel: #121212; --bg-element: #1a1a1a; --bg-hover: #252525; --border-dark: #2a2a2a; --border-gold: #9e8f6b; --text-main: #d0d0d0; --text-sub: #888; --text-beige: #d2c4a6; --eft-gold: #9e8f6b; --eft-gold-bright: #c4b896; --eft-red: #8c3b3b; --eft-green: #4a7a4a; --eft-blue: #4a6a8a; --tier-s: #ffd700; --tier-a: #c0c0c0; --tier-b: #cd7f32; --tier-c: #5a9e5a; --tier-d: #5a7a9e; --tier-f: #9e5a5a; }
        * { box-sizing: border-box; }
        body { background-color: var(--bg-black); color: var(--text-main); font-family: 'Rajdhani', 'Segoe UI', sans-serif; font-size: 0.95rem; line-height: 1.5; min-height: 100vh; }
        h1, h2, h3, h4, h5 { color: var(--text-beige); font-family: 'Rajdhani', sans-serif; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; }
        .text-beige { color: var(--text-beige) !important; } .text-sub { color: var(--text-sub) !important; } .text-gold { color: var(--eft-gold) !important; }
        .container { max-width: 1500px; margin-top: 20px; }
        
        /* Header with status indicator */
        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .header-row h1 { margin: 0; font-size: 1.8rem; }
        .status-indicator { display: flex; align-items: center; gap: 10px; background: var(--bg-element); border: 1px solid var(--border-dark); padding: 8px 15px; font-size: 0.85rem; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--eft-green); animation: pulse 2s infinite; }
        .status-dot.offline { background: var(--eft-red); animation: none; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .nav-tabs-tarkov { border-bottom: 2px solid var(--border-gold); margin-bottom: 30px; display: flex; gap: 0; }
        .nav-tab { background: var(--bg-panel); border: 1px solid var(--border-dark); border-bottom: none; color: var(--text-sub); padding: 15px 40px; font-family: 'Rajdhani', sans-serif; font-size: 1.1rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; cursor: pointer; transition: all 0.2s ease; position: relative; top: 2px; }
        .nav-tab:hover { background: var(--bg-element); color: var(--text-beige); }
        .nav-tab.active { background: var(--bg-dark); color: var(--text-beige); border-color: var(--border-gold); border-bottom: 2px solid var(--bg-dark); }
        .tab-content { display: none; } .tab-content.active { display: block; }
        .tarkov-panel { background: var(--bg-panel); border: 1px solid var(--border-dark); border-radius: 0; padding: 20px; margin-bottom: 20px; }
        .tarkov-panel h5 { border-bottom: 1px solid var(--border-gold); padding-bottom: 10px; margin-bottom: 15px; font-size: 1rem; }
        .btn-tarkov { background: linear-gradient(180deg, var(--bg-element) 0%, var(--bg-dark) 100%); border: 1px solid var(--border-gold); color: var(--text-beige); font-family: 'Rajdhani', sans-serif; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; padding: 10px 20px; transition: all 0.2s ease; }
        .btn-tarkov:hover { background: linear-gradient(180deg, var(--bg-hover) 0%, var(--bg-element) 100%); color: var(--eft-gold-bright); border-color: var(--eft-gold-bright); }
        .btn-tarkov:disabled { opacity: 0.5; cursor: not-allowed; }
        .trader-group { background: var(--bg-element); border: 1px solid var(--border-dark); margin-bottom: 10px; }
        .trader-header { display: flex; align-items: center; gap: 15px; padding: 15px; cursor: pointer; transition: background 0.2s; }
        .trader-header:hover { background: var(--bg-hover); }
        .trader-header img { width: 50px; height: 50px; border-radius: 0; border: 1px solid var(--border-gold); }
        .trader-header h6 { margin: 0; font-size: 1.1rem; flex-grow: 1; }
        .trader-quests { display: none; padding: 0 15px 15px; }
        .trader-quests.show { display: block; }
        .quest-row { display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg-dark); border: 1px solid var(--border-dark); margin-bottom: 6px; cursor: pointer; transition: all 0.15s ease; }
        .quest-row:hover { background: var(--bg-hover); border-color: var(--eft-gold); }
        .quest-row.selected { background: rgba(158, 143, 107, 0.15); border-color: var(--eft-gold); }
        .quest-row input[type="checkbox"] { width: 18px; height: 18px; accent-color: var(--eft-gold); cursor: pointer; flex-shrink: 0; }
        .quest-info { flex-grow: 1; min-width: 0; }
        .quest-name { font-weight: 600; color: var(--text-beige); font-size: 0.95rem; }
        .quest-name a { color: inherit; text-decoration: none; }
        .quest-name a:hover { text-decoration: underline; color: var(--eft-gold-bright); }
        .quest-meta { font-size: 0.8rem; color: var(--text-sub); display: flex; gap: 15px; flex-wrap: wrap; }
        .badge-tarkov { background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-sub); padding: 4px 10px; font-size: 0.75rem; font-weight: 600; }
        .badge-active { background: rgba(158, 143, 107, 0.2); border-color: var(--eft-gold); color: var(--eft-gold); }
        .form-select-tarkov, .form-control-tarkov { background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-main); padding: 10px 15px; font-family: 'Rajdhani', sans-serif; }
        .form-select-tarkov:focus, .form-control-tarkov:focus { background: var(--bg-hover); border-color: var(--eft-gold); color: var(--text-main); box-shadow: none; outline: none; }
        .form-select-tarkov option { background: var(--bg-dark); color: var(--text-main); }
        .form-select-tarkov option:disabled { color: var(--text-sub); opacity: 0.5; }
        #map { height: 600px; background: var(--bg-dark); border: 1px solid var(--border-dark); }
        .map-controls { display: flex; align-items: center; gap: 15px; padding: 10px 15px; background: var(--bg-element); border: 1px solid var(--border-dark); border-bottom: none; font-size: 0.85rem; color: var(--text-sub); }
        .map-controls .btn-tarkov { padding: 5px 12px; font-size: 0.8rem; }
        .marker-count { margin-left: auto; color: var(--eft-gold); font-weight: 600; }
        .map-hint { padding: 8px 15px; background: rgba(158, 143, 107, 0.1); border: 1px solid var(--border-dark); border-top: none; font-size: 0.8rem; color: var(--eft-gold); }
        .map-hint.warning { background: rgba(140, 59, 59, 0.15); color: var(--eft-red); }
        .leaflet-container { background: var(--bg-dark); }
        .map-legend { background: var(--bg-element); border: 1px solid var(--border-dark); border-top: none; padding: 10px 15px; }
        .legend-title { font-weight: 600; color: var(--text-beige); font-size: 0.85rem; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .legend-items { display: flex; flex-wrap: wrap; gap: 12px; }
        .legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.8rem; color: var(--text-main); }
        .legend-color { width: 16px; height: 16px; border-radius: 50%; border: 2px solid; flex-shrink: 0; }
        .marker-label { background: rgba(0,0,0,0.85) !important; border: 1px solid var(--eft-gold) !important; color: var(--text-beige) !important; font-family: 'Rajdhani', sans-serif !important; padding: 5px 10px !important; border-radius: 0 !important; }
        .quest-marker-popup { min-width: 200px; max-width: 280px; }
        .quest-marker-popup h6 { color: var(--eft-gold); margin-bottom: 8px; font-size: 0.9rem; }
        .quest-marker-popup p { margin: 0; font-size: 0.85rem; color: var(--text-main); }
        .quest-marker-popup .obj-type { display: inline-block; padding: 2px 8px; font-size: 0.7rem; text-transform: uppercase; margin-bottom: 5px; }
        .quest-marker-popup .obj-num { display: inline-block; background: var(--eft-gold); color: #000; font-weight: 700; padding: 2px 6px; font-size: 0.7rem; margin-right: 5px; }
        .obj-pickup { background: #2d5a2d; color: #7fff7f; }
        .obj-place { background: #5a5a2d; color: #ffff7f; }
        .obj-mark { background: #5a2d5a; color: #ff7fff; }
        .obj-find { background: #2d5a5a; color: #7fffff; }
        .obj-kill { background: #5a2d2d; color: #ff7f7f; }
        .obj-locate { background: #2d2d5a; color: #7f7fff; }
        .marker-number { position: absolute; top: -8px; right: -8px; background: var(--eft-gold); color: #000; font-weight: 700; font-size: 0.65rem; width: 16px; height: 16px; line-height: 16px; text-align: center; border-radius: 50%; }
        .quest-marker-icon { background: transparent !important; border: none !important; }
        .item-box { display: flex; align-items: center; gap: 10px; background: var(--bg-dark); border: 1px solid var(--border-dark); padding: 8px 12px; margin-bottom: 6px; }
        .item-box img { width: 40px; height: 40px; object-fit: contain; }
        .item-label { font-size: 0.65rem; padding: 2px 6px; font-weight: 700; letter-spacing: 1px; }
        .label-find { background: var(--eft-red); color: #fff; }
        .label-given { background: var(--eft-green); color: #fff; }
        .status-provided { border-left: 3px solid var(--eft-green); }
        .status-acquire { border-left: 3px solid var(--eft-red); }
        .unlock-card { background: var(--bg-dark); border: 1px solid var(--border-dark); padding: 12px; margin-bottom: 8px; }
        .unlock-link { color: var(--eft-gold); text-decoration: none; }
        .unlock-link:hover { color: var(--eft-gold-bright); text-decoration: underline; }
        .quest-objectives-group { background: var(--bg-dark); border: 1px solid var(--border-dark); margin-bottom: 10px; padding: 12px; }
        .quest-objectives-header { display: flex; align-items: center; gap: 8px; font-weight: 600; color: var(--text-beige); margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid var(--border-dark); }
        .quest-objectives-list { list-style: none; padding: 0; margin: 0; }
        .quest-objectives-list li { color: var(--text-sub); font-size: 0.9rem; padding: 4px 0; padding-left: 22px; position: relative; }
        .quest-objectives-list .obj-index { position: absolute; left: 0; color: var(--eft-gold); font-weight: 600; }
        .caliber-group { margin-bottom: 20px; }
        .caliber-header { background: var(--bg-element); border: 1px solid var(--border-dark); padding: 10px 15px; font-weight: 600; color: var(--text-beige); margin-bottom: 5px; }
        .ammo-card { display: flex; align-items: center; gap: 10px; background: var(--bg-dark); border: 1px solid var(--border-dark); padding: 10px 12px; margin-bottom: 4px; cursor: pointer; transition: all 0.15s ease; }
        .ammo-card:hover { background: var(--bg-hover); border-color: var(--eft-gold); }
        .ammo-card.owned { background: rgba(74, 122, 74, 0.15); border-color: var(--eft-green); }
        .ammo-card img { width: 45px; height: 45px; object-fit: contain; }
        .ammo-stats { display: flex; gap: 12px; font-size: 0.8rem; color: var(--text-sub); margin-top: 3px; }
        .stat-dmg { color: #e07050; }
        .stat-pen { color: #50a0e0; }
        .stat-price { color: var(--eft-gold); }
        .stat-highlight { font-weight: 700; text-decoration: underline; }
        .tier-source { font-size: 0.65rem; font-weight: 700; padding: 2px 6px; border-radius: 2px; text-transform: uppercase; }
        .source-pen { background: rgba(80, 160, 224, 0.2); color: #50a0e0; }
        .source-dmg { background: rgba(224, 112, 80, 0.2); color: #e07050; }
        .source-both { background: rgba(158, 143, 107, 0.2); color: var(--eft-gold); }
        .tier-badge { display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; font-weight: 700; font-size: 0.85rem; border-radius: 0; flex-shrink: 0; }
        .tier-S { background: linear-gradient(135deg, #ffd700 0%, #b8860b 100%); color: #000; }
        .tier-A { background: linear-gradient(135deg, #e0e0e0 0%, #a0a0a0 100%); color: #000; }
        .tier-B { background: linear-gradient(135deg, #cd7f32 0%, #8b4513 100%); color: #fff; }
        .tier-C { background: linear-gradient(135deg, #5a9e5a 0%, #3a6e3a 100%); color: #fff; }
        .tier-D { background: linear-gradient(135deg, #5a7a9e 0%, #3a5a7e 100%); color: #fff; }
        .tier-F { background: linear-gradient(135deg, #9e5a5a 0%, #7e3a3a 100%); color: #fff; }
        .analysis-panel { display: flex; gap: 20px; }
        .analysis-col { flex: 1; }
        .analysis-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; background: var(--bg-element); border: 1px solid var(--border-dark); margin-bottom: 10px; }
        .analysis-header h6 { margin: 0; font-size: 0.9rem; }
        .analysis-list { max-height: 300px; overflow-y: auto; }
        .search-box { position: relative; margin-bottom: 15px; }
        .search-box input { width: 100%; padding-right: 35px; }
        .loading-spinner { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px; color: var(--text-sub); }
        .spinner { width: 40px; height: 40px; border: 3px solid var(--border-dark); border-top-color: var(--eft-gold); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Tier Editor Styles */
        .tier-config { margin-bottom: 20px; }
        .tier-config-row { display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: var(--bg-dark); border: 1px solid var(--border-dark); margin-bottom: 4px; }
        .tier-config-row .tier-badge { flex-shrink: 0; }
        .tier-config-row label { font-size: 0.8rem; color: var(--text-sub); min-width: 80px; }
        .tier-config-row input[type="number"] { width: 70px; background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-main); padding: 4px 8px; font-family: 'Rajdhani', sans-serif; text-align: center; }
        .tier-config-row input[type="number"]:focus { border-color: var(--eft-gold); outline: none; }
        .tier-override { position: relative; }
        .tier-override-btn { position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-sub); cursor: pointer; padding: 2px 6px; font-size: 0.7rem; }
        .tier-override-btn:hover { color: var(--eft-gold); }
        .ammo-card.overridden { border-left: 3px solid var(--eft-gold); }
        .override-indicator { font-size: 0.65rem; color: var(--eft-gold); margin-left: auto; }
        .tier-select-mini { background: var(--bg-element); border: 1px solid var(--border-dark); color: var(--text-main); padding: 2px 6px; font-size: 0.75rem; cursor: pointer; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-row">
            <h1>Tarkov Raid Planner</h1>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Connecting...</span>
            </div>
        </div>
        
        <div class="nav-tabs-tarkov">
            <div class="nav-tab active" onclick="switchTab('planner')">Mission Planner</div>
            <div class="nav-tab" onclick="switchTab('ammo')">Ammo</div>
            <div class="nav-tab" onclick="switchTab('weapons')">Weapons</div>
            <div class="nav-tab" onclick="switchTab('gear')">Gear</div>
            <div class="nav-tab" onclick="switchTab('attachments')">Attachments</div>
        </div>

        <!-- MISSION PLANNER TAB -->
        <div id="tab-planner" class="tab-content active">
            <div class="row">
                <div class="col-lg-5">
                    <div class="tarkov-panel">
                        <h5>Select Operations</h5>
                        <div class="search-box">
                            <input type="text" class="form-control-tarkov w-100" placeholder="Search quests..." id="questSearch" oninput="filterQuests()">
                        </div>
                        <div id="quest-loading" class="loading-spinner">
                            <div class="spinner"></div>
                            <div>Loading intel from command...</div>
                        </div>
                        <div id="quest-list" class="d-none" style="max-height: 500px; overflow-y: auto;"></div>
                        <div id="quest-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-7">
                    <div class="tarkov-panel">
                        <h5>Tactical Map</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-6">
                                <select id="mapSelect" class="form-select-tarkov w-100" onchange="onMapChange()">
                                    <option value="customs">Customs</option>
                                    <option value="factory">Factory</option>
                                    <option value="groundzero">Ground Zero</option>
                                    <option value="interchange">Interchange</option>
                                    <option value="labs">The Lab</option>
                                    <option value="lighthouse">Lighthouse</option>
                                    <option value="reserve">Reserve</option>
                                    <option value="shoreline">Shoreline</option>
                                    <option value="streets">Streets of Tarkov</option>
                                    <option value="woods">Woods</option>
                                </select>
                            </div>
                            <div class="col-md-6">
                                <button class="btn-tarkov w-100" onclick="planRaid()">Plan Raid</button>
                            </div>
                        </div>
                        <div id="mapHint" class="map-hint" style="display: none;"></div>
                        <div class="map-controls">
                            <span>Scroll to zoom | Drag to pan | Click markers for details</span>
                            <span class="marker-count" id="markerCount">0 markers</span>
                            <button class="btn-tarkov" onclick="resetMapView()">Reset View</button>
                        </div>
                        <div id="map"></div>
                        <div id="mapLegend" class="map-legend" style="display: none;">
                            <div class="legend-title">Quest Colors</div>
                            <div id="legendItems" class="legend-items"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="planning-result" class="tarkov-panel" style="display: none;">
                <h5>Mission Briefing</h5>
                <div class="row">
                    <div class="col-md-4">
                        <h6 class="text-beige mb-3">Required Keys</h6>
                        <div id="required-keys"></div>
                    </div>
                    <div class="col-md-4">
                        <h6 class="text-beige mb-3">Required Items</h6>
                        <div id="required-items"></div>
                    </div>
                    <div class="col-md-4">
                        <h6 class="text-beige mb-3">Unlocks</h6>
                        <div id="progression-list"></div>
                    </div>
                </div>
                <h6 class="text-beige mt-4 mb-3">Objectives</h6>
                <ul id="mission-steps" class="list-group list-group-flush" style="max-height: 250px; overflow-y: auto;"></ul>
            </div>
        </div>

        <!-- AMMO MANAGER TAB -->
        <div id="tab-ammo" class="tab-content">
            <div class="row">
                <div class="col-lg-8">
                    <div class="tarkov-panel">
                        <h5>Ammunition Database</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-4">
                                <select id="caliberFilter" class="form-select-tarkov w-100" onchange="filterAmmoByCaliber()">
                                    <option value="ALL">All Calibers</option>
                                </select>
                            </div>
                            <div class="col-md-5">
                                <div class="search-box">
                                    <input type="text" class="form-control-tarkov w-100" placeholder="Search ammo..." id="ammoSearch" oninput="filterAmmoBySearch()">
                                </div>
                            </div>
                            <div class="col-md-3">
                                <button id="btn-load-ammo" class="btn-tarkov w-100" onclick="loadAmmoData()">Load Data</button>
                            </div>
                        </div>
                        <div class="text-sub small mb-3">Click ammo to mark as owned | <span id="ammo-count">0</span> loaded</div>
                        <div id="ammo-loading" class="loading-spinner d-none">
                            <div class="spinner"></div>
                            <div>Loading ammunition data...</div>
                        </div>
                        <div id="ammo-content" class="d-none">
                            <div id="ammo-list" style="max-height: 500px; overflow-y: auto;"></div>
                        </div>
                        <div id="ammo-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="tarkov-panel">
                        <h5>Tier Configuration</h5>
                        <div class="tier-config" id="tierConfig">
                            <div class="tier-config-section">
                                <div class="text-sub small mb-2">Penetration thresholds:</div>
                                <div class="tier-config-row">
                                    <span class="tier-badge tier-S">S</span>
                                    <label>Min Pen:</label>
                                    <input type="number" id="tierThresholdS" value="55" min="0" max="100" onchange="updateTierConfig()">
                                </div>
                                <div class="tier-config-row">
                                    <span class="tier-badge tier-A">A</span>
                                    <label>Min Pen:</label>
                                    <input type="number" id="tierThresholdA" value="45" min="0" max="100" onchange="updateTierConfig()">
                                </div>
                                <div class="tier-config-row">
                                    <span class="tier-badge tier-B">B</span>
                                    <label>Min Pen:</label>
                                    <input type="number" id="tierThresholdB" value="35" min="0" max="100" onchange="updateTierConfig()">
                                </div>
                                <div class="tier-config-row">
                                    <span class="tier-badge tier-C">C</span>
                                    <label>Min Pen:</label>
                                    <input type="number" id="tierThresholdC" value="25" min="0" max="100" onchange="updateTierConfig()">
                                </div>
                                <div class="tier-config-row">
                                    <span class="tier-badge tier-D">D</span>
                                    <label>Min Pen:</label>
                                    <input type="number" id="tierThresholdD" value="15" min="0" max="100" onchange="updateTierConfig()">
                                </div>
                            </div>
                            <div class="tier-config-section mt-3">
                                <div class="text-sub small mb-2">Damage thresholds:</div>
                                <div class="tier-config-row">
                                    <span class="tier-badge tier-S">S</span>
                                    <label>Min Dmg:</label>
                                    <input type="number" id="tierDmgThresholdS" value="80" min="0" max="300" onchange="updateTierConfig()">
                                </div>
                                <div class="tier-config-row">
                                    <span class="tier-badge tier-A">A</span>
                                    <label>Min Dmg:</label>
                                    <input type="number" id="tierDmgThresholdA" value="65" min="0" max="300" onchange="updateTierConfig()">
                                </div>
                                <div class="tier-config-row">
                                    <span class="tier-badge tier-B">B</span>
                                    <label>Min Dmg:</label>
                                    <input type="number" id="tierDmgThresholdB" value="50" min="0" max="300" onchange="updateTierConfig()">
                                </div>
                                <div class="tier-config-row">
                                    <span class="tier-badge tier-C">C</span>
                                    <label>Min Dmg:</label>
                                    <input type="number" id="tierDmgThresholdC" value="40" min="0" max="300" onchange="updateTierConfig()">
                                </div>
                                <div class="tier-config-row">
                                    <span class="tier-badge tier-D">D</span>
                                    <label>Min Dmg:</label>
                                    <input type="number" id="tierDmgThresholdD" value="30" min="0" max="300" onchange="updateTierConfig()">
                                </div>
                            </div>
                            <div class="tier-config-row mt-2">
                                <span class="tier-badge tier-F">F</span>
                                <label>Below D thresholds</label>
                            </div>
                            <div class="text-sub small mt-2" style="font-size: 0.7rem;">Tier reached if PEN <u>or</u> DMG meets threshold</div>
                            <div class="mt-2 d-flex gap-2">
                                <button class="btn-tarkov flex-grow-1" onclick="resetTierConfig()" style="padding: 6px 12px; font-size: 0.8rem;">Reset Defaults</button>
                                <button class="btn-tarkov flex-grow-1" onclick="clearTierOverrides()" style="padding: 6px 12px; font-size: 0.8rem;">Clear Overrides</button>
                            </div>
                        </div>
                    </div>
                    <div class="tarkov-panel">
                        <h5>Keep/Sell Analysis</h5>
                        <div class="mb-3">
                            <label class="form-label text-sub small">Minimum tier to keep:</label>
                            <input type="range" class="form-range" id="tierSlider" min="0" max="5" value="2" oninput="updateTierThreshold()">
                            <div class="text-center text-beige" id="tierDisplay">Keep B-Tier+</div>
                        </div>
                        <div class="analysis-panel" style="flex-direction: column;">
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(74, 122, 74, 0.2);">
                                    <h6 style="color: var(--eft-green);">KEEP</h6>
                                    <span class="badge-tarkov badge-active" id="keep-count">0</span>
                                </div>
                                <div id="keep-list" class="analysis-list"></div>
                            </div>
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(140, 59, 59, 0.2);">
                                    <h6 style="color: var(--eft-red);">SELL</h6>
                                    <span class="badge-tarkov" id="sell-count">0</span>
                                </div>
                                <div id="sell-list" class="analysis-list"></div>
                                <div class="text-end mt-2 text-sub small">Total value: <span id="total-sell-value" class="text-gold">0 RUB</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- WEAPONS TAB -->
        <div id="tab-weapons" class="tab-content">
            <div class="row">
                <div class="col-lg-8">
                    <div class="tarkov-panel">
                        <h5>Weapons Database</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-4">
                                <select id="weaponTypeFilter" class="form-select-tarkov w-100" onchange="filterWeapons()">
                                    <option value="ALL">All Types</option>
                                </select>
                            </div>
                            <div class="col-md-5">
                                <input type="text" class="form-control-tarkov w-100" placeholder="Search weapons..." id="weaponSearch" oninput="filterWeapons()">
                            </div>
                            <div class="col-md-3">
                                <button id="btn-load-weapons" class="btn-tarkov w-100" onclick="loadWeaponsData()">Load Data</button>
                            </div>
                        </div>
                        <div class="text-sub small mb-3">Click weapon to mark as owned | <span id="weapon-count">0</span> loaded</div>
                        <div id="weapons-loading" class="loading-spinner d-none">
                            <div class="spinner"></div>
                            <div>Loading weapons data...</div>
                        </div>
                        <div id="weapons-content" class="d-none">
                            <div id="weapons-list" style="max-height: 500px; overflow-y: auto;"></div>
                        </div>
                        <div id="weapons-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="tarkov-panel">
                        <h5>Weapon Tier Config</h5>
                        <div class="tier-config">
                            <div class="text-sub small mb-2">Ergonomics thresholds:</div>
                            <div class="tier-config-row"><span class="tier-badge tier-S">S</span><label>Min Ergo:</label><input type="number" id="weaponTierErgoS" value="70" min="0" max="100" onchange="updateWeaponTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-A">A</span><label>Min Ergo:</label><input type="number" id="weaponTierErgoA" value="55" min="0" max="100" onchange="updateWeaponTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-B">B</span><label>Min Ergo:</label><input type="number" id="weaponTierErgoB" value="40" min="0" max="100" onchange="updateWeaponTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-C">C</span><label>Min Ergo:</label><input type="number" id="weaponTierErgoC" value="28" min="0" max="100" onchange="updateWeaponTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-D">D</span><label>Min Ergo:</label><input type="number" id="weaponTierErgoD" value="15" min="0" max="100" onchange="updateWeaponTierConfig()"></div>
                            <div class="tier-config-section mt-3">
                                <div class="text-sub small mb-2">Recoil thresholds (lower = better):</div>
                                <div class="tier-config-row"><span class="tier-badge tier-S">S</span><label>Max Recoil:</label><input type="number" id="weaponTierRecoilS" value="50" min="0" max="500" onchange="updateWeaponTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-A">A</span><label>Max Recoil:</label><input type="number" id="weaponTierRecoilA" value="80" min="0" max="500" onchange="updateWeaponTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-B">B</span><label>Max Recoil:</label><input type="number" id="weaponTierRecoilB" value="120" min="0" max="500" onchange="updateWeaponTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-C">C</span><label>Max Recoil:</label><input type="number" id="weaponTierRecoilC" value="180" min="0" max="500" onchange="updateWeaponTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-D">D</span><label>Max Recoil:</label><input type="number" id="weaponTierRecoilD" value="250" min="0" max="500" onchange="updateWeaponTierConfig()"></div>
                            </div>
                            <div class="tier-config-row mt-2"><span class="tier-badge tier-F">F</span><label>Below D</label></div>
                            <div class="text-sub small mt-2" style="font-size: 0.7rem;">Tier reached if Ergo <u>or</u> Recoil meets threshold</div>
                            <div class="mt-2 d-flex gap-2">
                                <button class="btn-tarkov flex-grow-1" onclick="resetWeaponTierConfig()" style="padding: 6px 12px; font-size: 0.8rem;">Reset</button>
                                <button class="btn-tarkov flex-grow-1" onclick="clearWeaponOverrides()" style="padding: 6px 12px; font-size: 0.8rem;">Clear Overrides</button>
                            </div>
                        </div>
                    </div>
                    <div class="tarkov-panel">
                        <h5>Keep/Sell Analysis</h5>
                        <div class="mb-3">
                            <label class="form-label text-sub small">Minimum tier to keep:</label>
                            <input type="range" class="form-range" id="weaponTierSlider" min="0" max="5" value="2" oninput="updateWeaponTierThreshold()">
                            <div class="text-center text-beige" id="weaponTierDisplay">Keep B-Tier+</div>
                        </div>
                        <div class="analysis-panel" style="flex-direction: column;">
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(74, 122, 74, 0.2);"><h6 style="color: var(--eft-green);">KEEP</h6><span class="badge-tarkov badge-active" id="weapon-keep-count">0</span></div>
                                <div id="weapon-keep-list" class="analysis-list"></div>
                            </div>
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(140, 59, 59, 0.2);"><h6 style="color: var(--eft-red);">SELL</h6><span class="badge-tarkov" id="weapon-sell-count">0</span></div>
                                <div id="weapon-sell-list" class="analysis-list"></div>
                                <div class="text-end mt-2 text-sub small">Total value: <span id="weapon-total-sell-value" class="text-gold">0 RUB</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- GEAR TAB -->
        <div id="tab-gear" class="tab-content">
            <div class="row">
                <div class="col-lg-8">
                    <div class="tarkov-panel">
                        <h5>Gear Database</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-4">
                                <select id="gearTypeFilter" class="form-select-tarkov w-100" onchange="filterGear()">
                                    <option value="ALL">All Types</option>
                                    <option value="armor">Body Armor</option>
                                    <option value="helmet">Helmets</option>
                                    <option value="rig">Tactical Rigs</option>
                                    <option value="backpack">Backpacks</option>
                                    <option value="headphones">Headsets</option>
                                </select>
                            </div>
                            <div class="col-md-5">
                                <input type="text" class="form-control-tarkov w-100" placeholder="Search gear..." id="gearSearch" oninput="filterGear()">
                            </div>
                            <div class="col-md-3">
                                <button id="btn-load-gear" class="btn-tarkov w-100" onclick="loadGearData()">Load Data</button>
                            </div>
                        </div>
                        <div class="text-sub small mb-3">Click gear to mark as owned | <span id="gear-count">0</span> loaded</div>
                        <div id="gear-loading" class="loading-spinner d-none">
                            <div class="spinner"></div>
                            <div>Loading gear data...</div>
                        </div>
                        <div id="gear-content" class="d-none">
                            <div id="gear-list" style="max-height: 500px; overflow-y: auto;"></div>
                        </div>
                        <div id="gear-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="tarkov-panel">
                        <h5>Gear Tier Config</h5>
                        <div class="tier-config">
                            <div class="text-sub small mb-2">Armor Class thresholds:</div>
                            <div class="tier-config-row"><span class="tier-badge tier-S">S</span><label>Min Class:</label><input type="number" id="gearTierClassS" value="6" min="1" max="6" onchange="updateGearTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-A">A</span><label>Min Class:</label><input type="number" id="gearTierClassA" value="5" min="1" max="6" onchange="updateGearTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-B">B</span><label>Min Class:</label><input type="number" id="gearTierClassB" value="4" min="1" max="6" onchange="updateGearTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-C">C</span><label>Min Class:</label><input type="number" id="gearTierClassC" value="3" min="1" max="6" onchange="updateGearTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-D">D</span><label>Min Class:</label><input type="number" id="gearTierClassD" value="2" min="1" max="6" onchange="updateGearTierConfig()"></div>
                            <div class="tier-config-section mt-3">
                                <div class="text-sub small mb-2">Durability thresholds:</div>
                                <div class="tier-config-row"><span class="tier-badge tier-S">S</span><label>Min Dur:</label><input type="number" id="gearTierDurS" value="70" min="0" max="100" onchange="updateGearTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-A">A</span><label>Min Dur:</label><input type="number" id="gearTierDurA" value="55" min="0" max="100" onchange="updateGearTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-B">B</span><label>Min Dur:</label><input type="number" id="gearTierDurB" value="40" min="0" max="100" onchange="updateGearTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-C">C</span><label>Min Dur:</label><input type="number" id="gearTierDurC" value="30" min="0" max="100" onchange="updateGearTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-D">D</span><label>Min Dur:</label><input type="number" id="gearTierDurD" value="20" min="0" max="100" onchange="updateGearTierConfig()"></div>
                            </div>
                            <div class="tier-config-row mt-2"><span class="tier-badge tier-F">F</span><label>Below D</label></div>
                            <div class="text-sub small mt-2" style="font-size: 0.7rem;">Tier reached if Class <u>or</u> Durability meets threshold</div>
                            <div class="mt-2 d-flex gap-2">
                                <button class="btn-tarkov flex-grow-1" onclick="resetGearTierConfig()" style="padding: 6px 12px; font-size: 0.8rem;">Reset</button>
                                <button class="btn-tarkov flex-grow-1" onclick="clearGearOverrides()" style="padding: 6px 12px; font-size: 0.8rem;">Clear Overrides</button>
                            </div>
                        </div>
                    </div>
                    <div class="tarkov-panel">
                        <h5>Keep/Sell Analysis</h5>
                        <div class="mb-3">
                            <label class="form-label text-sub small">Minimum tier to keep:</label>
                            <input type="range" class="form-range" id="gearTierSlider" min="0" max="5" value="2" oninput="updateGearTierThreshold()">
                            <div class="text-center text-beige" id="gearTierDisplay">Keep B-Tier+</div>
                        </div>
                        <div class="analysis-panel" style="flex-direction: column;">
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(74, 122, 74, 0.2);"><h6 style="color: var(--eft-green);">KEEP</h6><span class="badge-tarkov badge-active" id="gear-keep-count">0</span></div>
                                <div id="gear-keep-list" class="analysis-list"></div>
                            </div>
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(140, 59, 59, 0.2);"><h6 style="color: var(--eft-red);">SELL</h6><span class="badge-tarkov" id="gear-sell-count">0</span></div>
                                <div id="gear-sell-list" class="analysis-list"></div>
                                <div class="text-end mt-2 text-sub small">Total value: <span id="gear-total-sell-value" class="text-gold">0 RUB</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ATTACHMENTS TAB -->
        <div id="tab-attachments" class="tab-content">
            <div class="row">
                <div class="col-lg-8">
                    <div class="tarkov-panel">
                        <h5>Attachments Database</h5>
                        <div class="row g-3 mb-3">
                            <div class="col-md-4">
                                <select id="attachmentTypeFilter" class="form-select-tarkov w-100" onchange="filterAttachments()">
                                    <option value="ALL">All Types</option>
                                </select>
                            </div>
                            <div class="col-md-5">
                                <input type="text" class="form-control-tarkov w-100" placeholder="Search attachments..." id="attachmentSearch" oninput="filterAttachments()">
                            </div>
                            <div class="col-md-3">
                                <button id="btn-load-attachments" class="btn-tarkov w-100" onclick="loadAttachmentsData()">Load Data</button>
                            </div>
                        </div>
                        <div class="text-sub small mb-3">Click attachment to mark as owned | <span id="attachment-count">0</span> loaded</div>
                        <div id="attachments-loading" class="loading-spinner d-none">
                            <div class="spinner"></div>
                            <div>Loading attachments data...</div>
                        </div>
                        <div id="attachments-content" class="d-none">
                            <div id="attachments-list" style="max-height: 500px; overflow-y: auto;"></div>
                        </div>
                        <div id="attachments-error" class="alert alert-danger d-none"></div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="tarkov-panel">
                        <h5>Attachment Tier Config</h5>
                        <div class="tier-config">
                            <div class="text-sub small mb-2">Ergonomics Modifier thresholds:</div>
                            <div class="tier-config-row"><span class="tier-badge tier-S">S</span><label>Min Ergo+:</label><input type="number" id="attachTierErgoS" value="15" min="-50" max="50" onchange="updateAttachmentTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-A">A</span><label>Min Ergo+:</label><input type="number" id="attachTierErgoA" value="10" min="-50" max="50" onchange="updateAttachmentTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-B">B</span><label>Min Ergo+:</label><input type="number" id="attachTierErgoB" value="5" min="-50" max="50" onchange="updateAttachmentTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-C">C</span><label>Min Ergo+:</label><input type="number" id="attachTierErgoC" value="2" min="-50" max="50" onchange="updateAttachmentTierConfig()"></div>
                            <div class="tier-config-row"><span class="tier-badge tier-D">D</span><label>Min Ergo+:</label><input type="number" id="attachTierErgoD" value="0" min="-50" max="50" onchange="updateAttachmentTierConfig()"></div>
                            <div class="tier-config-section mt-3">
                                <div class="text-sub small mb-2">Recoil Modifier thresholds (negative = better):</div>
                                <div class="tier-config-row"><span class="tier-badge tier-S">S</span><label>Max Recoil:</label><input type="number" id="attachTierRecoilS" value="-5" min="-50" max="50" onchange="updateAttachmentTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-A">A</span><label>Max Recoil:</label><input type="number" id="attachTierRecoilA" value="-3" min="-50" max="50" onchange="updateAttachmentTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-B">B</span><label>Max Recoil:</label><input type="number" id="attachTierRecoilB" value="-1" min="-50" max="50" onchange="updateAttachmentTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-C">C</span><label>Max Recoil:</label><input type="number" id="attachTierRecoilC" value="0" min="-50" max="50" onchange="updateAttachmentTierConfig()"></div>
                                <div class="tier-config-row"><span class="tier-badge tier-D">D</span><label>Max Recoil:</label><input type="number" id="attachTierRecoilD" value="2" min="-50" max="50" onchange="updateAttachmentTierConfig()"></div>
                            </div>
                            <div class="tier-config-row mt-2"><span class="tier-badge tier-F">F</span><label>Below D</label></div>
                            <div class="text-sub small mt-2" style="font-size: 0.7rem;">Tier reached if Ergo+ <u>or</u> Recoil meets threshold</div>
                            <div class="mt-2 d-flex gap-2">
                                <button class="btn-tarkov flex-grow-1" onclick="resetAttachmentTierConfig()" style="padding: 6px 12px; font-size: 0.8rem;">Reset</button>
                                <button class="btn-tarkov flex-grow-1" onclick="clearAttachmentOverrides()" style="padding: 6px 12px; font-size: 0.8rem;">Clear Overrides</button>
                            </div>
                        </div>
                    </div>
                    <div class="tarkov-panel">
                        <h5>Keep/Sell Analysis</h5>
                        <div class="mb-3">
                            <label class="form-label text-sub small">Minimum tier to keep:</label>
                            <input type="range" class="form-range" id="attachmentTierSlider" min="0" max="5" value="2" oninput="updateAttachmentTierThreshold()">
                            <div class="text-center text-beige" id="attachmentTierDisplay">Keep B-Tier+</div>
                        </div>
                        <div class="analysis-panel" style="flex-direction: column;">
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(74, 122, 74, 0.2);"><h6 style="color: var(--eft-green);">KEEP</h6><span class="badge-tarkov badge-active" id="attachment-keep-count">0</span></div>
                                <div id="attachment-keep-list" class="analysis-list"></div>
                            </div>
                            <div class="analysis-col">
                                <div class="analysis-header" style="background: rgba(140, 59, 59, 0.2);"><h6 style="color: var(--eft-red);">SELL</h6><span class="badge-tarkov" id="attachment-sell-count">0</span></div>
                                <div id="attachment-sell-list" class="analysis-list"></div>
                                <div class="text-end mt-2 text-sub small">Total value: <span id="attachment-total-sell-value" class="text-gold">0 RUB</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // ============================================================================
        // CONFIGURATION
        // ============================================================================
        const API_BASE = '/api';
        const STORAGE_KEY_QUESTS = 'tarkov_planner_quests_v3';
        const STORAGE_KEY_AMMO = 'tarkov_planner_ammo_v3';
        
        // Map configuration - using tarkovdata SVG maps (coordinates match 1:1)
        const MAP_CONFIG = {
            customs:     { file: 'maps/Customs.svg' },
            woods:       { file: 'maps/Woods.svg' },
            shoreline:   { file: 'maps/Shoreline.svg' },
            interchange: { file: 'maps/Interchange.svg' },
            reserve:     { file: 'maps/Reserve.svg' },
            lighthouse:  { file: 'maps/Lighthouse.svg' },
            streets:     { file: 'maps/StreetsOfTarkov.svg' },
            groundzero:  { file: 'maps/GroundZero.svg' },
            factory:     { file: 'maps/Factory.svg' },
            labs:        { file: 'maps/Labs.svg' }
        };

        // Tier configuration
        const TIER_NAMES = ['S', 'A', 'B', 'C', 'D', 'F'];
        const TIER_ORDER = ['S', 'A', 'B', 'C', 'D', 'F'];
        const STORAGE_KEY_TIER_CONFIG = 'tarkov_planner_tier_config_v1';
        const STORAGE_KEY_TIER_OVERRIDES = 'tarkov_planner_tier_overrides_v1';
        
        // Storage keys for new tabs
        const STORAGE_KEY_WEAPONS = 'tarkov_planner_weapons_v1';
        const STORAGE_KEY_WEAPONS_TIER = 'tarkov_planner_weapons_tier_v1';
        const STORAGE_KEY_WEAPONS_OVERRIDES = 'tarkov_planner_weapons_overrides_v1';
        const STORAGE_KEY_GEAR = 'tarkov_planner_gear_v1';
        const STORAGE_KEY_GEAR_TIER = 'tarkov_planner_gear_tier_v1';
        const STORAGE_KEY_GEAR_OVERRIDES = 'tarkov_planner_gear_overrides_v1';
        const STORAGE_KEY_ATTACHMENTS = 'tarkov_planner_attachments_v1';
        const STORAGE_KEY_ATTACHMENTS_TIER = 'tarkov_planner_attachments_tier_v1';
        const STORAGE_KEY_ATTACHMENTS_OVERRIDES = 'tarkov_planner_attachments_overrides_v1';
        
        // Default tier thresholds (penetration and damage values)
        const DEFAULT_TIER_THRESHOLDS = { 
            pen: { S: 55, A: 45, B: 35, C: 25, D: 15 },
            dmg: { S: 80, A: 65, B: 50, C: 40, D: 30 }
        };
        
        // Default tier thresholds for Weapons (Ergonomics higher=better, Recoil lower=better)
        const DEFAULT_WEAPON_TIER_THRESHOLDS = {
            ergo: { S: 70, A: 55, B: 40, C: 28, D: 15 },
            recoil: { S: 50, A: 80, B: 120, C: 180, D: 250 }  // Max recoil (lower is better)
        };
        
        // Default tier thresholds for Gear (Armor Class, Durability)
        const DEFAULT_GEAR_TIER_THRESHOLDS = {
            armorClass: { S: 6, A: 5, B: 4, C: 3, D: 2 },
            durability: { S: 70, A: 55, B: 40, C: 30, D: 20 }
        };
        
        // Default tier thresholds for Attachments (Ergo modifier, Recoil modifier)
        const DEFAULT_ATTACHMENT_TIER_THRESHOLDS = {
            ergoMod: { S: 15, A: 10, B: 5, C: 2, D: 0 },       // Min ergo bonus
            recoilMod: { S: -5, A: -3, B: -1, C: 0, D: 2 }     // Max recoil (negative=better)
        };
        
        // State
        let mapInstance = null;
        let currentMapLayer = null;
        let imageBounds = null;
        let allQuestsGlobal = [];
        let allAmmoData = null;
        let ownedAmmo = new Set();
        let currentTierThreshold = 'B';
        let questLocationsData = null;
        let questMarkersLayer = null;
        let currentMapHeight = 0;
        let currentMapWidth = 0;
        let selectedQuestNamesForMarkers = [];
        let requiredMapsForQuests = new Set();
        let tierThresholds = JSON.parse(JSON.stringify(DEFAULT_TIER_THRESHOLDS));
        let tierOverrides = {}; // ammoId -> tier
        
        // Weapons state
        let allWeaponsData = null;
        let ownedWeapons = new Set();
        let weaponTierThresholds = JSON.parse(JSON.stringify(DEFAULT_WEAPON_TIER_THRESHOLDS));
        let weaponTierOverrides = {};
        let currentWeaponTierThreshold = 'B';
        let weaponTypeFilter = 'ALL';
        let weaponSearchQuery = '';
        
        // Gear state
        let allGearData = null;
        let ownedGear = new Set();
        let gearTierThresholds = JSON.parse(JSON.stringify(DEFAULT_GEAR_TIER_THRESHOLDS));
        let gearTierOverrides = {};
        let currentGearTierThreshold = 'B';
        let gearTypeFilter = 'ALL';
        let gearSearchQuery = '';
        
        // Attachments state
        let allAttachmentsData = null;
        let ownedAttachments = new Set();
        let attachmentTierThresholds = JSON.parse(JSON.stringify(DEFAULT_ATTACHMENT_TIER_THRESHOLDS));
        let attachmentTierOverrides = {};
        let currentAttachmentTierThreshold = 'B';
        let attachmentTypeFilter = 'ALL';
        let attachmentSearchQuery = '';

        // ============================================================================
        // STATUS INDICATOR
        // ============================================================================
        
        function updateStatus(connected, version = '4.0') {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            if (connected) {
                dot.classList.remove('offline');
                text.textContent = `v${version} connected`;
            } else {
                dot.classList.add('offline');
                text.textContent = 'Offline';
            }
        }

        // ============================================================================
        // TARKOVDATA INTEGRATION - Quest Locations
        // ============================================================================
        
        const TARKOVDATA_QUESTS_URL = 'https://raw.githubusercontent.com/TarkovTracker/tarkovdata/master/quests.json';
        
        async function loadQuestLocationsData() {
            try {
                const response = await fetch(TARKOVDATA_QUESTS_URL);
                if (!response.ok) throw new Error('Failed to load tarkovdata');
                const data = await response.json();
                
                // Parse quest locations - index by quest name for matching
                questLocationsData = { byMap: {}, byQuestName: {} };
                let totalLocations = 0;
                
                for (const [questId, quest] of Object.entries(data)) {
                    const questTitle = (quest.title || quest.name || '').toLowerCase().trim();
                    
                    if (quest.objectives) {
                        let objIndex = 0;
                        quest.objectives.forEach(obj => {
                            if (obj.gps && obj.gps.leftPercent !== undefined && obj.gps.topPercent !== undefined) {
                                const mapKey = getMapKeyFromLocation(obj.location, quest);
                                if (!mapKey) return;
                                
                                objIndex++;
                                
                                // Build concise description from available fields
                                const descParts = [];
                                if (obj.target) descParts.push(obj.target);
                                if (obj.tool && !descParts.includes(obj.tool)) descParts.push(`with ${obj.tool}`);
                                const description = descParts.length > 0 
                                    ? descParts.join(' ').substring(0, 80) 
                                    : `Objective #${objIndex}`;
                                
                                const locData = {
                                    questId: questId,
                                    questName: quest.title || quest.name || `Quest ${questId}`,
                                    objectiveIndex: objIndex,
                                    objectiveId: obj.id,
                                    type: obj.type || 'unknown',
                                    description: description,
                                    target: obj.target || '',
                                    tool: obj.tool || '',
                                    leftPercent: obj.gps.leftPercent,
                                    topPercent: obj.gps.topPercent,
                                    floor: obj.gps.floor || 'Ground_Level',
                                    mapKey: mapKey
                                };
                                
                                // Index by map
                                if (!questLocationsData.byMap[mapKey]) {
                                    questLocationsData.byMap[mapKey] = [];
                                }
                                questLocationsData.byMap[mapKey].push(locData);
                                
                                // Index by quest name (lowercase for matching)
                                if (!questLocationsData.byQuestName[questTitle]) {
                                    questLocationsData.byQuestName[questTitle] = [];
                                }
                                questLocationsData.byQuestName[questTitle].push(locData);
                                
                                totalLocations++;
                            }
                        });
                    }
                }
                
                console.log('Quest locations loaded:', totalLocations, 'objectives');
                return questLocationsData;
            } catch (error) {
                console.error('Error loading quest locations:', error);
                return null;
            }
        }
        
        function getMapKeyFromLocation(locationId, quest) {
            const locationMap = {
                0: 'customs',
                1: 'factory',
                2: 'woods',
                3: 'shoreline',
                4: 'interchange',
                5: 'lighthouse',
                6: 'reserve',
                7: 'labs',
                8: 'streets',
                9: 'groundzero'
            };
            
            if (locationId !== undefined && locationMap[locationId]) {
                return locationMap[locationId];
            }
            if (quest.location !== undefined && locationMap[quest.location]) {
                return locationMap[quest.location];
            }
            return null;
        }
        
        // Quest color palette - distinct colors for each quest
        const QUEST_COLORS = [
            { fill: '#2d7a2d', border: '#7fff7f' },  // Green
            { fill: '#7a2d7a', border: '#ff7fff' },  // Magenta
            { fill: '#2d5a7a', border: '#7fdfff' },  // Cyan
            { fill: '#7a5a2d', border: '#ffc77f' },  // Orange
            { fill: '#5a2d7a', border: '#bf7fff' },  // Purple
            { fill: '#7a2d2d', border: '#ff7f7f' },  // Red
            { fill: '#2d7a5a', border: '#7fffbf' },  // Teal
            { fill: '#7a7a2d', border: '#ffff7f' },  // Yellow
            { fill: '#4a4a7a', border: '#9f9fff' },  // Lavender
            { fill: '#7a4a4a', border: '#ffafaf' },  // Pink
            { fill: '#2d4a4a', border: '#7fbfbf' },  // Dark Cyan
            { fill: '#4a7a4a', border: '#afdfaf' },  // Lime
        ];
        
        let currentQuestColors = {};
        
        function drawQuestMarkers(mapKey, mapWidth, mapHeight, questNames = []) {
            if (!questMarkersLayer) {
                questMarkersLayer = L.layerGroup();
            }
            questMarkersLayer.clearLayers();
            
            const legend = document.getElementById('mapLegend');
            const legendItems = document.getElementById('legendItems');
            
            // Only draw markers if we have selected quests
            if (!questLocationsData || questNames.length === 0) {
                updateMarkerCount(0);
                legend.style.display = 'none';
                return;
            }
            
            // Assign colors to quests
            currentQuestColors = {};
            questNames.forEach((qName, index) => {
                currentQuestColors[qName.toLowerCase().trim()] = QUEST_COLORS[index % QUEST_COLORS.length];
            });
            
            // Build legend
            legendItems.innerHTML = questNames.map((qName, index) => {
                const color = QUEST_COLORS[index % QUEST_COLORS.length];
                return `<div class="legend-item">
                    <div class="legend-color" style="background: ${color.fill}; border-color: ${color.border};"></div>
                    <span>${qName}</span>
                </div>`;
            }).join('');
            legend.style.display = 'block';
            
            let markerCount = 0;
            
            // Draw markers only for selected quests
            questNames.forEach((qName, questIndex) => {
                const normalizedName = qName.toLowerCase().trim();
                const locations = questLocationsData.byQuestName[normalizedName] || [];
                const color = QUEST_COLORS[questIndex % QUEST_COLORS.length];
                
                locations.forEach(loc => {
                    // Only draw if this location is on the current map
                    if (loc.mapKey !== mapKey) return;
                    
                    // Direct percent to pixel conversion (no offset needed for tarkovdata SVG maps)
                    const pixelX = (loc.leftPercent / 100) * mapWidth;
                    const pixelY = (loc.topPercent / 100) * mapHeight;
                    
                    // Leaflet CRS.Simple: Y is inverted
                    const leafletY = mapHeight - pixelY;
                    const leafletX = pixelX;
                    
                    markerCount++;
                    
                    // Create custom div icon with number
                    const markerHtml = `
                        <div style="position: relative; width: 24px; height: 24px;">
                            <div style="width: 24px; height: 24px; border-radius: 50%; background: ${color.fill}; border: 3px solid ${color.border};"></div>
                            <div style="position: absolute; top: -6px; right: -6px; background: #c4b896; color: #000; font-weight: 700; font-size: 10px; width: 14px; height: 14px; line-height: 14px; text-align: center; border-radius: 50%;">${loc.objectiveIndex || markerCount}</div>
                        </div>
                    `;
                    
                    const icon = L.divIcon({
                        html: markerHtml,
                        className: 'quest-marker-icon',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                    
                    const marker = L.marker([leafletY, leafletX], { icon: icon });
                    
                    // Build tooltip text: short and informative
                    const typeLabel = loc.type.charAt(0).toUpperCase() + loc.type.slice(1);
                    const tooltipText = `#${loc.objectiveIndex || markerCount}: ${typeLabel} - ${loc.description}`;
                    
                    const popupContent = `
                        <div class="quest-marker-popup">
                            <span class="obj-num">#${loc.objectiveIndex || markerCount}</span>
                            <span class="obj-type" style="background: ${color.fill}; color: ${color.border};">${loc.type}</span>
                            <h6>${loc.questName}</h6>
                            <p>${loc.description}</p>
                            ${loc.floor !== 'Ground_Level' ? `<p class="text-sub" style="font-size: 0.75rem; margin-top: 5px;">Floor: ${loc.floor}</p>` : ''}
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent, { className: 'marker-label' });
                    marker.bindTooltip(tooltipText, { direction: 'top', className: 'marker-label', offset: [0, -15] });
                    
                    questMarkersLayer.addLayer(marker);
                });
            });
            
            if (mapInstance) {
                questMarkersLayer.addTo(mapInstance);
            }
            
            updateMarkerCount(markerCount);
        }
        
        function updateMarkerCount(count) {
            document.getElementById('markerCount').textContent = count + ' marker' + (count !== 1 ? 's' : '');
        }

        // ============================================================================
        // TAB NAVIGATION
        // ============================================================================
        
        function switchTab(tabId) {
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('tab-' + tabId).classList.add('active');
        }

        // ============================================================================
        // QUEST MANAGEMENT
        // ============================================================================
        
        function getSavedQuests() {
            const saved = localStorage.getItem(STORAGE_KEY_QUESTS);
            return saved ? new Set(JSON.parse(saved)) : new Set();
        }
        
        function saveQuestState(questId, isSelected) {
            const saved = getSavedQuests();
            isSelected ? saved.add(questId) : saved.delete(questId);
            localStorage.setItem(STORAGE_KEY_QUESTS, JSON.stringify([...saved]));
        }
        
        function getWikiUrl(questName) {
            return 'https://escapefromtarkov.fandom.com/wiki/' + encodeURIComponent(questName.replace(/ /g, '_'));
        }
        
        async function loadQuests() {
            const loading = document.getElementById('quest-loading');
            const list = document.getElementById('quest-list');
            const error = document.getElementById('quest-error');
            
            try {
                const response = await fetch(API_BASE + '/quests/ALL');
                if (!response.ok) throw new Error('Server error: ' + response.status);
                const data = await response.json();
                
                // Handle both array and object response
                allQuestsGlobal = Array.isArray(data) ? data : (data.quests || []);
                const savedQuests = getSavedQuests();
                
                // Update connection status
                updateStatus(true, '4.0');
                
                // Group by trader
                const byTrader = {};
                allQuestsGlobal.forEach(q => {
                    const trader = q.trader?.name || 'Unknown';
                    if (!byTrader[trader]) byTrader[trader] = { quests: [], image: q.trader?.imageLink };
                    byTrader[trader].quests.push(q);
                });
                
                let html = '';
                for (const [trader, data] of Object.entries(byTrader)) {
                    const groupId = 'trader-' + trader.replace(/\s+/g, '-');
                    html += `
                        <div class="trader-group">
                            <div class="trader-header" onclick="toggleTrader('${groupId}')" id="btn-${groupId}" data-total="${data.quests.length}">
                                ${data.image ? `<img src="${data.image}" alt="${trader}">` : ''}
                                <h6>${trader}</h6>
                                <span class="badge-tarkov">${data.quests.length} Tasks</span>
                            </div>
                            <div class="trader-quests" id="${groupId}">
                    `;
                    
                    data.quests.forEach(q => {
                        const isSelected = savedQuests.has(q.id);
                        html += `
                            <div class="quest-row ${isSelected ? 'selected' : ''}" onclick="toggleSelection('${q.id}', this, event)">
                                <input type="checkbox" id="cb-${q.id}" ${isSelected ? 'checked' : ''} data-parent-group="${groupId}" data-quest-name="${q.name}">
                                <div class="quest-info">
                                    <div class="quest-name">
                                        <a href="${getWikiUrl(q.name)}" target="_blank" rel="noopener noreferrer" onclick="event.stopPropagation()">${q.name}</a>
                                    </div>
                                    <div class="quest-meta">
                                        <span>${q.map?.name || 'Any'}</span>
                                        <span>Lvl ${q.minPlayerLevel || '?'}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += '</div></div>';
                }
                
                list.innerHTML = html;
                list.classList.remove('d-none');
                loading.classList.add('d-none');
                
                for (const [trader, data] of Object.entries(byTrader)) {
                    const groupId = 'trader-' + trader.replace(/\s+/g, '-');
                    updateTraderBadge(groupId);
                }
                
            } catch (err) {
                updateStatus(false);
                error.innerHTML = `<strong>ERROR:</strong> ${err.message}<br><small>Make sure the backend is running</small>`;
                error.classList.remove('d-none');
                loading.classList.add('d-none');
            }
        }
        
        function toggleTrader(groupId) {
            document.getElementById(groupId).classList.toggle('show');
        }
        
        function toggleSelection(questId, div, ev) {
            const cb = document.getElementById('cb-' + questId);
            if (ev.target !== cb && ev.target.tagName !== 'A') {
                cb.checked = !cb.checked;
            }
            cb.checked ? div.classList.add('selected') : div.classList.remove('selected');
            saveQuestState(questId, cb.checked);
            
            const groupId = cb.getAttribute('data-parent-group');
            if (groupId) updateTraderBadge(groupId);
            
            // Update map selection based on selected quests
            updateMapSelection();
        }
        
        function updateMapSelection() {
            const savedQuests = getSavedQuests();
            const selectedQuests = allQuestsGlobal.filter(q => savedQuests.has(q.id));
            const mapSelect = document.getElementById('mapSelect');
            const mapHint = document.getElementById('mapHint');
            
            if (selectedQuests.length === 0) {
                // No quests selected - enable all maps, hide hint
                Array.from(mapSelect.options).forEach(opt => opt.disabled = false);
                mapHint.style.display = 'none';
                requiredMapsForQuests = new Set();
                return;
            }
            
            // Collect required maps from API quest data AND tarkovdata locations
            requiredMapsForQuests = new Set();
            
            selectedQuests.forEach(q => {
                // From API quest map field
                if (q.map?.name && q.map.name.toLowerCase() !== 'any') {
                    const mapKey = mapNameToKey(q.map.name);
                    if (mapKey) requiredMapsForQuests.add(mapKey);
                }
                
                // From tarkovdata GPS locations
                if (questLocationsData) {
                    const questTitle = q.name.toLowerCase().trim();
                    const locations = questLocationsData.byQuestName[questTitle] || [];
                    locations.forEach(loc => {
                        if (loc.mapKey) requiredMapsForQuests.add(loc.mapKey);
                    });
                }
            });
            
            // If no specific maps found (all "any" quests), enable all
            if (requiredMapsForQuests.size === 0) {
                Array.from(mapSelect.options).forEach(opt => opt.disabled = false);
                mapHint.textContent = 'Selected quests can be completed on any map';
                mapHint.className = 'map-hint';
                mapHint.style.display = 'block';
                return;
            }
            
            // Enable/disable map options
            const mapNames = [];
            Array.from(mapSelect.options).forEach(opt => {
                const isRequired = requiredMapsForQuests.has(opt.value);
                opt.disabled = !isRequired;
                if (isRequired) {
                    mapNames.push(opt.textContent);
                }
            });
            
            // Sort alphabetically and select first
            mapNames.sort();
            const sortedMaps = Array.from(requiredMapsForQuests).sort();
            
            // Auto-select first available map if current selection is disabled
            const currentSelected = mapSelect.value;
            if (!requiredMapsForQuests.has(currentSelected)) {
                mapSelect.value = sortedMaps[0];
            }
            
            // Show hint
            if (requiredMapsForQuests.size === 1) {
                mapHint.textContent = `Quest location: ${mapNames[0]}`;
                mapHint.className = 'map-hint';
            } else {
                mapHint.textContent = `Quests require ${requiredMapsForQuests.size} maps: ${mapNames.join(', ')}`;
                mapHint.className = 'map-hint warning';
            }
            mapHint.style.display = 'block';
        }
        
        function mapNameToKey(mapName) {
            const nameMap = {
                'customs': 'customs',
                'woods': 'woods',
                'shoreline': 'shoreline',
                'interchange': 'interchange',
                'reserve': 'reserve',
                'lighthouse': 'lighthouse',
                'streets of tarkov': 'streets',
                'streets': 'streets',
                'ground zero': 'groundzero',
                'factory': 'factory',
                'the lab': 'labs',
                'laboratory': 'labs',
                'labs': 'labs'
            };
            return nameMap[mapName.toLowerCase()] || null;
        }
        
        function updateTraderBadge(groupId) {
            const btn = document.getElementById('btn-' + groupId);
            if (!btn) return;
            const count = document.querySelectorAll(`input[data-parent-group="${groupId}"]:checked`).length;
            const badge = btn.querySelector('.badge-tarkov');
            badge.textContent = count > 0 ? count + ' Active' : btn.dataset.total + ' Tasks';
            badge.classList.toggle('badge-active', count > 0);
        }
        
        function filterQuests() {
            const search = document.getElementById('questSearch').value.toLowerCase();
            document.querySelectorAll('.quest-row').forEach(row => {
                const name = row.querySelector('.quest-name').textContent.toLowerCase();
                row.style.display = name.includes(search) ? '' : 'none';
            });
        }

        // ============================================================================
        // MAP MANAGEMENT
        // ============================================================================
        
        async function initMap(mapName, questNames = []) {
            const cfg = MAP_CONFIG[mapName];
            if (!cfg) return;
            
            if (mapInstance) {
                mapInstance.remove();
                mapInstance = null;
            }
            
            const isSvg = cfg.file.toLowerCase().endsWith('.svg');
            
            try {
                if (isSvg) {
                    // For SVG: fetch and parse viewBox to get dimensions
                    const response = await fetch(cfg.file);
                    if (!response.ok) throw new Error('SVG not found');
                    const svgText = await response.text();
                    
                    // Parse viewBox from SVG
                    const viewBoxMatch = svgText.match(/viewBox=["']([^"']+)["']/);
                    if (viewBoxMatch) {
                        const [minX, minY, width, height] = viewBoxMatch[1].split(/\s+/).map(Number);
                        currentMapWidth = width;
                        currentMapHeight = height;
                    } else {
                        // Fallback: try width/height attributes
                        const widthMatch = svgText.match(/width=["'](\d+)/);
                        const heightMatch = svgText.match(/height=["'](\d+)/);
                        currentMapWidth = widthMatch ? parseInt(widthMatch[1]) : 1000;
                        currentMapHeight = heightMatch ? parseInt(heightMatch[1]) : 1000;
                    }
                } else {
                    // For raster images: use Image object
                    const img = new Image();
                    img.src = cfg.file;
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                    });
                    currentMapWidth = img.naturalWidth;
                    currentMapHeight = img.naturalHeight;
                }
            } catch (e) {
                document.getElementById('map').innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--eft-red);">
                        <div class="text-center">
                            <div style="font-size: 2rem;">!</div>
                            <div>Map not found: ${cfg.file}</div>
                        </div>
                    </div>
                `;
                return;
            }
            
            imageBounds = [[0, 0], [currentMapHeight, currentMapWidth]];
            
            mapInstance = L.map('map', {
                crs: L.CRS.Simple,
                minZoom: -3,
                maxZoom: 2,
                zoomSnap: 0.25,
                zoomDelta: 0.5,
                attributionControl: false
            });
            
            currentMapLayer = L.imageOverlay(cfg.file, imageBounds).addTo(mapInstance);
            mapInstance.fitBounds(imageBounds);
            
            questMarkersLayer = L.layerGroup().addTo(mapInstance);
            
            // Draw quest markers only for selected quests
            drawQuestMarkers(mapName, currentMapWidth, currentMapHeight, questNames);
            
            setTimeout(() => mapInstance.invalidateSize(), 200);
        }
        
        function resetMapView() {
            if (mapInstance && imageBounds) {
                mapInstance.fitBounds(imageBounds);
            }
        }
        
        function onMapChange() {
            const mapName = document.getElementById('mapSelect').value;
            // Redraw with currently selected quests (if any)
            initMap(mapName, selectedQuestNamesForMarkers);
        }

        // ============================================================================
        // RAID PLANNING
        // ============================================================================
        
        async function planRaid() {
            const resultBox = document.getElementById('planning-result');
            const mapName = document.getElementById('mapSelect').value;
            const savedQuests = getSavedQuests();
            
            if (savedQuests.size === 0) {
                alert('No operations selected. Please select at least one quest.');
                return;
            }
            
            const selectedQuests = allQuestsGlobal.filter(q => savedQuests.has(q.id));
            
            // Store selected quest names for markers
            selectedQuestNamesForMarkers = selectedQuests.map(q => q.name);
            
            resultBox.style.display = 'block';
            resultBox.scrollIntoView({ behavior: 'smooth' });
            
            // Initialize map with selected quest markers
            await initMap(mapName, selectedQuestNamesForMarkers);
            
            // Collect items provided by quest starts
            const providedItemIds = new Set();
            selectedQuests.forEach(q => {
                if (q.startRewards?.items) {
                    q.startRewards.items.forEach(r => {
                        if (r.item?.id) providedItemIds.add(r.item.id);
                    });
                }
            });
            
            // Collect required keys, items, objectives, unlocks
            const neededKeys = new Map();
            const itemsMap = new Map();
            const objectives = [];
            const unlocks = [];
            
            selectedQuests.forEach(q => {
                if (q.neededKeys) {
                    q.neededKeys.forEach(g => {
                        if (g.keys?.length > 0) {
                            neededKeys.set(g.keys[0].name, g.keys[0]);
                        }
                    });
                }
                
                if (q.objectives) {
                    q.objectives.forEach(o => {
                        objectives.push({ quest: q.name, desc: o.description });
                        
                        const item = o.item || o.markerItem;
                        if (item) {
                            const isProvided = providedItemIds.has(item.id);
                            if (!itemsMap.has(item.id)) {
                                itemsMap.set(item.id, { name: item.name, icon: item.iconLink, count: 0, isProvided });
                            }
                            itemsMap.get(item.id).count += (o.count || 1);
                            if (isProvided) itemsMap.get(item.id).isProvided = true;
                        }
                    });
                }
                
                if (q.derived_unlocks) {
                    q.derived_unlocks.forEach(u => unlocks.push({ from: q.name, ...u }));
                }
            });
            
            // Render results
            document.getElementById('required-keys').innerHTML = neededKeys.size > 0 
                ? Array.from(neededKeys.values()).map(k => `
                    <div class="item-box">
                        ${k.iconLink ? `<img src="${k.iconLink}">` : ''}
                        <span>${k.shortName || k.name}</span>
                    </div>
                `).join('') 
                : '<span class="text-sub p-2">None required.</span>';
            
            const itemsArray = Array.from(itemsMap.values())
                .sort((a, b) => (b.isProvided ? 1 : 0) - (a.isProvided ? 1 : 0));
            
            document.getElementById('required-items').innerHTML = itemsArray.length > 0 
                ? itemsArray.map(i => `
                    <div class="item-box ${i.isProvided ? 'status-provided' : 'status-acquire'}">
                        ${i.icon ? `<img src="${i.icon}">` : ''}
                        <div>${i.count}x ${i.name}</div>
                        <span class="item-label ${i.isProvided ? 'label-given' : 'label-find'}">
                            ${i.isProvided ? 'GIVEN' : 'FIND'}
                        </span>
                    </div>
                `).join('') 
                : '<span class="text-sub p-2">None required.</span>';
            
            // Group objectives by quest for better readability
            const objectivesByQuest = {};
            selectedQuests.forEach(q => {
                if (q.objectives) {
                    objectivesByQuest[q.name] = q.objectives.map(o => o.description);
                }
            });
            
            let objectivesHtml = '';
            Object.entries(objectivesByQuest).forEach(([questName, objs], index) => {
                const color = QUEST_COLORS[index % QUEST_COLORS.length];
                objectivesHtml += `
                    <div class="quest-objectives-group">
                        <div class="quest-objectives-header">
                            <div class="legend-color" style="background: ${color.fill}; border-color: ${color.border}; width: 14px; height: 14px;"></div>
                            <span>${questName}</span>
                        </div>
                        <ul class="quest-objectives-list">
                            ${objs.map((desc, i) => `<li><span class="obj-index">${i + 1}.</span> ${desc}</li>`).join('')}
                        </ul>
                    </div>
                `;
            });
            document.getElementById('mission-steps').innerHTML = objectivesHtml;
            
            document.getElementById('progression-list').innerHTML = unlocks.length > 0 
                ? unlocks.map(u => `
                    <div class="unlock-card">
                        <div style="font-size: 0.8rem; color: var(--text-sub);">From ${u.from}:</div>
                        <div class="fw-bold">
                            <a href="${getWikiUrl(u.name)}" target="_blank" rel="noopener noreferrer" class="unlock-link">${u.name}</a>
                        </div>
                        <div class="small text-sub">${u.map} | ${u.trader}</div>
                    </div>
                `).join('') 
                : '<div class="text-sub p-2">No immediate unlocks.</div>';
        }

        // ============================================================================
        // AMMO MANAGEMENT
        // ============================================================================
        
        function loadSavedAmmo() {
            const saved = localStorage.getItem(STORAGE_KEY_AMMO);
            ownedAmmo = saved ? new Set(JSON.parse(saved)) : new Set();
        }
        
        function saveOwnedAmmo() {
            localStorage.setItem(STORAGE_KEY_AMMO, JSON.stringify([...ownedAmmo]));
        }
        
        async function loadAmmoData() {
            const loading = document.getElementById('ammo-loading');
            const content = document.getElementById('ammo-content');
            const error = document.getElementById('ammo-error');
            const btn = document.getElementById('btn-load-ammo');
            
            content.classList.add('d-none');
            loading.classList.remove('d-none');
            error.classList.add('d-none');
            
            try {
                const response = await fetch(API_BASE + '/ammo');
                if (!response.ok) throw new Error('Server error: ' + response.status);
                
                allAmmoData = await response.json();
                
                const caliberSelect = document.getElementById('caliberFilter');
                caliberSelect.innerHTML = '<option value="ALL">All Calibers</option>';
                allAmmoData.calibers.forEach(cal => {
                    caliberSelect.innerHTML += `<option value="${cal}">${cal}</option>`;
                });
                
                document.getElementById('ammo-count').textContent = allAmmoData.all.length + ' types';
                renderAmmoList();
                
                content.classList.remove('d-none');
                btn.innerHTML = 'Refresh Data';
                btn.classList.add('btn-secondary');
                
            } catch (err) {
                error.innerHTML = `<strong>ERROR:</strong> ${err.message}`;
                error.classList.remove('d-none');
            } finally {
                loading.classList.add('d-none');
            }
        }
        
        function filterAmmoByCaliber() { renderAmmoList(); }
        function filterAmmoBySearch() { renderAmmoList(); }
        
        function updateTierThreshold() {
            const value = parseInt(document.getElementById('tierSlider').value);
            currentTierThreshold = TIER_NAMES[value];
            document.getElementById('tierDisplay').textContent = 'Keep ' + currentTierThreshold + '-Tier+';
            updateAmmoAnalysis();
        }
        
        function renderAmmoList() {
            if (!allAmmoData) return;
            
            const container = document.getElementById('ammo-list');
            const caliberFilter = document.getElementById('caliberFilter').value;
            const searchFilter = document.getElementById('ammoSearch').value.toLowerCase();
            
            let html = '';
            
            if (caliberFilter === 'ALL') {
                for (const [caliber, ammos] of Object.entries(allAmmoData.byCaliber)) {
                    const filtered = ammos.filter(a => 
                        a.name.toLowerCase().includes(searchFilter) || 
                        a.shortName.toLowerCase().includes(searchFilter)
                    );
                    if (filtered.length > 0) {
                        html += renderCaliberGroup(caliber, filtered);
                    }
                }
            } else {
                const ammos = allAmmoData.byCaliber[caliberFilter] || [];
                const filtered = ammos.filter(a => 
                    a.name.toLowerCase().includes(searchFilter) || 
                    a.shortName.toLowerCase().includes(searchFilter)
                );
                html += renderCaliberGroup(caliberFilter, filtered);
            }
            
            container.innerHTML = html;
            updateAmmoAnalysis();
        }
        
        function renderCaliberGroup(caliber, ammos) {
            let html = `
                <div class="caliber-group">
                    <div class="caliber-header">${caliber} <span class="text-sub small">(${ammos.length})</span></div>
            `;
            
            ammos.forEach(a => {
                const isOwned = ownedAmmo.has(a.id);
                const tierInfo = getAmmoTier(a);
                const displayTier = tierInfo.tier;
                const tierSource = tierInfo.source;
                const isOverridden = tierOverrides[a.id] !== undefined;
                
                // Source indicator color
                const sourceClass = tierSource === 'PEN' ? 'source-pen' : tierSource === 'DMG' ? 'source-dmg' : tierSource === 'PEN+DMG' ? 'source-both' : '';
                
                html += `
                    <div class="ammo-card ${isOwned ? 'owned' : ''} ${isOverridden ? 'overridden' : ''}" onclick="toggleAmmoOwned('${a.id}')">
                        <span class="tier-badge tier-${displayTier}">${displayTier}</span>
                        ${a.iconLink ? `<img src="${a.iconLink}">` : ''}
                        <div class="flex-grow-1">
                            <div class="fw-bold" style="color: var(--text-main);">${a.shortName}</div>
                            <div class="ammo-stats">
                                <span class="stat-dmg ${tierSource.includes('DMG') ? 'stat-highlight' : ''}">DMG ${a.damage}</span>
                                <span class="stat-pen ${tierSource.includes('PEN') ? 'stat-highlight' : ''}">PEN ${a.penetration}</span>
                                ${a.sellPrice > 0 ? `<span class="stat-price">${a.sellPrice.toLocaleString()} RUB</span>` : ''}
                            </div>
                        </div>
                        <span class="tier-source ${sourceClass}">${tierSource}</span>
                        ${isOwned ? '<span class="badge-tarkov badge-active">OWNED</span>' : ''}
                        <select class="tier-select-mini" onclick="event.stopPropagation()" onchange="setTierOverride('${a.id}', this.value)">
                            <option value="" ${!isOverridden ? 'selected' : ''}>Auto</option>
                            ${TIER_NAMES.map(t => `<option value="${t}" ${tierOverrides[a.id] === t ? 'selected' : ''}>${t}</option>`).join('')}
                        </select>
                    </div>
                `;
            });
            
            return html + '</div>';
        }
        
        function getAmmoTier(ammo) {
            // Check for manual override first
            if (tierOverrides[ammo.id]) {
                return { tier: tierOverrides[ammo.id], source: 'CUSTOM' };
            }
            
            // Calculate based on penetration OR damage thresholds
            const pen = ammo.penetration;
            const dmg = ammo.damage;
            
            // Check each tier - if either pen OR dmg meets threshold, ammo qualifies
            for (const tier of ['S', 'A', 'B', 'C', 'D']) {
                const penMet = pen >= tierThresholds.pen[tier];
                const dmgMet = dmg >= tierThresholds.dmg[tier];
                
                if (penMet || dmgMet) {
                    // Determine which stat(s) qualified
                    let source = '';
                    if (penMet && dmgMet) source = 'PEN+DMG';
                    else if (penMet) source = 'PEN';
                    else source = 'DMG';
                    
                    return { tier, source };
                }
            }
            
            return { tier: 'F', source: '-' };
        }
        
        function getAmmoTierSimple(ammo) {
            return getAmmoTier(ammo).tier;
        }
        
        function setTierOverride(ammoId, tier) {
            if (tier === '') {
                delete tierOverrides[ammoId];
            } else {
                tierOverrides[ammoId] = tier;
            }
            saveTierOverrides();
            renderAmmoList();
        }
        
        function updateTierConfig() {
            tierThresholds.pen.S = parseInt(document.getElementById('tierThresholdS').value) || 55;
            tierThresholds.pen.A = parseInt(document.getElementById('tierThresholdA').value) || 45;
            tierThresholds.pen.B = parseInt(document.getElementById('tierThresholdB').value) || 35;
            tierThresholds.pen.C = parseInt(document.getElementById('tierThresholdC').value) || 25;
            tierThresholds.pen.D = parseInt(document.getElementById('tierThresholdD').value) || 15;
            
            tierThresholds.dmg.S = parseInt(document.getElementById('tierDmgThresholdS').value) || 80;
            tierThresholds.dmg.A = parseInt(document.getElementById('tierDmgThresholdA').value) || 65;
            tierThresholds.dmg.B = parseInt(document.getElementById('tierDmgThresholdB').value) || 50;
            tierThresholds.dmg.C = parseInt(document.getElementById('tierDmgThresholdC').value) || 40;
            tierThresholds.dmg.D = parseInt(document.getElementById('tierDmgThresholdD').value) || 30;
            
            saveTierConfig();
            renderAmmoList();
        }
        
        function resetTierConfig() {
            tierThresholds = JSON.parse(JSON.stringify(DEFAULT_TIER_THRESHOLDS));
            // Penetration inputs
            document.getElementById('tierThresholdS').value = tierThresholds.pen.S;
            document.getElementById('tierThresholdA').value = tierThresholds.pen.A;
            document.getElementById('tierThresholdB').value = tierThresholds.pen.B;
            document.getElementById('tierThresholdC').value = tierThresholds.pen.C;
            document.getElementById('tierThresholdD').value = tierThresholds.pen.D;
            // Damage inputs
            document.getElementById('tierDmgThresholdS').value = tierThresholds.dmg.S;
            document.getElementById('tierDmgThresholdA').value = tierThresholds.dmg.A;
            document.getElementById('tierDmgThresholdB').value = tierThresholds.dmg.B;
            document.getElementById('tierDmgThresholdC').value = tierThresholds.dmg.C;
            document.getElementById('tierDmgThresholdD').value = tierThresholds.dmg.D;
            saveTierConfig();
            renderAmmoList();
        }
        
        function clearTierOverrides() {
            tierOverrides = {};
            saveTierOverrides();
            renderAmmoList();
        }
        
        function saveTierConfig() {
            localStorage.setItem(STORAGE_KEY_TIER_CONFIG, JSON.stringify(tierThresholds));
        }
        
        function loadTierConfig() {
            const saved = localStorage.getItem(STORAGE_KEY_TIER_CONFIG);
            if (saved) {
                const parsed = JSON.parse(saved);
                // Handle old format (flat) vs new format (nested)
                if (parsed.pen) {
                    tierThresholds = parsed;
                } else {
                    // Old format - convert
                    tierThresholds = {
                        pen: { S: parsed.S || 55, A: parsed.A || 45, B: parsed.B || 35, C: parsed.C || 25, D: parsed.D || 15 },
                        dmg: { S: 80, A: 65, B: 50, C: 40, D: 30 }
                    };
                }
            }
            // Update inputs
            document.getElementById('tierThresholdS').value = tierThresholds.pen.S;
            document.getElementById('tierThresholdA').value = tierThresholds.pen.A;
            document.getElementById('tierThresholdB').value = tierThresholds.pen.B;
            document.getElementById('tierThresholdC').value = tierThresholds.pen.C;
            document.getElementById('tierThresholdD').value = tierThresholds.pen.D;
            document.getElementById('tierDmgThresholdS').value = tierThresholds.dmg.S;
            document.getElementById('tierDmgThresholdA').value = tierThresholds.dmg.A;
            document.getElementById('tierDmgThresholdB').value = tierThresholds.dmg.B;
            document.getElementById('tierDmgThresholdC').value = tierThresholds.dmg.C;
            document.getElementById('tierDmgThresholdD').value = tierThresholds.dmg.D;
        }
        
        function saveTierOverrides() {
            localStorage.setItem(STORAGE_KEY_TIER_OVERRIDES, JSON.stringify(tierOverrides));
        }
        
        function loadTierOverrides() {
            const saved = localStorage.getItem(STORAGE_KEY_TIER_OVERRIDES);
            if (saved) {
                tierOverrides = JSON.parse(saved);
            }
        }
        
        function toggleAmmoOwned(id) {
            ownedAmmo.has(id) ? ownedAmmo.delete(id) : ownedAmmo.add(id);
            saveOwnedAmmo();
            renderAmmoList();
        }
        
        function updateAmmoAnalysis() {
            if (!allAmmoData) return;
            
            const keepList = document.getElementById('keep-list');
            const sellList = document.getElementById('sell-list');
            const keepCount = document.getElementById('keep-count');
            const sellCount = document.getElementById('sell-count');
            const totalValue = document.getElementById('total-sell-value');
            
            const tierIndex = TIER_ORDER.indexOf(currentTierThreshold);
            const keepTiers = TIER_ORDER.slice(0, tierIndex + 1);
            
            const owned = allAmmoData.all.filter(a => ownedAmmo.has(a.id));
            const keep = owned.filter(a => keepTiers.includes(getAmmoTier(a).tier));
            const sell = owned.filter(a => !keepTiers.includes(getAmmoTier(a).tier));
            
            keepCount.textContent = keep.length;
            sellCount.textContent = sell.length;
            
            keepList.innerHTML = keep.length > 0 
                ? keep.map(a => renderAnalysisItem(a, 'keep')).join('') 
                : '<div class="text-sub p-2 small">No ammo to keep marked.</div>';
            
            sellList.innerHTML = sell.length > 0 
                ? sell.map(a => renderAnalysisItem(a, 'sell')).join('') 
                : '<div class="text-sub p-2 small">No ammo to sell.</div>';
            
            totalValue.textContent = sell.reduce((sum, a) => sum + (a.sellPrice || 0), 0).toLocaleString() + ' RUB';
        }
        
        function renderAnalysisItem(ammo, type) {
            const tierInfo = getAmmoTier(ammo);
            const displayTier = tierInfo.tier;
            return `
                <div class="item-box ${type === 'keep' ? 'status-provided' : 'status-acquire'} w-100 mb-1">
                    <span class="tier-badge tier-${displayTier}" style="width:24px;height:24px;line-height:24px;font-size:0.75rem;">${displayTier}</span>
                    ${ammo.iconLink ? `<img src="${ammo.iconLink}" style="width:28px;height:28px;">` : ''}
                    <div class="flex-grow-1">
                        <div style="font-size:0.85rem;">${ammo.shortName}</div>
                        <div style="font-size:0.7rem;color:var(--text-sub);">${ammo.caliber}</div>
                    </div>
                    ${type === 'sell' && ammo.sellPrice > 0 ? `<span class="stat-price small">${ammo.sellPrice.toLocaleString()} RUB</span>` : ''}
                </div>
            `;
        }

        // ============================================================================
        // WEAPONS MANAGER
        // ============================================================================
        
        async function loadWeaponsData() {
            const loading = document.getElementById('weapons-loading');
            const content = document.getElementById('weapons-content');
            const error = document.getElementById('weapons-error');
            const btn = document.getElementById('btn-load-weapons');
            
            loading.classList.remove('d-none');
            content.classList.add('d-none');
            error.classList.add('d-none');
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            try {
                const query = `{
                    items(types: [gun]) {
                        id
                        name
                        shortName
                        iconLink
                        avg24hPrice
                        sellFor { price vendor { name } }
                        types
                        properties {
                            ... on ItemPropertiesWeapon {
                                caliber
                                fireRate
                                ergonomics
                                recoilVertical
                                recoilHorizontal
                                effectiveDistance
                            }
                        }
                    }
                }`;
                
                const response = await fetch('https://api.tarkov.dev/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                
                const data = await response.json();
                
                if (data.errors) throw new Error(data.errors[0].message);
                
                // Process weapons
                const weapons = data.data.items.map(w => {
                    const props = w.properties || {};
                    const bestSell = w.sellFor?.reduce((best, s) => s.price > best.price ? s : best, { price: 0 }) || { price: 0 };
                    return {
                        id: w.id,
                        name: w.name,
                        shortName: w.shortName,
                        iconLink: w.iconLink,
                        caliber: props.caliber || 'Unknown',
                        fireRate: props.fireRate || 0,
                        ergonomics: props.ergonomics || 0,
                        recoilVertical: props.recoilVertical || 0,
                        recoilHorizontal: props.recoilHorizontal || 0,
                        totalRecoil: (props.recoilVertical || 0) + (props.recoilHorizontal || 0),
                        effectiveDistance: props.effectiveDistance || 0,
                        sellPrice: bestSell.price,
                        sellTo: bestSell.vendor?.name || 'Fence',
                        types: w.types || []
                    };
                }).filter(w => w.ergonomics > 0); // Filter out items without weapon stats
                
                // Group by caliber
                const byCaliber = {};
                weapons.forEach(w => {
                    const cal = w.caliber || 'Other';
                    if (!byCaliber[cal]) byCaliber[cal] = [];
                    byCaliber[cal].push(w);
                });
                
                // Sort within each caliber by tier
                Object.values(byCaliber).forEach(arr => {
                    arr.sort((a, b) => {
                        const tierA = TIER_ORDER.indexOf(getWeaponTier(a).tier);
                        const tierB = TIER_ORDER.indexOf(getWeaponTier(b).tier);
                        return tierA - tierB;
                    });
                });
                
                allWeaponsData = { all: weapons, byCaliber };
                
                // Populate type filter
                const typeFilter = document.getElementById('weaponTypeFilter');
                const calibers = Object.keys(byCaliber).sort();
                typeFilter.innerHTML = '<option value="ALL">All Calibers (' + weapons.length + ')</option>' +
                    calibers.map(c => `<option value="${c}">${c} (${byCaliber[c].length})</option>`).join('');
                
                document.getElementById('weapon-count').textContent = weapons.length;
                
                loading.classList.add('d-none');
                content.classList.remove('d-none');
                btn.textContent = 'Reload';
                btn.disabled = false;
                
                loadOwnedWeapons();
                loadWeaponTierConfig();
                loadWeaponTierOverrides();
                renderWeaponsList();
                
            } catch (err) {
                loading.classList.add('d-none');
                error.classList.remove('d-none');
                error.textContent = 'Error loading weapons: ' + err.message;
                btn.textContent = 'Retry';
                btn.disabled = false;
            }
        }
        
        function renderWeaponsList() {
            if (!allWeaponsData) return;
            
            const container = document.getElementById('weapons-list');
            let html = '';
            
            const calibers = weaponTypeFilter === 'ALL' 
                ? Object.keys(allWeaponsData.byCaliber).sort()
                : [weaponTypeFilter];
            
            calibers.forEach(cal => {
                let weapons = allWeaponsData.byCaliber[cal] || [];
                
                // Apply search filter
                if (weaponSearchQuery) {
                    const q = weaponSearchQuery.toLowerCase();
                    weapons = weapons.filter(w => 
                        w.name.toLowerCase().includes(q) || 
                        w.shortName.toLowerCase().includes(q)
                    );
                }
                
                if (weapons.length === 0) return;
                
                html += `<div class="caliber-group mb-3">
                    <div class="caliber-header">${cal} (${weapons.length})</div>
                    <div class="ammo-grid">`;
                
                weapons.forEach(w => {
                    const isOwned = ownedWeapons.has(w.id);
                    const tierInfo = getWeaponTier(w);
                    const isOverridden = weaponTierOverrides[w.id] !== undefined;
                    const sourceClass = tierInfo.source === 'ERGO' ? 'source-pen' : tierInfo.source === 'RECOIL' ? 'source-dmg' : tierInfo.source === 'ERGO+RECOIL' ? 'source-both' : '';
                    
                    html += `
                        <div class="ammo-card ${isOwned ? 'owned' : ''} ${isOverridden ? 'overridden' : ''}" onclick="toggleWeaponOwned('${w.id}')">
                            <span class="tier-badge tier-${tierInfo.tier}">${tierInfo.tier}</span>
                            ${w.iconLink ? `<img src="${w.iconLink}">` : ''}
                            <div class="flex-grow-1">
                                <div class="fw-bold" style="color: var(--text-main);">${w.shortName}</div>
                                <div class="ammo-stats">
                                    <span class="stat-pen ${tierInfo.source.includes('ERGO') ? 'stat-highlight' : ''}">ERG ${w.ergonomics}</span>
                                    <span class="stat-dmg ${tierInfo.source.includes('RECOIL') ? 'stat-highlight' : ''}">REC ${w.totalRecoil}</span>
                                    ${w.sellPrice > 0 ? `<span class="stat-price">${w.sellPrice.toLocaleString()}</span>` : ''}
                                </div>
                            </div>
                            <span class="tier-source ${sourceClass}">${tierInfo.source}</span>
                            ${isOwned ? '<span class="badge-tarkov badge-active">OWNED</span>' : ''}
                            <select class="tier-select-mini" onclick="event.stopPropagation()" onchange="setWeaponTierOverride('${w.id}', this.value)">
                                <option value="" ${!isOverridden ? 'selected' : ''}>Auto</option>
                                ${TIER_NAMES.map(t => `<option value="${t}" ${weaponTierOverrides[w.id] === t ? 'selected' : ''}>${t}</option>`).join('')}
                            </select>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            container.innerHTML = html || '<div class="text-sub p-3">No weapons match your filter.</div>';
            updateWeaponAnalysis();
        }
        
        function getWeaponTier(weapon) {
            if (weaponTierOverrides[weapon.id]) {
                return { tier: weaponTierOverrides[weapon.id], source: 'CUSTOM' };
            }
            
            const ergo = weapon.ergonomics;
            const recoil = weapon.totalRecoil;
            
            for (const tier of ['S', 'A', 'B', 'C', 'D']) {
                const ergoMet = ergo >= weaponTierThresholds.ergo[tier];
                const recoilMet = recoil <= weaponTierThresholds.recoil[tier];
                
                if (ergoMet || recoilMet) {
                    let source = '';
                    if (ergoMet && recoilMet) source = 'ERGO+RECOIL';
                    else if (ergoMet) source = 'ERGO';
                    else source = 'RECOIL';
                    return { tier, source };
                }
            }
            return { tier: 'F', source: '-' };
        }
        
        function filterWeapons() {
            weaponTypeFilter = document.getElementById('weaponTypeFilter').value;
            weaponSearchQuery = document.getElementById('weaponSearch').value;
            renderWeaponsList();
        }
        
        function toggleWeaponOwned(id) {
            ownedWeapons.has(id) ? ownedWeapons.delete(id) : ownedWeapons.add(id);
            saveOwnedWeapons();
            renderWeaponsList();
        }
        
        function setWeaponTierOverride(id, tier) {
            if (tier === '') delete weaponTierOverrides[id];
            else weaponTierOverrides[id] = tier;
            saveWeaponTierOverrides();
            renderWeaponsList();
        }
        
        function updateWeaponTierConfig() {
            weaponTierThresholds.ergo.S = parseInt(document.getElementById('weaponTierErgoS').value) || 70;
            weaponTierThresholds.ergo.A = parseInt(document.getElementById('weaponTierErgoA').value) || 55;
            weaponTierThresholds.ergo.B = parseInt(document.getElementById('weaponTierErgoB').value) || 40;
            weaponTierThresholds.ergo.C = parseInt(document.getElementById('weaponTierErgoC').value) || 28;
            weaponTierThresholds.ergo.D = parseInt(document.getElementById('weaponTierErgoD').value) || 15;
            weaponTierThresholds.recoil.S = parseInt(document.getElementById('weaponTierRecoilS').value) || 50;
            weaponTierThresholds.recoil.A = parseInt(document.getElementById('weaponTierRecoilA').value) || 80;
            weaponTierThresholds.recoil.B = parseInt(document.getElementById('weaponTierRecoilB').value) || 120;
            weaponTierThresholds.recoil.C = parseInt(document.getElementById('weaponTierRecoilC').value) || 180;
            weaponTierThresholds.recoil.D = parseInt(document.getElementById('weaponTierRecoilD').value) || 250;
            saveWeaponTierConfig();
            renderWeaponsList();
        }
        
        function resetWeaponTierConfig() {
            weaponTierThresholds = JSON.parse(JSON.stringify(DEFAULT_WEAPON_TIER_THRESHOLDS));
            document.getElementById('weaponTierErgoS').value = weaponTierThresholds.ergo.S;
            document.getElementById('weaponTierErgoA').value = weaponTierThresholds.ergo.A;
            document.getElementById('weaponTierErgoB').value = weaponTierThresholds.ergo.B;
            document.getElementById('weaponTierErgoC').value = weaponTierThresholds.ergo.C;
            document.getElementById('weaponTierErgoD').value = weaponTierThresholds.ergo.D;
            document.getElementById('weaponTierRecoilS').value = weaponTierThresholds.recoil.S;
            document.getElementById('weaponTierRecoilA').value = weaponTierThresholds.recoil.A;
            document.getElementById('weaponTierRecoilB').value = weaponTierThresholds.recoil.B;
            document.getElementById('weaponTierRecoilC').value = weaponTierThresholds.recoil.C;
            document.getElementById('weaponTierRecoilD').value = weaponTierThresholds.recoil.D;
            saveWeaponTierConfig();
            renderWeaponsList();
        }
        
        function clearWeaponOverrides() {
            weaponTierOverrides = {};
            saveWeaponTierOverrides();
            renderWeaponsList();
        }
        
        function updateWeaponTierThreshold() {
            const val = parseInt(document.getElementById('weaponTierSlider').value);
            currentWeaponTierThreshold = TIER_ORDER[val];
            document.getElementById('weaponTierDisplay').textContent = `Keep ${currentWeaponTierThreshold}-Tier+`;
            updateWeaponAnalysis();
        }
        
        function updateWeaponAnalysis() {
            if (!allWeaponsData) return;
            
            const tierIndex = TIER_ORDER.indexOf(currentWeaponTierThreshold);
            const keepTiers = TIER_ORDER.slice(0, tierIndex + 1);
            
            const owned = allWeaponsData.all.filter(w => ownedWeapons.has(w.id));
            const keep = owned.filter(w => keepTiers.includes(getWeaponTier(w).tier));
            const sell = owned.filter(w => !keepTiers.includes(getWeaponTier(w).tier));
            
            document.getElementById('weapon-keep-count').textContent = keep.length;
            document.getElementById('weapon-sell-count').textContent = sell.length;
            
            document.getElementById('weapon-keep-list').innerHTML = keep.length > 0
                ? keep.map(w => renderEquipmentAnalysisItem(w, 'keep', getWeaponTier(w))).join('')
                : '<div class="text-sub p-2 small">No weapons to keep marked.</div>';
            
            document.getElementById('weapon-sell-list').innerHTML = sell.length > 0
                ? sell.map(w => renderEquipmentAnalysisItem(w, 'sell', getWeaponTier(w))).join('')
                : '<div class="text-sub p-2 small">No weapons to sell.</div>';
            
            document.getElementById('weapon-total-sell-value').textContent = 
                sell.reduce((sum, w) => sum + (w.sellPrice || 0), 0).toLocaleString() + ' RUB';
        }
        
        function saveOwnedWeapons() { localStorage.setItem(STORAGE_KEY_WEAPONS, JSON.stringify([...ownedWeapons])); }
        function loadOwnedWeapons() { const s = localStorage.getItem(STORAGE_KEY_WEAPONS); if (s) ownedWeapons = new Set(JSON.parse(s)); }
        function saveWeaponTierConfig() { localStorage.setItem(STORAGE_KEY_WEAPONS_TIER, JSON.stringify(weaponTierThresholds)); }
        function loadWeaponTierConfig() { 
            const s = localStorage.getItem(STORAGE_KEY_WEAPONS_TIER); 
            if (s) weaponTierThresholds = JSON.parse(s);
            document.getElementById('weaponTierErgoS').value = weaponTierThresholds.ergo.S;
            document.getElementById('weaponTierErgoA').value = weaponTierThresholds.ergo.A;
            document.getElementById('weaponTierErgoB').value = weaponTierThresholds.ergo.B;
            document.getElementById('weaponTierErgoC').value = weaponTierThresholds.ergo.C;
            document.getElementById('weaponTierErgoD').value = weaponTierThresholds.ergo.D;
            document.getElementById('weaponTierRecoilS').value = weaponTierThresholds.recoil.S;
            document.getElementById('weaponTierRecoilA').value = weaponTierThresholds.recoil.A;
            document.getElementById('weaponTierRecoilB').value = weaponTierThresholds.recoil.B;
            document.getElementById('weaponTierRecoilC').value = weaponTierThresholds.recoil.C;
            document.getElementById('weaponTierRecoilD').value = weaponTierThresholds.recoil.D;
        }
        function saveWeaponTierOverrides() { localStorage.setItem(STORAGE_KEY_WEAPONS_OVERRIDES, JSON.stringify(weaponTierOverrides)); }
        function loadWeaponTierOverrides() { const s = localStorage.getItem(STORAGE_KEY_WEAPONS_OVERRIDES); if (s) weaponTierOverrides = JSON.parse(s); }
        
        // ============================================================================
        // GEAR MANAGER
        // ============================================================================
        
        async function loadGearData() {
            const loading = document.getElementById('gear-loading');
            const content = document.getElementById('gear-content');
            const error = document.getElementById('gear-error');
            const btn = document.getElementById('btn-load-gear');
            
            loading.classList.remove('d-none');
            content.classList.add('d-none');
            error.classList.add('d-none');
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            try {
                const query = `{
                    items(types: [armor, helmet, rig, backpack, headphones]) {
                        id
                        name
                        shortName
                        iconLink
                        avg24hPrice
                        sellFor { price vendor { name } }
                        types
                        properties {
                            ... on ItemPropertiesArmor {
                                class
                                durability
                                material { name }
                                zones
                                ergoPenalty
                                speedPenalty
                                turnPenalty
                            }
                            ... on ItemPropertiesHelmet {
                                class
                                durability
                                material { name }
                                zones
                                ergoPenalty
                                speedPenalty
                                turnPenalty
                                ricochetY
                            }
                            ... on ItemPropertiesChestRig {
                                class
                                durability
                                material { name }
                                zones
                                capacity
                            }
                            ... on ItemPropertiesBackpack {
                                capacity
                                speedPenalty
                            }
                            ... on ItemPropertiesHeadphone {
                                ambientVolume
                                distortion
                            }
                        }
                    }
                }`;
                
                const response = await fetch('https://api.tarkov.dev/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                
                const data = await response.json();
                if (data.errors) throw new Error(data.errors[0].message);
                
                const gear = data.data.items.map(g => {
                    const props = g.properties || {};
                    const bestSell = g.sellFor?.reduce((best, s) => s.price > best.price ? s : best, { price: 0 }) || { price: 0 };
                    
                    // Determine gear type
                    let gearType = 'other';
                    if (g.types?.includes('armor')) gearType = 'armor';
                    else if (g.types?.includes('helmet')) gearType = 'helmet';
                    else if (g.types?.includes('backpack')) gearType = 'backpack';
                    else if (g.types?.includes('rig')) gearType = 'rig';
                    else if (g.types?.includes('headphones')) gearType = 'headphones';
                    
                    return {
                        id: g.id,
                        name: g.name,
                        shortName: g.shortName,
                        iconLink: g.iconLink,
                        gearType,
                        armorClass: props.class || 0,
                        durability: props.durability || 0,
                        material: props.material?.name || '',
                        capacity: props.capacity || 0,
                        ergoPenalty: props.ergoPenalty || 0,
                        speedPenalty: props.speedPenalty || 0,
                        ambientVolume: props.ambientVolume || 0,
                        sellPrice: bestSell.price,
                        sellTo: bestSell.vendor?.name || 'Fence'
                    };
                });
                
                // Group by type
                const byType = {};
                gear.forEach(g => {
                    if (!byType[g.gearType]) byType[g.gearType] = [];
                    byType[g.gearType].push(g);
                });
                
                // Sort by tier
                Object.values(byType).forEach(arr => {
                    arr.sort((a, b) => TIER_ORDER.indexOf(getGearTier(a).tier) - TIER_ORDER.indexOf(getGearTier(b).tier));
                });
                
                allGearData = { all: gear, byType };
                document.getElementById('gear-count').textContent = gear.length;
                
                loading.classList.add('d-none');
                content.classList.remove('d-none');
                btn.textContent = 'Reload';
                btn.disabled = false;
                
                loadOwnedGear();
                loadGearTierConfig();
                loadGearTierOverrides();
                renderGearList();
                
            } catch (err) {
                loading.classList.add('d-none');
                error.classList.remove('d-none');
                error.textContent = 'Error loading gear: ' + err.message;
                btn.textContent = 'Retry';
                btn.disabled = false;
            }
        }
        
        function renderGearList() {
            if (!allGearData) return;
            
            const container = document.getElementById('gear-list');
            let html = '';
            
            const typeLabels = { armor: 'Body Armor', helmet: 'Helmets', rig: 'Tactical Rigs', backpack: 'Backpacks', headphones: 'Headsets' };
            const types = gearTypeFilter === 'ALL' ? Object.keys(allGearData.byType) : [gearTypeFilter];
            
            types.forEach(type => {
                let items = allGearData.byType[type] || [];
                
                if (gearSearchQuery) {
                    const q = gearSearchQuery.toLowerCase();
                    items = items.filter(g => g.name.toLowerCase().includes(q) || g.shortName.toLowerCase().includes(q));
                }
                
                if (items.length === 0) return;
                
                html += `<div class="caliber-group mb-3">
                    <div class="caliber-header">${typeLabels[type] || type} (${items.length})</div>
                    <div class="ammo-grid">`;
                
                items.forEach(g => {
                    const isOwned = ownedGear.has(g.id);
                    const tierInfo = getGearTier(g);
                    const isOverridden = gearTierOverrides[g.id] !== undefined;
                    const sourceClass = tierInfo.source === 'CLASS' ? 'source-pen' : tierInfo.source === 'DUR' ? 'source-dmg' : tierInfo.source === 'CLASS+DUR' ? 'source-both' : '';
                    
                    // Show relevant stats based on type
                    let statsHtml = '';
                    if (g.armorClass > 0) {
                        statsHtml += `<span class="stat-pen ${tierInfo.source.includes('CLASS') ? 'stat-highlight' : ''}">CL ${g.armorClass}</span>`;
                        statsHtml += `<span class="stat-dmg ${tierInfo.source.includes('DUR') ? 'stat-highlight' : ''}">DUR ${g.durability}</span>`;
                    } else if (g.gearType === 'backpack') {
                        statsHtml += `<span class="stat-pen">CAP ${g.capacity}</span>`;
                    } else if (g.gearType === 'headphones') {
                        statsHtml += `<span class="stat-pen">VOL ${g.ambientVolume}</span>`;
                    }
                    if (g.sellPrice > 0) statsHtml += `<span class="stat-price">${g.sellPrice.toLocaleString()}</span>`;
                    
                    html += `
                        <div class="ammo-card ${isOwned ? 'owned' : ''} ${isOverridden ? 'overridden' : ''}" onclick="toggleGearOwned('${g.id}')">
                            <span class="tier-badge tier-${tierInfo.tier}">${tierInfo.tier}</span>
                            ${g.iconLink ? `<img src="${g.iconLink}">` : ''}
                            <div class="flex-grow-1">
                                <div class="fw-bold" style="color: var(--text-main);">${g.shortName}</div>
                                <div class="ammo-stats">${statsHtml}</div>
                            </div>
                            <span class="tier-source ${sourceClass}">${tierInfo.source}</span>
                            ${isOwned ? '<span class="badge-tarkov badge-active">OWNED</span>' : ''}
                            <select class="tier-select-mini" onclick="event.stopPropagation()" onchange="setGearTierOverride('${g.id}', this.value)">
                                <option value="" ${!isOverridden ? 'selected' : ''}>Auto</option>
                                ${TIER_NAMES.map(t => `<option value="${t}" ${gearTierOverrides[g.id] === t ? 'selected' : ''}>${t}</option>`).join('')}
                            </select>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            container.innerHTML = html || '<div class="text-sub p-3">No gear matches your filter.</div>';
            updateGearAnalysis();
        }
        
        function getGearTier(gear) {
            if (gearTierOverrides[gear.id]) return { tier: gearTierOverrides[gear.id], source: 'CUSTOM' };
            
            // For non-armor items, use simple tier based on sell value or capacity
            if (gear.armorClass === 0) {
                if (gear.gearType === 'backpack') {
                    if (gear.capacity >= 50) return { tier: 'S', source: 'CAP' };
                    if (gear.capacity >= 35) return { tier: 'A', source: 'CAP' };
                    if (gear.capacity >= 25) return { tier: 'B', source: 'CAP' };
                    if (gear.capacity >= 15) return { tier: 'C', source: 'CAP' };
                    if (gear.capacity >= 8) return { tier: 'D', source: 'CAP' };
                    return { tier: 'F', source: '-' };
                }
                if (gear.gearType === 'headphones') {
                    // Higher ambient volume = better sound quality generally
                    if (gear.sellPrice >= 50000) return { tier: 'S', source: 'VALUE' };
                    if (gear.sellPrice >= 30000) return { tier: 'A', source: 'VALUE' };
                    if (gear.sellPrice >= 15000) return { tier: 'B', source: 'VALUE' };
                    return { tier: 'C', source: 'VALUE' };
                }
                return { tier: 'C', source: '-' };
            }
            
            const armorClass = gear.armorClass;
            const dur = gear.durability;
            
            for (const tier of ['S', 'A', 'B', 'C', 'D']) {
                const classMet = armorClass >= gearTierThresholds.armorClass[tier];
                const durMet = dur >= gearTierThresholds.durability[tier];
                
                if (classMet || durMet) {
                    let source = '';
                    if (classMet && durMet) source = 'CLASS+DUR';
                    else if (classMet) source = 'CLASS';
                    else source = 'DUR';
                    return { tier, source };
                }
            }
            return { tier: 'F', source: '-' };
        }
        
        function filterGear() {
            gearTypeFilter = document.getElementById('gearTypeFilter').value;
            gearSearchQuery = document.getElementById('gearSearch').value;
            renderGearList();
        }
        
        function toggleGearOwned(id) {
            ownedGear.has(id) ? ownedGear.delete(id) : ownedGear.add(id);
            saveOwnedGear();
            renderGearList();
        }
        
        function setGearTierOverride(id, tier) {
            if (tier === '') delete gearTierOverrides[id];
            else gearTierOverrides[id] = tier;
            saveGearTierOverrides();
            renderGearList();
        }
        
        function updateGearTierConfig() {
            gearTierThresholds.armorClass.S = parseInt(document.getElementById('gearTierClassS').value) || 6;
            gearTierThresholds.armorClass.A = parseInt(document.getElementById('gearTierClassA').value) || 5;
            gearTierThresholds.armorClass.B = parseInt(document.getElementById('gearTierClassB').value) || 4;
            gearTierThresholds.armorClass.C = parseInt(document.getElementById('gearTierClassC').value) || 3;
            gearTierThresholds.armorClass.D = parseInt(document.getElementById('gearTierClassD').value) || 2;
            gearTierThresholds.durability.S = parseInt(document.getElementById('gearTierDurS').value) || 70;
            gearTierThresholds.durability.A = parseInt(document.getElementById('gearTierDurA').value) || 55;
            gearTierThresholds.durability.B = parseInt(document.getElementById('gearTierDurB').value) || 40;
            gearTierThresholds.durability.C = parseInt(document.getElementById('gearTierDurC').value) || 30;
            gearTierThresholds.durability.D = parseInt(document.getElementById('gearTierDurD').value) || 20;
            saveGearTierConfig();
            renderGearList();
        }
        
        function resetGearTierConfig() {
            gearTierThresholds = JSON.parse(JSON.stringify(DEFAULT_GEAR_TIER_THRESHOLDS));
            document.getElementById('gearTierClassS').value = gearTierThresholds.armorClass.S;
            document.getElementById('gearTierClassA').value = gearTierThresholds.armorClass.A;
            document.getElementById('gearTierClassB').value = gearTierThresholds.armorClass.B;
            document.getElementById('gearTierClassC').value = gearTierThresholds.armorClass.C;
            document.getElementById('gearTierClassD').value = gearTierThresholds.armorClass.D;
            document.getElementById('gearTierDurS').value = gearTierThresholds.durability.S;
            document.getElementById('gearTierDurA').value = gearTierThresholds.durability.A;
            document.getElementById('gearTierDurB').value = gearTierThresholds.durability.B;
            document.getElementById('gearTierDurC').value = gearTierThresholds.durability.C;
            document.getElementById('gearTierDurD').value = gearTierThresholds.durability.D;
            saveGearTierConfig();
            renderGearList();
        }
        
        function clearGearOverrides() {
            gearTierOverrides = {};
            saveGearTierOverrides();
            renderGearList();
        }
        
        function updateGearTierThreshold() {
            const val = parseInt(document.getElementById('gearTierSlider').value);
            currentGearTierThreshold = TIER_ORDER[val];
            document.getElementById('gearTierDisplay').textContent = `Keep ${currentGearTierThreshold}-Tier+`;
            updateGearAnalysis();
        }
        
        function updateGearAnalysis() {
            if (!allGearData) return;
            
            const tierIndex = TIER_ORDER.indexOf(currentGearTierThreshold);
            const keepTiers = TIER_ORDER.slice(0, tierIndex + 1);
            
            const owned = allGearData.all.filter(g => ownedGear.has(g.id));
            const keep = owned.filter(g => keepTiers.includes(getGearTier(g).tier));
            const sell = owned.filter(g => !keepTiers.includes(getGearTier(g).tier));
            
            document.getElementById('gear-keep-count').textContent = keep.length;
            document.getElementById('gear-sell-count').textContent = sell.length;
            
            document.getElementById('gear-keep-list').innerHTML = keep.length > 0
                ? keep.map(g => renderEquipmentAnalysisItem(g, 'keep', getGearTier(g))).join('')
                : '<div class="text-sub p-2 small">No gear to keep marked.</div>';
            
            document.getElementById('gear-sell-list').innerHTML = sell.length > 0
                ? sell.map(g => renderEquipmentAnalysisItem(g, 'sell', getGearTier(g))).join('')
                : '<div class="text-sub p-2 small">No gear to sell.</div>';
            
            document.getElementById('gear-total-sell-value').textContent =
                sell.reduce((sum, g) => sum + (g.sellPrice || 0), 0).toLocaleString() + ' RUB';
        }
        
        function saveOwnedGear() { localStorage.setItem(STORAGE_KEY_GEAR, JSON.stringify([...ownedGear])); }
        function loadOwnedGear() { const s = localStorage.getItem(STORAGE_KEY_GEAR); if (s) ownedGear = new Set(JSON.parse(s)); }
        function saveGearTierConfig() { localStorage.setItem(STORAGE_KEY_GEAR_TIER, JSON.stringify(gearTierThresholds)); }
        function loadGearTierConfig() {
            const s = localStorage.getItem(STORAGE_KEY_GEAR_TIER);
            if (s) gearTierThresholds = JSON.parse(s);
            document.getElementById('gearTierClassS').value = gearTierThresholds.armorClass.S;
            document.getElementById('gearTierClassA').value = gearTierThresholds.armorClass.A;
            document.getElementById('gearTierClassB').value = gearTierThresholds.armorClass.B;
            document.getElementById('gearTierClassC').value = gearTierThresholds.armorClass.C;
            document.getElementById('gearTierClassD').value = gearTierThresholds.armorClass.D;
            document.getElementById('gearTierDurS').value = gearTierThresholds.durability.S;
            document.getElementById('gearTierDurA').value = gearTierThresholds.durability.A;
            document.getElementById('gearTierDurB').value = gearTierThresholds.durability.B;
            document.getElementById('gearTierDurC').value = gearTierThresholds.durability.C;
            document.getElementById('gearTierDurD').value = gearTierThresholds.durability.D;
        }
        function saveGearTierOverrides() { localStorage.setItem(STORAGE_KEY_GEAR_OVERRIDES, JSON.stringify(gearTierOverrides)); }
        function loadGearTierOverrides() { const s = localStorage.getItem(STORAGE_KEY_GEAR_OVERRIDES); if (s) gearTierOverrides = JSON.parse(s); }
        
        // ============================================================================
        // ATTACHMENTS MANAGER
        // ============================================================================
        
        async function loadAttachmentsData() {
            const loading = document.getElementById('attachments-loading');
            const content = document.getElementById('attachments-content');
            const error = document.getElementById('attachments-error');
            const btn = document.getElementById('btn-load-attachments');
            
            loading.classList.remove('d-none');
            content.classList.add('d-none');
            error.classList.add('d-none');
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            try {
                const query = `{
                    items(types: [mods]) {
                        id
                        name
                        shortName
                        iconLink
                        avg24hPrice
                        sellFor { price vendor { name } }
                        types
                        properties {
                            ... on ItemPropertiesMagazine {
                                capacity
                                ergonomics
                            }
                            ... on ItemPropertiesBarrel {
                                ergonomics
                                recoilModifier
                                accuracyModifier
                            }
                            ... on ItemPropertiesScope {
                                ergonomics
                                recoilModifier
                                zoomLevels
                            }
                            ... on ItemPropertiesWeaponMod {
                                ergonomics
                                recoilModifier
                                accuracyModifier
                            }
                        }
                    }
                }`;
                
                const response = await fetch('https://api.tarkov.dev/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                
                const data = await response.json();
                if (data.errors) throw new Error(data.errors[0].message);
                
                const attachments = data.data.items.map(a => {
                    const props = a.properties || {};
                    const bestSell = a.sellFor?.reduce((best, s) => s.price > best.price ? s : best, { price: 0 }) || { price: 0 };
                    
                    // Determine attachment type from types array
                    let attachType = 'other';
                    const typeMap = {
                        'scope': 'Scopes', 'sights': 'Sights', 'barrel': 'Barrels',
                        'muzzle': 'Muzzle', 'grip': 'Grips', 'stock': 'Stocks',
                        'handguard': 'Handguards', 'mount': 'Mounts', 'magazine': 'Magazines',
                        'foregrip': 'Foregrips', 'flashlight': 'Flashlights', 'laser': 'Lasers',
                        'suppressor': 'Suppressors', 'rail': 'Rails', 'receiver': 'Receivers'
                    };
                    
                    for (const [key, label] of Object.entries(typeMap)) {
                        if (a.types?.some(t => t.toLowerCase().includes(key))) {
                            attachType = label;
                            break;
                        }
                    }
                    if (attachType === 'other' && a.types?.length > 0) {
                        attachType = a.types[0];
                    }
                    
                    return {
                        id: a.id,
                        name: a.name,
                        shortName: a.shortName,
                        iconLink: a.iconLink,
                        attachType,
                        ergonomics: props.ergonomics || 0,
                        recoilModifier: props.recoilModifier || 0,
                        accuracyModifier: props.accuracyModifier || 0,
                        capacity: props.capacity || 0,
                        zoomLevels: props.zoomLevels || [],
                        sellPrice: bestSell.price,
                        sellTo: bestSell.vendor?.name || 'Fence'
                    };
                });
                
                // Group by type
                const byType = {};
                attachments.forEach(a => {
                    if (!byType[a.attachType]) byType[a.attachType] = [];
                    byType[a.attachType].push(a);
                });
                
                // Sort by tier
                Object.values(byType).forEach(arr => {
                    arr.sort((a, b) => TIER_ORDER.indexOf(getAttachmentTier(a).tier) - TIER_ORDER.indexOf(getAttachmentTier(b).tier));
                });
                
                allAttachmentsData = { all: attachments, byType };
                
                // Populate type filter
                const typeFilter = document.getElementById('attachmentTypeFilter');
                const types = Object.keys(byType).sort();
                typeFilter.innerHTML = '<option value="ALL">All Types (' + attachments.length + ')</option>' +
                    types.map(t => `<option value="${t}">${t} (${byType[t].length})</option>`).join('');
                
                document.getElementById('attachment-count').textContent = attachments.length;
                
                loading.classList.add('d-none');
                content.classList.remove('d-none');
                btn.textContent = 'Reload';
                btn.disabled = false;
                
                loadOwnedAttachments();
                loadAttachmentTierConfig();
                loadAttachmentTierOverrides();
                renderAttachmentsList();
                
            } catch (err) {
                loading.classList.add('d-none');
                error.classList.remove('d-none');
                error.textContent = 'Error loading attachments: ' + err.message;
                btn.textContent = 'Retry';
                btn.disabled = false;
            }
        }
        
        function renderAttachmentsList() {
            if (!allAttachmentsData) return;
            
            const container = document.getElementById('attachments-list');
            let html = '';
            
            const types = attachmentTypeFilter === 'ALL'
                ? Object.keys(allAttachmentsData.byType).sort()
                : [attachmentTypeFilter];
            
            types.forEach(type => {
                let items = allAttachmentsData.byType[type] || [];
                
                if (attachmentSearchQuery) {
                    const q = attachmentSearchQuery.toLowerCase();
                    items = items.filter(a => a.name.toLowerCase().includes(q) || a.shortName.toLowerCase().includes(q));
                }
                
                if (items.length === 0) return;
                
                html += `<div class="caliber-group mb-3">
                    <div class="caliber-header">${type} (${items.length})</div>
                    <div class="ammo-grid">`;
                
                items.forEach(a => {
                    const isOwned = ownedAttachments.has(a.id);
                    const tierInfo = getAttachmentTier(a);
                    const isOverridden = attachmentTierOverrides[a.id] !== undefined;
                    const sourceClass = tierInfo.source === 'ERGO' ? 'source-pen' : tierInfo.source === 'RECOIL' ? 'source-dmg' : tierInfo.source === 'ERGO+RECOIL' ? 'source-both' : '';
                    
                    const ergoDisplay = a.ergonomics >= 0 ? `+${a.ergonomics}` : a.ergonomics;
                    const recoilDisplay = a.recoilModifier >= 0 ? `+${a.recoilModifier}%` : `${a.recoilModifier}%`;
                    
                    html += `
                        <div class="ammo-card ${isOwned ? 'owned' : ''} ${isOverridden ? 'overridden' : ''}" onclick="toggleAttachmentOwned('${a.id}')">
                            <span class="tier-badge tier-${tierInfo.tier}">${tierInfo.tier}</span>
                            ${a.iconLink ? `<img src="${a.iconLink}">` : ''}
                            <div class="flex-grow-1">
                                <div class="fw-bold" style="color: var(--text-main);">${a.shortName}</div>
                                <div class="ammo-stats">
                                    <span class="stat-pen ${tierInfo.source.includes('ERGO') ? 'stat-highlight' : ''}">ERG ${ergoDisplay}</span>
                                    <span class="stat-dmg ${tierInfo.source.includes('RECOIL') ? 'stat-highlight' : ''}">REC ${recoilDisplay}</span>
                                    ${a.sellPrice > 0 ? `<span class="stat-price">${a.sellPrice.toLocaleString()}</span>` : ''}
                                </div>
                            </div>
                            <span class="tier-source ${sourceClass}">${tierInfo.source}</span>
                            ${isOwned ? '<span class="badge-tarkov badge-active">OWNED</span>' : ''}
                            <select class="tier-select-mini" onclick="event.stopPropagation()" onchange="setAttachmentTierOverride('${a.id}', this.value)">
                                <option value="" ${!isOverridden ? 'selected' : ''}>Auto</option>
                                ${TIER_NAMES.map(t => `<option value="${t}" ${attachmentTierOverrides[a.id] === t ? 'selected' : ''}>${t}</option>`).join('')}
                            </select>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            container.innerHTML = html || '<div class="text-sub p-3">No attachments match your filter.</div>';
            updateAttachmentAnalysis();
        }
        
        function getAttachmentTier(attach) {
            if (attachmentTierOverrides[attach.id]) return { tier: attachmentTierOverrides[attach.id], source: 'CUSTOM' };
            
            const ergo = attach.ergonomics;
            const recoil = attach.recoilModifier;
            
            for (const tier of ['S', 'A', 'B', 'C', 'D']) {
                const ergoMet = ergo >= attachmentTierThresholds.ergoMod[tier];
                const recoilMet = recoil <= attachmentTierThresholds.recoilMod[tier];
                
                if (ergoMet || recoilMet) {
                    let source = '';
                    if (ergoMet && recoilMet) source = 'ERGO+RECOIL';
                    else if (ergoMet) source = 'ERGO';
                    else source = 'RECOIL';
                    return { tier, source };
                }
            }
            return { tier: 'F', source: '-' };
        }
        
        function filterAttachments() {
            attachmentTypeFilter = document.getElementById('attachmentTypeFilter').value;
            attachmentSearchQuery = document.getElementById('attachmentSearch').value;
            renderAttachmentsList();
        }
        
        function toggleAttachmentOwned(id) {
            ownedAttachments.has(id) ? ownedAttachments.delete(id) : ownedAttachments.add(id);
            saveOwnedAttachments();
            renderAttachmentsList();
        }
        
        function setAttachmentTierOverride(id, tier) {
            if (tier === '') delete attachmentTierOverrides[id];
            else attachmentTierOverrides[id] = tier;
            saveAttachmentTierOverrides();
            renderAttachmentsList();
        }
        
        function updateAttachmentTierConfig() {
            attachmentTierThresholds.ergoMod.S = parseInt(document.getElementById('attachTierErgoS').value) || 15;
            attachmentTierThresholds.ergoMod.A = parseInt(document.getElementById('attachTierErgoA').value) || 10;
            attachmentTierThresholds.ergoMod.B = parseInt(document.getElementById('attachTierErgoB').value) || 5;
            attachmentTierThresholds.ergoMod.C = parseInt(document.getElementById('attachTierErgoC').value) || 2;
            attachmentTierThresholds.ergoMod.D = parseInt(document.getElementById('attachTierErgoD').value) || 0;
            attachmentTierThresholds.recoilMod.S = parseInt(document.getElementById('attachTierRecoilS').value) || -5;
            attachmentTierThresholds.recoilMod.A = parseInt(document.getElementById('attachTierRecoilA').value) || -3;
            attachmentTierThresholds.recoilMod.B = parseInt(document.getElementById('attachTierRecoilB').value) || -1;
            attachmentTierThresholds.recoilMod.C = parseInt(document.getElementById('attachTierRecoilC').value) || 0;
            attachmentTierThresholds.recoilMod.D = parseInt(document.getElementById('attachTierRecoilD').value) || 2;
            saveAttachmentTierConfig();
            renderAttachmentsList();
        }
        
        function resetAttachmentTierConfig() {
            attachmentTierThresholds = JSON.parse(JSON.stringify(DEFAULT_ATTACHMENT_TIER_THRESHOLDS));
            document.getElementById('attachTierErgoS').value = attachmentTierThresholds.ergoMod.S;
            document.getElementById('attachTierErgoA').value = attachmentTierThresholds.ergoMod.A;
            document.getElementById('attachTierErgoB').value = attachmentTierThresholds.ergoMod.B;
            document.getElementById('attachTierErgoC').value = attachmentTierThresholds.ergoMod.C;
            document.getElementById('attachTierErgoD').value = attachmentTierThresholds.ergoMod.D;
            document.getElementById('attachTierRecoilS').value = attachmentTierThresholds.recoilMod.S;
            document.getElementById('attachTierRecoilA').value = attachmentTierThresholds.recoilMod.A;
            document.getElementById('attachTierRecoilB').value = attachmentTierThresholds.recoilMod.B;
            document.getElementById('attachTierRecoilC').value = attachmentTierThresholds.recoilMod.C;
            document.getElementById('attachTierRecoilD').value = attachmentTierThresholds.recoilMod.D;
            saveAttachmentTierConfig();
            renderAttachmentsList();
        }
        
        function clearAttachmentOverrides() {
            attachmentTierOverrides = {};
            saveAttachmentTierOverrides();
            renderAttachmentsList();
        }
        
        function updateAttachmentTierThreshold() {
            const val = parseInt(document.getElementById('attachmentTierSlider').value);
            currentAttachmentTierThreshold = TIER_ORDER[val];
            document.getElementById('attachmentTierDisplay').textContent = `Keep ${currentAttachmentTierThreshold}-Tier+`;
            updateAttachmentAnalysis();
        }
        
        function updateAttachmentAnalysis() {
            if (!allAttachmentsData) return;
            
            const tierIndex = TIER_ORDER.indexOf(currentAttachmentTierThreshold);
            const keepTiers = TIER_ORDER.slice(0, tierIndex + 1);
            
            const owned = allAttachmentsData.all.filter(a => ownedAttachments.has(a.id));
            const keep = owned.filter(a => keepTiers.includes(getAttachmentTier(a).tier));
            const sell = owned.filter(a => !keepTiers.includes(getAttachmentTier(a).tier));
            
            document.getElementById('attachment-keep-count').textContent = keep.length;
            document.getElementById('attachment-sell-count').textContent = sell.length;
            
            document.getElementById('attachment-keep-list').innerHTML = keep.length > 0
                ? keep.map(a => renderEquipmentAnalysisItem(a, 'keep', getAttachmentTier(a))).join('')
                : '<div class="text-sub p-2 small">No attachments to keep marked.</div>';
            
            document.getElementById('attachment-sell-list').innerHTML = sell.length > 0
                ? sell.map(a => renderEquipmentAnalysisItem(a, 'sell', getAttachmentTier(a))).join('')
                : '<div class="text-sub p-2 small">No attachments to sell.</div>';
            
            document.getElementById('attachment-total-sell-value').textContent =
                sell.reduce((sum, a) => sum + (a.sellPrice || 0), 0).toLocaleString() + ' RUB';
        }
        
        function saveOwnedAttachments() { localStorage.setItem(STORAGE_KEY_ATTACHMENTS, JSON.stringify([...ownedAttachments])); }
        function loadOwnedAttachments() { const s = localStorage.getItem(STORAGE_KEY_ATTACHMENTS); if (s) ownedAttachments = new Set(JSON.parse(s)); }
        function saveAttachmentTierConfig() { localStorage.setItem(STORAGE_KEY_ATTACHMENTS_TIER, JSON.stringify(attachmentTierThresholds)); }
        function loadAttachmentTierConfig() {
            const s = localStorage.getItem(STORAGE_KEY_ATTACHMENTS_TIER);
            if (s) attachmentTierThresholds = JSON.parse(s);
            document.getElementById('attachTierErgoS').value = attachmentTierThresholds.ergoMod.S;
            document.getElementById('attachTierErgoA').value = attachmentTierThresholds.ergoMod.A;
            document.getElementById('attachTierErgoB').value = attachmentTierThresholds.ergoMod.B;
            document.getElementById('attachTierErgoC').value = attachmentTierThresholds.ergoMod.C;
            document.getElementById('attachTierErgoD').value = attachmentTierThresholds.ergoMod.D;
            document.getElementById('attachTierRecoilS').value = attachmentTierThresholds.recoilMod.S;
            document.getElementById('attachTierRecoilA').value = attachmentTierThresholds.recoilMod.A;
            document.getElementById('attachTierRecoilB').value = attachmentTierThresholds.recoilMod.B;
            document.getElementById('attachTierRecoilC').value = attachmentTierThresholds.recoilMod.C;
            document.getElementById('attachTierRecoilD').value = attachmentTierThresholds.recoilMod.D;
        }
        function saveAttachmentTierOverrides() { localStorage.setItem(STORAGE_KEY_ATTACHMENTS_OVERRIDES, JSON.stringify(attachmentTierOverrides)); }
        function loadAttachmentTierOverrides() { const s = localStorage.getItem(STORAGE_KEY_ATTACHMENTS_OVERRIDES); if (s) attachmentTierOverrides = JSON.parse(s); }
        
        // ============================================================================
        // SHARED EQUIPMENT ANALYSIS RENDERER
        // ============================================================================
        
        function renderEquipmentAnalysisItem(item, type, tierInfo) {
            return `
                <div class="item-box ${type === 'keep' ? 'status-provided' : 'status-acquire'} w-100 mb-1">
                    <span class="tier-badge tier-${tierInfo.tier}" style="width:24px;height:24px;line-height:24px;font-size:0.75rem;">${tierInfo.tier}</span>
                    ${item.iconLink ? `<img src="${item.iconLink}" style="width:28px;height:28px;">` : ''}
                    <div class="flex-grow-1">
                        <div style="font-size:0.85rem;">${item.shortName}</div>
                        <div style="font-size:0.7rem;color:var(--text-sub);">${item.caliber || item.gearType || item.attachType || ''}</div>
                    </div>
                    ${type === 'sell' && item.sellPrice > 0 ? `<span class="stat-price small">${item.sellPrice.toLocaleString()} RUB</span>` : ''}
                </div>
            `;
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        document.addEventListener('DOMContentLoaded', async () => {
            loadSavedAmmo();
            loadTierConfig();
            loadTierOverrides();
            
            // Load quest locations from tarkovdata
            await loadQuestLocationsData();
            
            // Load quests from backend
            await loadQuests();
            
            // Update map selection based on any saved quest selections
            updateMapSelection();
            
            // Initialize map without markers (markers appear after Plan Raid)
            initMap('customs', []);
        });
    </script>
</body>
</html>
